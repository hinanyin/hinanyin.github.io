<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue 源码解析 组件通信</title>
      <link href="/articles/vue/communication/"/>
      <url>/articles/vue/communication/</url>
      
        <content type="html"><![CDATA[<h3 id="props-emit"><a href="#props-emit" class="headerlink" title="props / $emit"></a>props / $emit</h3><h3 id="parent-children"><a href="#parent-children" class="headerlink" title="$parent / $children"></a>$parent / $children</h3><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="$dispatch"></a>$dispatch</h3><blockquote><p>一直递归找父组件，然后执行父组件中对应的 $emit 方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$dispatch</span> = <span class="keyword">function</span> (<span class="params">eventName, newValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> parent = <span class="variable language_">this</span>.<span class="property">$parent</span>;</span><br><span class="line">  <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    parent.$emit(eventName, newValue);</span><br><span class="line">    parent = parent.<span class="property">$parent</span>; <span class="comment">// 继续递归接着往上找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="broadcast"><a href="#broadcast" class="headerlink" title="$broadcast"></a>$broadcast</h3><blockquote><p>一直往归找子元素，执行对应的方法执行</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$broadcast</span> = <span class="keyword">function</span> (<span class="params">eventName, newValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> children = <span class="variable language_">this</span>.<span class="property">$children</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">broad</span>(<span class="params">children</span>) &#123;</span><br><span class="line">    children.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      child.$emit(eventName, newValue);</span><br><span class="line">      <span class="keyword">if</span> (child.<span class="property">$children</span>) &#123;</span><br><span class="line">        <span class="title function_">broad</span>(child.<span class="property">$children</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">broad</span>(children);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="sync-v-model"><a href="#sync-v-model" class="headerlink" title=".sync / v-model"></a>.sync / v-model</h3><blockquote><p>props 和 $emit 的语法糖</p><ul><li>只需要将 $emit(fn) 中的 fn 改为 update:xxx 就可以了，其中 xxx 为父组件传递给子组件的数据名</li><li>在子组件中调用 $emit(fn, val) 的时候 fn 的名字一定是这样的格式的 update:xxx</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Son</span> @<span class="attr">update</span>:number=<span class="string">&quot;newValue =&gt;number = newValue&quot;</span> :number=<span class="string">&quot;number&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.vue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>更新父组件的方法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:number&#x27;</span>, <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Son</span> @<span class="attr">update</span>:number=<span class="string">&quot;newValue =&gt; number = newValue&quot;</span> :number=<span class="string">&quot;number&quot;</span> /&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">:number.sync</span>=<span class="string">&quot;number&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="attrs-和-listeners"><a href="#attrs-和-listeners" class="headerlink" title="$attrs 和 $listeners"></a>$attrs 和 $listeners</h3><blockquote><p>$attrs 和 v-bind</p><ul><li>场景: 要将父组件的数据传递给孙组件，但是我们的子组件又没有使用到这些数据，这个时候可以使用 $attrs 了</li><li>局限性: 子组件不可以接收父组件的数据，也就是不可以有 props 钩子</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Son</span> :number=<span class="string">&quot;number&quot;</span> :count=<span class="string">&quot;count&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.vue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Grandson.vue</span></span><br><span class="line">&#123;&#123; $attrs &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>$listeners 和 v-on</p><ul><li>通过 $listeners 和 v-on 的配合可以将全部事件传递给孙组件，子组件也是可以通过 $listeners 来接收父组件传递的全部事件</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Son</span> :number=<span class="string">&quot;number&quot;</span> @change=<span class="string">&quot;change&quot;</span> @say=<span class="string">&quot;say&quot;</span> :count=<span class="string">&quot;count&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.vue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Grandson.vue</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$listeners</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="eventbus"><a href="#eventbus" class="headerlink" title="eventbus"></a>eventbus</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bug</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(); <span class="comment">// Vue本身就是具有发布订阅能力的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件A - 在组件A中发布事件</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&quot;change&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件B - 在组件B中可以订阅这个事件实现通信</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&quot;change&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅事件</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布事件</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">cb</span>(...args);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[eventName] = <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">filter</span>(</span><br><span class="line">        <span class="function">(<span class="params">cb</span>) =&gt;</span> cb !== callback</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> ee = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&quot;sayHi&quot;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&quot;sayHi&quot;</span>); <span class="comment">// Hello!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cb</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&quot;sayHi&quot;</span>, cb);</span><br><span class="line">ee.<span class="title function_">off</span>(<span class="string">&quot;sayHi&quot;</span>, cb);</span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&quot;sayHi&quot;</span>); <span class="comment">// 没有输出</span></span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">vm</span>: <span class="variable language_">this</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;vm&#x27;</span>],</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">vm</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 keep-alive</title>
      <link href="/articles/vue/keepAlive/"/>
      <url>/articles/vue/keepAlive/</url>
      
        <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 逗号分隔字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><ul><li>include: 字符串或正则表达式。只有名称匹配的组件会被缓存</li><li>exclude: 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li><li>max: 数字。最多可以缓存多少组件实例</li></ul></blockquote><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><blockquote><ul><li>匹配时首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，也就是组件的标签值。匿名组件不能被匹配</li><li>max 表示最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉 (LRU)</li><li><code>&lt;keep-alive&gt;</code> 只处理第一个子元素，所以一般和它搭配使用的有 component 动态组件或者是 router-view</li></ul></blockquote><div class="tip warning"><p>删除缓存组件并且为什么命中缓存了需要调整组件 key 的顺序：<br>缓存淘汰策略 LRU (Least recently used，最近最少使用) ，如果数据最近被访问过，那么将来被访问的几率也更高</p></div><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><blockquote><ul><li>组件一旦被 <code>&lt;keep-alive&gt;</code> 缓存，那么再次渲染的时候就不会执行 created、mounted 等钩子函数</li><li>activated 和 deactivated，执行时机是 <code>&lt;keep-alive&gt;</code> 包裹的组件激活时调用和停用时调用</li></ul></blockquote><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><blockquote><p>缓存机制</p><ul><li>将新数据从尾部插入到 this.keys 中</li><li>每当缓存命中 (即缓存数据被访问)，则将数据移到 this.keys 的尾部</li><li>当 this.keys 满的时候，将头部的数据丢弃</li></ul></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式组件，执行 &lt;keep-alive&gt; 组件渲染的时候，就会执行 render 函数</span></span><br><span class="line">() =&gt; (&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="attr">abstract</span>: <span class="literal">true</span>,</span><br><span class="line">  </span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">include</span>: [<span class="title class_">String</span>, <span class="title class_">RegExp</span>, <span class="title class_">Array</span>],</span><br><span class="line">      <span class="attr">exclude</span>: [<span class="title class_">String</span>, <span class="title class_">RegExp</span>, <span class="title class_">Array</span>],</span><br><span class="line">      <span class="attr">max</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="title function_">created</span> () &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// 存储需要缓存的组件，this.cache = &#123; &#x27;key1&#x27;:&#x27;组件1&#x27;, &#x27;key2&#x27;:&#x27;组件2&#x27;, // ... &#125;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">keys</span> = [] <span class="comment">// 存储每个需要缓存的组件的key，即对应this.cache对象中的键值</span></span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="title function_">destroyed</span> () &#123;</span><br><span class="line">        <span class="comment">// 将那些被缓存的并且当前没有处于被渲染状态的组件都销毁掉并将其从this.cache对象中剔除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">            <span class="title function_">pruneCacheEntry</span>(<span class="variable language_">this</span>.<span class="property">cache</span>, key, <span class="variable language_">this</span>.<span class="property">keys</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pruneCacheEntry函数</span></span><br><span class="line">    <span class="title function_">pruneCacheEntry</span> (cache,key,keys,current) &#123;</span><br><span class="line">        <span class="keyword">const</span> cached = cache[key]</span><br><span class="line">        <span class="comment">/* 判断当前没有处于被渲染状态的组件，将其销毁*/</span></span><br><span class="line">        <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.<span class="property">tag</span> !== current.<span class="property">tag</span>)) &#123;</span><br><span class="line">        cached.<span class="property">componentInstance</span>.$destroy()</span><br><span class="line">        &#125;</span><br><span class="line">        cache[key] = <span class="literal">null</span></span><br><span class="line">        <span class="title function_">remove</span>(keys, key)</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果include 或exclude 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行pruneCache函数</span></span><br><span class="line">    <span class="title function_">mounted</span> () &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> <span class="title function_">matches</span>(val, name))</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> !<span class="title function_">matches</span>(val, name))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该函数内对this.cache对象进行遍历，取出每一项的name值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，</span></span><br><span class="line">    <span class="comment">// 则调用pruneCacheEntry函数将这个已经不需要缓存的组件实例先销毁掉，然后再将其从this.cache对象中剔除</span></span><br><span class="line">    <span class="title function_">pruneCache</span> (keepAliveInstance, filter) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; cache, keys, _vnode &#125; = keepAliveInstance</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">          <span class="keyword">const</span> cachedNode = cache[key]</span><br><span class="line">          <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">            <span class="keyword">const</span> name = <span class="title function_">getComponentName</span>(cachedNode.<span class="property">componentOptions</span>)</span><br><span class="line">            <span class="keyword">if</span> (name &amp;&amp; !<span class="title function_">filter</span>(name)) &#123;</span><br><span class="line">              <span class="title function_">pruneCacheEntry</span>(cache, key, keys, _vnode)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">    <span class="title function_">pruneCacheEntry</span> (cache,key,keys,current) &#123;</span><br><span class="line">        <span class="keyword">const</span> cached = cache[key]</span><br><span class="line">        <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.<span class="property">tag</span> !== current.<span class="property">tag</span>)) &#123;</span><br><span class="line">          cached.<span class="property">componentInstance</span>.$destroy()</span><br><span class="line">        &#125;</span><br><span class="line">        cache[key] = <span class="literal">null</span></span><br><span class="line">        <span class="title function_">remove</span>(keys, key)</span><br><span class="line">      &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">/* 获取默认插槽中的第一个组件节点 */</span></span><br><span class="line">      <span class="keyword">const</span> slot = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span></span><br><span class="line">      <span class="keyword">const</span> vnode = <span class="title function_">getFirstComponentChild</span>(slot)</span><br><span class="line">      <span class="comment">/* 获取该组件节点的componentOptions */</span></span><br><span class="line">      <span class="keyword">const</span> componentOptions = vnode &amp;&amp; vnode.<span class="property">componentOptions</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">        <span class="comment">/* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */</span></span><br><span class="line">        <span class="keyword">const</span> name = <span class="title function_">getComponentName</span>(componentOptions)</span><br><span class="line">        <span class="comment">/* 优先获取组件的name字段，如果name不存在则获取组件的tag */</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getComponentName</span> (<span class="params">opts</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> opts &amp;&amp; (opts.<span class="property">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || opts.<span class="property">tag</span>)</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="variable language_">this</span></span><br><span class="line">        <span class="comment">/* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          (include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))) ||</span><br><span class="line">          <span class="comment">// excluded</span></span><br><span class="line">          (exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> vnode</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="variable language_">this</span></span><br><span class="line">        <span class="comment">/* 获取组件的key */</span></span><br><span class="line">        <span class="keyword">const</span> key = vnode.<span class="property">key</span> == <span class="literal">null</span></span><br><span class="line">          <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">          <span class="comment">// so cid alone is not enough (##3269)</span></span><br><span class="line">          ? componentOptions.<span class="property">Ctor</span>.<span class="property">cid</span> + (componentOptions.<span class="property">tag</span> ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">          : vnode.<span class="property">key</span></span><br><span class="line">        <span class="comment">/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */</span></span><br><span class="line">        <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">          vnode.<span class="property">componentInstance</span> = cache[key].<span class="property">componentInstance</span></span><br><span class="line">          <span class="comment">/* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */</span></span><br><span class="line">          <span class="title function_">remove</span>(keys, key)</span><br><span class="line">          keys.<span class="title function_">push</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果没有命中缓存，则将其设置进缓存 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          cache[key] = vnode</span><br><span class="line">          keys.<span class="title function_">push</span>(key)</span><br><span class="line">          <span class="comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">max</span> &amp;&amp; keys.<span class="property">length</span> &gt; <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">max</span>)) &#123;</span><br><span class="line">            <span class="title function_">pruneCacheEntry</span>(cache, keys[<span class="number">0</span>], keys, <span class="variable language_">this</span>.<span class="property">_vnode</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* 最后设置keepAlive标记位 */</span></span><br><span class="line">        vnode.<span class="property">data</span>.<span class="property">keepAlive</span> = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 指令</title>
      <link href="/articles/vue/directive/"/>
      <url>/articles/vue/directive/</url>
      
        <content type="html"><![CDATA[<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><blockquote><p>全局: Vue.directive —-&gt; 存放在 <code>Vue.options[&#39;directives&#39;]</code>中<br>局部: 组件内的 directive 选项中定义 —-&gt; 存放在 <code>vm.$options[&#39;directives&#39;]</code> 中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;&lt;/input&gt;;</span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="监听时机"><a href="#监听时机" class="headerlink" title="监听时机"></a>监听时机</h3><h4 id="钩子触发时机"><a href="#钩子触发时机" class="headerlink" title="钩子触发时机"></a>钩子触发时机</h4><blockquote><p>init</p><ul><li>触发时机: 已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</li><li>回调参数: VNode</li></ul><p>create</p><ul><li>触发时机: 已基于 VNode 创建了 DOM 元素</li><li>回调参数: emptyNode 和 VNode</li></ul><p>activate</p><ul><li>触发时机: keep-alive 组件被创建</li><li>回调参数: emptyNode 和 VNode</li></ul><p>insert</p><ul><li>触发时机: VNode 对应的 DOM 元素被插入到父节点中时被触发</li><li>回调参数: VNode</li></ul><p>prepatch</p><ul><li>触发时机: 一个 VNode 即将被 patch 前触发</li><li>回调参数: oldVNode 和 VNode</li></ul><p>update</p><ul><li>触发时机: 一个 VNode 更新时触发</li><li>回调参数: oldVNode 和 VNode</li></ul><p>postpatch</p><ul><li>触发时机: 一个 VNode 被 patch 完毕时触发</li><li>回调参数: oldVNode 和 VNode</li></ul><p>destory</p><ul><li>触发时机: 一个 VNode 对应的 DOM 元素从 DOM 中移除时或者它的父元素从 DOM 中移除时触发</li><li>回调参数: VNode</li></ul><p>remove</p><ul><li>触发时机: 一个 VNode 对应的 DOM 元素从 DOM 中移除时触发。与 destory 不同的是，如果是直接将该 VNode 的父元素从 DOM 中移除导致该元素被移除，那么不会触发</li><li>回调参数: VNode 和 removeCallback</li></ul></blockquote><div class="tip success"><p>在 create、update、destory 三个阶段监听自定义指令</p></div><h3 id="指令钩子函数"><a href="#指令钩子函数" class="headerlink" title="指令钩子函数"></a>指令钩子函数</h3><blockquote><p>Vue 对于自定义指令定义对象提供了几个钩子函数，这几个钩子函数分别对应着指令的几种状态，一个指令从第一次被绑定到元素上到最终与被绑定的元素解绑，它会经过以下几种状态</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li><li>inserted: 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</li><li>update: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前</li><li>componentUpdated: 指令所在组件的 VNode 及其子 VNode 全部更新后调用</li><li>unbind: 只调用一次，指令与元素解绑时调用</li></ul><p>updateDirectives: 在合适的时机执行定义指令时所设置的钩子函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateDirectives</span>(<span class="params">oldVnode, vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode.<span class="property">data</span>.<span class="property">directives</span> || vnode.<span class="property">data</span>.<span class="property">directives</span>) &#123;</span><br><span class="line">    <span class="title function_">_update</span>(oldVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_update</span>(<span class="params">oldVnode, vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isCreate = oldVnode === emptyNode; <span class="comment">// 判断当前节点vnode对应的旧节点oldVnode是不是一个空节点，如果是的话，表明当前节点是一个新创建的节点</span></span><br><span class="line">  <span class="keyword">const</span> isDestroy = vnode === emptyNode; <span class="comment">// 判断当前节点vnode是不是一个空节点，如果是的话，表明当前节点对应的旧节点将要被销毁</span></span><br><span class="line">  <span class="keyword">const</span> oldDirs = <span class="title function_">normalizeDirectives</span>(</span><br><span class="line">    oldVnode.<span class="property">data</span>.<span class="property">directives</span>,</span><br><span class="line">    oldVnode.<span class="property">context</span></span><br><span class="line">  ); <span class="comment">// 旧的指令集合，即oldVnode中保存的指令</span></span><br><span class="line">  <span class="keyword">const</span> newDirs = <span class="title function_">normalizeDirectives</span>(vnode.<span class="property">data</span>.<span class="property">directives</span>, vnode.<span class="property">context</span>); <span class="comment">// 新的指令集合，即vnode中保存的指令</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dirsWithInsert = []; <span class="comment">// 保存需要触发inserted指令钩子函数的指令列表</span></span><br><span class="line">  <span class="keyword">const</span> dirsWithPostpatch = []; <span class="comment">// 保存需要触发componentUpdated指令钩子函数的指令列表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key, oldDir, dir;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> newDirs) &#123;</span><br><span class="line">    oldDir = oldDirs[key];</span><br><span class="line">    dir = newDirs[key];</span><br><span class="line">    <span class="keyword">if</span> (!oldDir) &#123;</span><br><span class="line">      <span class="comment">// 判断当前循环到的指令名key在旧的指令列表oldDirs中是否存在，如果不存在，说明该指令是首次绑定到元素上的一个新指令，此时调用callHook触发指令中的bind钩子函数</span></span><br><span class="line">      <span class="title function_">callHook</span>(dir, <span class="string">&quot;bind&quot;</span>, vnode, oldVnode);</span><br><span class="line">      <span class="comment">// 判断如果该新指令在定义时设置了inserted钩子函数，那么将该指令添加到dirsWithInsert中，以保证执行完所有指令的bind钩子函数后再执行指令的inserted钩子函数</span></span><br><span class="line">      <span class="keyword">if</span> (dir.<span class="property">def</span> &amp;&amp; dir.<span class="property">def</span>.<span class="property">inserted</span>) &#123;</span><br><span class="line">        dirsWithInsert.<span class="title function_">push</span>(dir);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前循环到的指令名key在旧的指令列表oldDirs中存在时，说明该指令在之前已经绑定过了，那么这一次的操作应该是更新指令</span></span><br><span class="line">      dir.<span class="property">oldValue</span> = oldDir.<span class="property">value</span>;</span><br><span class="line">      dir.<span class="property">oldArg</span> = oldDir.<span class="property">arg</span>;</span><br><span class="line">      <span class="comment">// 保存上一次指令的value属性值和arg属性值，然后调用callHook触发指令中的update钩子函数</span></span><br><span class="line">      <span class="title function_">callHook</span>(dir, <span class="string">&quot;update&quot;</span>, vnode, oldVnode);</span><br><span class="line">      <span class="comment">// 判断如果该指令在定义时设置了componentUpdated钩子函数，那么将该指令添加到dirsWithPostpatch中，以保证让指令所在的组件的VNode及其子VNode全部更新完后再执行指令的componentUpdated钩子函数</span></span><br><span class="line">      <span class="keyword">if</span> (dir.<span class="property">def</span> &amp;&amp; dir.<span class="property">def</span>.<span class="property">componentUpdated</span>) &#123;</span><br><span class="line">        dirsWithPostpatch.<span class="title function_">push</span>(dir);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断dirsWithInsert数组中是否有元素，如果有，则循环dirsWithInsert数组，依次执行每一个指令的inserted钩子函数</span></span><br><span class="line">  <span class="keyword">if</span> (dirsWithInsert.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 并没有直接去循环执行每一个指令的inserted钩子函数，而是新创建了一个callInsert函数，当执行该函数的时候才会去循环执行每一个指令的inserted钩子函数</span></span><br><span class="line">    <span class="comment">// ==&gt; 1. 因为指令的inserted钩子函数必须在被绑定元素插入到父节点时调用，那么如果是一个新增的节点，如何保证它已经被插入到父节点了呢</span></span><br><span class="line">    <span class="comment">// 2. 当DOM节点在被插入到父节点时会触发insert函数，当虚拟DOM渲染更新的insert钩子函数被调用的时候就标志着当前节点已经被插入到父节点了，所以要在虚拟DOM渲染更新的insert钩子函数内执行指令的inserted钩子函数</span></span><br><span class="line">    <span class="comment">// 3. 当一个新创建的元素被插入到父节点中时虚拟DOM渲染更新的insert钩子函数和指令的inserted钩子函数都要被触发</span></span><br><span class="line">    <span class="comment">// 4. 可以把这两个钩子函数通过调用mergeVNodeHook方法进行合并，然后统一在虚拟DOM渲染更新的insert钩子函数中触发，就保证了元素确实被插入到父节点中才执行的指令的inserted钩子函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">callInsert</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dirsWithInsert.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(dirsWithInsert[i], <span class="string">&quot;inserted&quot;</span>, vnode, oldVnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (isCreate) &#123;</span><br><span class="line">      <span class="title function_">mergeVNodeHook</span>(vnode, <span class="string">&quot;insert&quot;</span>, callInsert);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">callInsert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要保证指令所在的组件的VNode及其子VNode全部更新完后再执行指令的componentUpdated钩子函数，所以将虚拟DOM渲染更新的postpatch钩子函数和指令的componentUpdated钩子函数进行合并触发</span></span><br><span class="line">  <span class="keyword">if</span> (dirsWithPostpatch.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="title function_">mergeVNodeHook</span>(vnode, <span class="string">&quot;postpatch&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dirsWithPostpatch.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(dirsWithPostpatch[i], <span class="string">&quot;componentUpdated&quot;</span>, vnode, oldVnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当newDirs循环完毕后，再循环oldDirs，如果某个指令存在于旧的指令列表oldDirs而在新的指令列表newDirs中不存在，那说明该指令是被废弃的，所以则触发指令的unbind钩子函数对指令进行解绑</span></span><br><span class="line">  <span class="keyword">if</span> (!isCreate) &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> oldDirs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!newDirs[key]) &#123;</span><br><span class="line">        <span class="comment">// no longer present, unbind</span></span><br><span class="line">        <span class="title function_">callHook</span>(oldDirs[key], <span class="string">&quot;unbind&quot;</span>, oldVnode, oldVnode, isDestroy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normalizeDirectives 用来模板中使用到的指令从存放指令的地方取出来，并将其格式进行统一化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeDirectives</span>(<span class="params">dirs, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (!dirs) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> i, dir;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dirs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    dir = dirs[i];</span><br><span class="line">    <span class="keyword">if</span> (!dir.<span class="property">modifiers</span>) &#123;</span><br><span class="line">      dir.<span class="property">modifiers</span> = emptyModifiers;</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="title function_">getRawDirName</span>(dir)] = dir;</span><br><span class="line">    dir.<span class="property">def</span> = <span class="title function_">resolveAsset</span>(vm.<span class="property">$options</span>, <span class="string">&quot;directives&quot;</span>, dir.<span class="property">name</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------&gt;  转化后结果</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     &#x27;v-focus&#x27;:&#123;</span></span><br><span class="line"><span class="comment">//         name : &#x27;focus&#x27; ,  // 指令的名称</span></span><br><span class="line"><span class="comment">//         value : &#x27;&#x27;,       // 指令的值</span></span><br><span class="line"><span class="comment">//         arg:&#x27;&#x27;,           // 指令的参数</span></span><br><span class="line"><span class="comment">//         modifiers:&#123;&#125;,     // 指令的修饰符</span></span><br><span class="line"><span class="comment">//         def:&#123;</span></span><br><span class="line"><span class="comment">//             inserted:fn</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 过滤器</title>
      <link href="/articles/vue/filter/"/>
      <url>/articles/vue/filter/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>质上就是一个 JS 函数</p></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><blockquote><p>双花括号插值中和在 v-bind 表达式中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">v-bind:id=&quot;rawId | formatId&quot;</span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>组件的选项中定义局部过滤器，优先级高</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">filters</span>: &#123;</span><br><span class="line">    <span class="attr">capitalize</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      value = value.<span class="title function_">toString</span>();</span><br><span class="line">      <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>创建 Vue 实例之前使用全局 API，Vue.filter 定义全局过滤器</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&quot;capitalize&quot;</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  value = value.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="串联过滤器"><a href="#串联过滤器" class="headerlink" title="串联过滤器"></a>串联过滤器</h3><blockquote><p><code>&#123;&#123; message | filterA | filterB &#125;&#125;</code></p><ul><li>message 做为参数传给 A，运算结果在穿过 B</li></ul><p><code>&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</code></p><ul><li>filterA 被定义为接受 3 个参数，message 为第一个参数</li></ul></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p><code>src/core/instance/render-helpers.js</code></p><ul><li>模板编译阶段会生成 _f 函数调用字符串，即 resolveFilter 函数，当执行渲染函数的时候，就会执行 _f 函数，从而让过滤器生效</li><li>根据过滤器 id 获取到对应的过滤器函数，然后传入参数调用即可</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveFilter</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolveAsset</span>(<span class="variable language_">this</span>.<span class="property">$options</span>, <span class="string">&quot;filters&quot;</span>, id, <span class="literal">true</span>) || identity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">identity</span> = (<span class="params">_</span>) =&gt; _;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; options 当前实例的$options属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; type 为filters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; id 当前过滤器的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">warnMissing</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> 根据过滤器id获取到用户定义的对应的过滤器函数并返回，拿到用户定义的过滤器函数之后，就可以调用该函数并传入参数使其生效了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveAsset</span>(<span class="params">options, type, id, warnMissing</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id !== <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 两种方式定义的过滤器都会被收集到当前实例的 $options 中，其中使用 Vue.filter 定义的过滤器会被添加到 $options 中的 filters 属性中</span></span><br><span class="line">  <span class="keyword">const</span> assets = options[type];</span><br><span class="line">  <span class="comment">// 先从本地注册中查找</span></span><br><span class="line">  <span class="comment">// 1. 检查assets自身中是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, id)) <span class="keyword">return</span> assets[id];</span><br><span class="line">  <span class="comment">// 2. 将过滤器id转化成驼峰式后再次查找</span></span><br><span class="line">  <span class="keyword">const</span> camelizedId = <span class="title function_">camelize</span>(id);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, camelizedId)) <span class="keyword">return</span> assets[camelizedId];</span><br><span class="line">  <span class="comment">// 3. 将过滤器id转化成首字母大写后再次查找</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">PascalCaseId</span> = <span class="title function_">capitalize</span>(camelizedId);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(assets, <span class="title class_">PascalCaseId</span>)) <span class="keyword">return</span> assets[<span class="title class_">PascalCaseId</span>];</span><br><span class="line">  <span class="comment">// 4. 再从原型链中查找，还不存在，则在非生产环境下抛出警告</span></span><br><span class="line">  <span class="keyword">const</span> res = assets[id] || assets[camelizedId] || assets[<span class="title class_">PascalCaseId</span>];</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; warnMissing &amp;&amp; !res) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&quot;Failed to resolve &quot;</span> + type.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>) + <span class="string">&quot;: &quot;</span> + id, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串联过滤器-1"><a href="#串联过滤器-1" class="headerlink" title="串联过滤器"></a>串联过滤器</h2><blockquote><p>与单个过滤器有所区别的是: 对于多个串联过滤器，在调用过滤器函数传递参数时，后一个过滤器的输入参数是前一个过滤器的输出结果</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line">// ===&gt; 编译成 _f(&quot;capitalize&quot;)(message)</span><br><span class="line">// 1. 截取字符串拿到 _f(&quot;capitalize&quot;) 中定义的 capitalize 函数</span><br><span class="line">// 2. 传入 message 参数执行 capitalize 函数</span><br><span class="line"></span><br><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br><span class="line">// ===&gt; 编译成 _f(&quot;filterB&quot;)(_f(&quot;filterA&quot;)(message))</span><br><span class="line"></span><br><span class="line">&#123;&#123; message | filterA | filterB(arg) &#125;&#125;</span><br><span class="line">// ===&gt; 编译成 _f(&quot;filterB&quot;)(_f(&quot;filterA&quot;)(message), arg)</span><br><span class="line">// 当过滤器接收其余参数时，它的参数都是从第二个参数开始往后传入的</span><br></pre></td></tr></table></figure><h2 id="解析过滤器"><a href="#解析过滤器" class="headerlink" title="解析过滤器"></a>解析过滤器</h2><blockquote><p><code>src/complier/parser/filter-parser.js</code><br>解析花括号中的</p><ul><li>当作标签文本解析，在 parseHTML 过程中的 chars 钩子函数里调用 parseText，在此调用 parseFilters</li></ul><p>解析 v-bind 中的</p><ul><li>当作标签属性解析，在 parseHTML 过程中的 processAttrs 里调用 parseFilters</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt; 将过滤器形式转化成 _f(&quot;capitalize&quot;)(message) 形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseFilters</span>(<span class="params">exp</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inSingle = <span class="literal">false</span>; <span class="comment">// exp是否在 &#x27;&#x27; 中</span></span><br><span class="line">  <span class="keyword">let</span> inDouble = <span class="literal">false</span>; <span class="comment">// exp是否在 &quot;&quot; 中</span></span><br><span class="line">  <span class="keyword">let</span> inTemplateString = <span class="literal">false</span>; <span class="comment">// exp是否在 `` 中</span></span><br><span class="line">  <span class="keyword">let</span> inRegex = <span class="literal">false</span>; <span class="comment">// exp是否在 \\ 中</span></span><br><span class="line">  <span class="keyword">let</span> curly = <span class="number">0</span>; <span class="comment">// 在exp中发现一个 &#123; 则curly加1，发现一个 &#125; 则curly减1，直到culy为0 说明 &#123; ... &#125;闭合</span></span><br><span class="line">  <span class="keyword">let</span> square = <span class="number">0</span>; <span class="comment">// 在exp中发现一个 [ 则curly加1，发现一个 ] 则curly减1，直到culy为0 说明 [ ... ]闭合</span></span><br><span class="line">  <span class="keyword">let</span> paren = <span class="number">0</span>; <span class="comment">// 在exp中发现一个 ( 则curly加1，发现一个 ) 则curly减1，直到culy为0 说明 ( ... )闭合</span></span><br><span class="line">  <span class="keyword">let</span> lastFilterIndex = <span class="number">0</span>; <span class="comment">// 解析游标，每循环过一个字符串游标加1</span></span><br><span class="line">  <span class="keyword">let</span> c, prev, i, expression, filters;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 从头开始遍历传入的exp每一个字符，通过判断每一个字符是否是特殊字符（如&#x27;,&quot;,&#123;,&#125;,[,],(,),\,|）进而判断出exp字符串中哪些部分是表达式，哪些部分是过滤器id</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; exp.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    prev = c;</span><br><span class="line">    c = exp.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (inSingle) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c === <span class="number">0x27</span> &amp;&amp; prev !== <span class="number">0x5c</span>) inSingle = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inDouble) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c === <span class="number">0x22</span> &amp;&amp; prev !== <span class="number">0x5c</span>) inDouble = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inTemplateString) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c === <span class="number">0x60</span> &amp;&amp; prev !== <span class="number">0x5c</span>) inTemplateString = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inRegex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c === <span class="number">0x2f</span> &amp;&amp; prev !== <span class="number">0x5c</span>) inRegex = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      c === <span class="number">0x7c</span> &amp;&amp; <span class="comment">// pipe</span></span><br><span class="line">      exp.<span class="title function_">charCodeAt</span>(i + <span class="number">1</span>) !== <span class="number">0x7c</span> &amp;&amp;</span><br><span class="line">      exp.<span class="title function_">charCodeAt</span>(i - <span class="number">1</span>) !== <span class="number">0x7c</span> &amp;&amp;</span><br><span class="line">      !curly &amp;&amp;</span><br><span class="line">      !square &amp;&amp;</span><br><span class="line">      !paren</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expression === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// first filter, end of expression</span></span><br><span class="line">        lastFilterIndex = i + <span class="number">1</span>;</span><br><span class="line">        expression = exp.<span class="title function_">slice</span>(<span class="number">0</span>, i).<span class="title function_">trim</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">pushFilter</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x22</span>:</span><br><span class="line">          inDouble = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// &quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x27</span>:</span><br><span class="line">          inSingle = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// &#x27;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x60</span>:</span><br><span class="line">          inTemplateString = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// `</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x28</span>:</span><br><span class="line">          paren++;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// (</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x29</span>:</span><br><span class="line">          paren--;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// )</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x5b</span>:</span><br><span class="line">          square++;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// [</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x5d</span>:</span><br><span class="line">          square--;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// ]</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x7b</span>:</span><br><span class="line">          curly++;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// &#123;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x7d</span>:</span><br><span class="line">          curly--;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c === <span class="number">0x2f</span>) &#123;</span><br><span class="line">        <span class="comment">// /</span></span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> p;</span><br><span class="line">        <span class="comment">// find first non-whitespace prev char</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">          p = exp.<span class="title function_">charAt</span>(j);</span><br><span class="line">          <span class="keyword">if</span> (p !== <span class="string">&quot; &quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!p || !validDivisionCharRE.<span class="title function_">test</span>(p)) &#123;</span><br><span class="line">          inRegex = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 当匹配到过滤器中的|符时，那么|符前面的字符串就认为是待处理的表达式，将其存储在 expression 中，后面继续匹配，</span></span><br><span class="line">  <span class="comment">// 如果再次匹配到过滤器中的 |符 ,并且此时expression有值， 那么说明后面还有第二个过滤器，</span></span><br><span class="line">  <span class="comment">// 那么此时两个|符之间的字符串就是第一个过滤器的id，此时调用 pushFilter函数将第一个过滤器添加进filters数组中</span></span><br><span class="line">  <span class="comment">// 比如 message | filter1 | filter2(arg) 会被解析成 expression = message;filters = [&#x27;filter1&#x27;,&#x27;filter2(arg)&#x27;]</span></span><br><span class="line">  <span class="keyword">if</span> (expression === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    expression = exp.<span class="title function_">slice</span>(<span class="number">0</span>, i).<span class="title function_">trim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastFilterIndex !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">pushFilter</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">pushFilter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    (filters || (filters = [])).<span class="title function_">push</span>(exp.<span class="title function_">slice</span>(lastFilterIndex, i).<span class="title function_">trim</span>());</span><br><span class="line">    lastFilterIndex = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 遍历得到的filters数组，并将数组的每一个元素及expression传给wrapFilter函数，用来生成最终的_f函数调用字符串</span></span><br><span class="line">  <span class="keyword">if</span> (filters) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filters.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      expression = <span class="title function_">wrapFilter</span>(expression, filters[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrapFilter</span>(<span class="params">exp, filter</span>) &#123;</span><br><span class="line">  <span class="comment">// 解析得到的每个过滤器中查找是否有(</span></span><br><span class="line">  <span class="keyword">const</span> i = filter.<span class="title function_">indexOf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">  <span class="comment">// 没有说明该过滤器没有接收参数，则直接构造_f函数调用字符串即_f(&quot;filter1&quot;)(message)并返回赋给expression</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// _f: resolveFilter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_f(&quot;<span class="subst">$&#123;filter&#125;</span>&quot;)(<span class="subst">$&#123;exp&#125;</span>)`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将新的experssion与filters数组中下一个过滤器再调用wrapFilter函数,</span></span><br><span class="line">    <span class="comment">// 如果下一个过滤器有参数，那么先取出过滤器id，再取出其带有的参数，生成第二个过滤器的_f函数调用字符串，即_f(&quot;filter2&quot;)(_f(&quot;filter1&quot;)(message),arg)</span></span><br><span class="line">    <span class="keyword">const</span> name = filter.<span class="title function_">slice</span>(<span class="number">0</span>, i);</span><br><span class="line">    <span class="keyword">const</span> args = filter.<span class="title function_">slice</span>(i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_f(&quot;<span class="subst">$&#123;name&#125;</span>&quot;)(<span class="subst">$&#123;exp&#125;</span><span class="subst">$&#123;args !== <span class="string">&quot;)&quot;</span> ? <span class="string">&quot;,&quot;</span> + args : args&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 全局方法</title>
      <link href="/articles/vue/global/"/>
      <url>/articles/vue/global/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h3><blockquote><p>使用基础 Vue 构造器，创建一个子类: 先创建一个类 Sub，接着通过原型继承的方式将该类继承基础 Vue 类，然后给 Sub 类添加一些属性以及将父类的某些属性复制到 Sub 类上，最后将 Sub 类返回</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建构造器</span></span><br><span class="line">&lt;div id=<span class="string">&quot;mount-point&quot;</span>&gt;&lt;/div&gt;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Profile</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&quot;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">firstName</span>: <span class="string">&quot;Walter&quot;</span>,</span><br><span class="line">      <span class="attr">lastName</span>: <span class="string">&quot;White&quot;</span>,</span><br><span class="line">      <span class="attr">alias</span>: <span class="string">&quot;Heisenberg&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Profile</span>().$mount(<span class="string">&quot;##mount-point&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">extend</span> = <span class="keyword">function</span> (<span class="params">extendOptions</span>) &#123;</span><br><span class="line">  extendOptions = extendOptions || &#123;&#125;; <span class="comment">// 传入的一个包含组件选项的对象参数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Super</span> = <span class="variable language_">this</span>; <span class="comment">// 指向父类，即基础 Vue类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">SuperId</span> = <span class="title class_">Super</span>.<span class="property">cid</span>; <span class="comment">// 父类的cid属性，无论是基础 Vue类还是从基础 Vue类继承而来的类，都有一个cid属性，作为该类的唯一标识</span></span><br><span class="line">  <span class="keyword">const</span> cachedCtors = extendOptions.<span class="property">_Ctor</span> || (extendOptions.<span class="property">_Ctor</span> = &#123;&#125;); <span class="comment">// 缓存池，用于缓存创建出来的类</span></span><br><span class="line">  <span class="comment">// 结果缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cachedCtors[<span class="title class_">SuperId</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedCtors[<span class="title class_">SuperId</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取到传入的选项参数中的name字段，并且在开发环境下校验name字段是否合法</span></span><br><span class="line">  <span class="keyword">const</span> name = extendOptions.<span class="property">name</span> || <span class="title class_">Super</span>.<span class="property">options</span>.<span class="property">name</span>;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; name) &#123;</span><br><span class="line">    <span class="title function_">validateComponentName</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个类Sub，这个类就是将要继承基础Vue类的子类，接着让该类去继承基础Vue类，让其具备一些基础Vue类的能力</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Sub</span> = <span class="keyword">function</span> <span class="title function_">VueComponent</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 1. 将父类的原型继承到子类中，并且为子类添加唯一标识cid</span></span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span>;</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">cid</span> = cid++;</span><br><span class="line">  <span class="comment">// 2. 将父类的options与子类的options进行合并，将合并结果赋给子类的options属性</span></span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(<span class="title class_">Super</span>.<span class="property">options</span>, extendOptions);</span><br><span class="line">  <span class="comment">// 3. 将父类保存到子类的super属性中，以确保在子类中能够拿到父类</span></span><br><span class="line">  <span class="title class_">Sub</span>[<span class="string">&quot;super&quot;</span>] = <span class="title class_">Super</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 如果选项中存在props属性，则初始化它</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Sub</span>.<span class="property">options</span>.<span class="property">props</span>) &#123;</span><br><span class="line">    <span class="title function_">initProps</span>(<span class="title class_">Sub</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把参数中传入的props选项代理到原型的_props中</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params"><span class="title class_">Comp</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="title class_">Comp</span>.<span class="property">options</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(<span class="title class_">Comp</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">`_props`</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 如果选项中存在computed属性，则初始化它</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Sub</span>.<span class="property">options</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">    <span class="title function_">initComputed</span>(<span class="title class_">Sub</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将每一项都调用defineComputed函数定义到子类原型上</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initComputed</span>(<span class="params"><span class="title class_">Comp</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> computed = <span class="title class_">Comp</span>.<span class="property">options</span>.<span class="property">computed</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">      <span class="title function_">defineComputed</span>(<span class="title class_">Comp</span>.<span class="property"><span class="keyword">prototype</span></span>, key, computed[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. 将父类中的一些属性复制到子类中</span></span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">extend</span> = <span class="title class_">Super</span>.<span class="property">extend</span>;</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">mixin</span> = <span class="title class_">Super</span>.<span class="property">mixin</span>;</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">use</span> = <span class="title class_">Super</span>.<span class="property">use</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">  <span class="comment">// can have their private assets too.</span></span><br><span class="line">  <span class="variable constant_">ASSET_TYPES</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params"><span class="keyword">type</span></span>) &#123;</span><br><span class="line">    <span class="title class_">Sub</span>[<span class="keyword">type</span>] = <span class="title class_">Super</span>[<span class="keyword">type</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="title class_">Sub</span>.<span class="property">options</span>.<span class="property">components</span>[name] = <span class="title class_">Sub</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. 给子类新增三个独有的属性</span></span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">superOptions</span> = <span class="title class_">Super</span>.<span class="property">options</span>;</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">extendOptions</span> = extendOptions;</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">sealedOptions</span> = <span class="title function_">extend</span>(&#123;&#125;, <span class="title class_">Sub</span>.<span class="property">options</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. 用父类的cid作为key，创建好的子类Sub作为value，存入缓存池cachedCtors中</span></span><br><span class="line">  cachedCtors[<span class="title class_">SuperId</span>] = <span class="title class_">Sub</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Sub</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h3><blockquote><p>该 API 的原理同实例方法 $nextTick 原理一样，此处不再重复。唯一不同的是实例方法 $nextTick 中回调的 this 绑定在调用它的实例上</p></blockquote><h3 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h3><h3 id="Vue-delete"><a href="#Vue-delete" class="headerlink" title="Vue.delete"></a>Vue.delete</h3><h3 id="Vue-directive"><a href="#Vue-directive" class="headerlink" title="Vue.directive"></a>Vue.directive</h3><blockquote><p>注册或获取全局指令</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;my-directive&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">update</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">componentUpdated</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">unbind</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 (指令函数)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;my-directive&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这里将会被 `bind` 和 `update` 调用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter，返回已注册的指令</span></span><br><span class="line"><span class="keyword">var</span> myDirective = <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;my-directive&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span>[<span class="string">&quot;directives&quot;</span>] = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 存放指令的位置</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">directive</span> = <span class="keyword">function</span> (<span class="params">id, definition</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取指令</span></span><br><span class="line">  <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">options</span>[<span class="string">&quot;directives&quot;</span>][id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注册指令</span></span><br><span class="line">    <span class="comment">// 如果是函数，则默认监听bind和update两个事件，即将definition函数分别赋给bind和update两个属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&quot;directive&quot;</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是一个函数，那么即认为它是用户自定义的指令对象，直接将其保存在this.options[&#x27;directives&#x27;]中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span>[<span class="string">&quot;directives&quot;</span>][id] = definition;</span><br><span class="line">    <span class="keyword">return</span> definition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue-filter"><a href="#Vue-filter" class="headerlink" title="Vue.filter"></a>Vue.filter</h3><blockquote><p>注册或获取全局过滤器</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&quot;my-filter&quot;</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回处理后的值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter，返回已注册的过滤器</span></span><br><span class="line"><span class="keyword">var</span> myFilter = <span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&quot;my-filter&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span>[<span class="string">&quot;filters&quot;</span>] = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">id, definition</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">options</span>[<span class="string">&quot;filters&quot;</span>][id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span>[<span class="string">&quot;filters&quot;</span>][id] = definition;</span><br><span class="line">    <span class="keyword">return</span> definition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue-component"><a href="#Vue-component" class="headerlink" title="Vue.component"></a>Vue.component</h3><blockquote><p>注册或获取全局组件。注册还会自动使用给定的 id 设置组件的名称</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册组件，传入一个扩展过的构造器</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(</span><br><span class="line">  <span class="string">&quot;my-component&quot;</span>,</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;my-component&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取注册的组件 (始终返回构造器)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;my-component&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span>[<span class="string">&quot;components&quot;</span>] = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">id, definition</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">options</span>[<span class="string">&quot;components&quot;</span>][id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 首先会校验组件的name值是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; <span class="keyword">type</span> === <span class="string">&quot;component&quot;</span>) &#123;</span><br><span class="line">      <span class="title function_">validateComponentName</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 判断传入的definition参数是否是一个对象，如果是对象，则使用Vue.extend方法将其变为Vue的子类，同时如果definition对象中不存在name属性时，则使用组件id作为组件的name属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&quot;component&quot;</span> &amp;&amp; <span class="title function_">isPlainObject</span>(definition)) &#123;</span><br><span class="line">      definition.<span class="property">name</span> = definition.<span class="property">name</span> || id;</span><br><span class="line">      definition = <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">_base</span>.<span class="title function_">extend</span>(definition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 将注册好的组件保存在this.options[&#x27;components&#x27;]</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span>[<span class="string">&quot;components&quot;</span>][id] = definition;</span><br><span class="line">    <span class="keyword">return</span> definition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h3><blockquote><p>安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入</p><ul><li>该方法需要在调用 new Vue() 之前被调用</li><li>当 install 方法被同一个插件多次调用，插件将只会被安装一次</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">use</span> = <span class="keyword">function</span> (<span class="params">plugin</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> installedPlugins =</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_installedPlugins</span> || (<span class="variable language_">this</span>.<span class="property">_installedPlugins</span> = []); <span class="comment">// 用来存储已安装过的插件</span></span><br><span class="line">  <span class="comment">// 1. 判断传入的插件是否存在于installedPlugins数组中（即已被安装过），如果存在的话，则直接返回，防止重复安装</span></span><br><span class="line">  <span class="keyword">if</span> (installedPlugins.<span class="title function_">indexOf</span>(plugin) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 获取到传入的其余参数，并且使用toArray方法将其转换成数组，同时将Vue插入到该数组的第一个位置，这是因为在后续调用install方法时，Vue必须作为第一个参数传入</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="title function_">toArray</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  args.<span class="title function_">unshift</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="comment">// 3. 判断传入的插件如果是一个提供了 install 方法的对象，那么就执行该对象中提供的 install 方法并传入参数完成插件安装</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.<span class="property">install</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    plugin.<span class="property">install</span>.<span class="title function_">apply</span>(plugin, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. 传入的插件是一个函数，那么就把这个函数当作install方法执行，同时传入参数完成插件安装</span></span><br><span class="line">    plugin.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 插件安装完成之后，将该插件添加进已安装插件列表中，防止重复安装</span></span><br><span class="line">  installedPlugins.<span class="title function_">push</span>(plugin);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a>Vue.mixin</h3><blockquote><p>全局注册一个混入，即可以修改 Vue.options，影响注册之后所有创建的每个 Vue 实例</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">mixin</span> = <span class="keyword">function</span> (<span class="params">mixin</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(<span class="variable language_">this</span>.<span class="property">options</span>, mixin);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue-compile"><a href="#Vue-compile" class="headerlink" title="Vue.compile"></a>Vue.compile</h3><blockquote><p>在 render 函数中编译模板字符串。只在独立构建时有效</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="title class_">Vue</span>.<span class="title function_">compile</span>(<span class="string">&quot;&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">render</span>: res.<span class="property">render</span>,</span><br><span class="line">  <span class="attr">staticRenderFns</span>: res.<span class="property">staticRenderFns</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">compile</span> = compileToFunctions;</span><br></pre></td></tr></table></figure><h3 id="Vue-observable"><a href="#Vue-observable" class="headerlink" title="Vue.observable"></a>Vue.observable</h3><blockquote><p>让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title class_">Vue</span>.<span class="title function_">observable</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Demo</span> = &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">      <span class="string">&quot;button&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">on</span>: &#123;</span><br><span class="line">          <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">count</span>++;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">`count is: <span class="subst">$&#123;state.count&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Vue-version"><a href="#Vue-version" class="headerlink" title="Vue.version"></a>Vue.version</h3><blockquote><p>提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略</p><ul><li>该 API 是在构建时读取了 package.json 中的 version 字段，然后将其赋值给 Vue.version</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> version = <span class="title class_">Number</span>(<span class="title class_">Vue</span>.<span class="property">version</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (version === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v2.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v1.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Unsupported versions of Vue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 实例方法</title>
      <link href="/articles/vue/instance/"/>
      <url>/articles/vue/instance/</url>
      
        <content type="html"><![CDATA[<h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><blockquote><p>通过 stateMixin 方法中挂载到 vue 原型上</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">stateMixin</span>(<span class="params"><span class="title class_">Vue</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$set</span> = set;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$delete</span> = del;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$watch</span> = <span class="keyword">function</span> (<span class="params">expOrFn, cb, options</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h4><blockquote><p>全局 Vue.set 的别名，其用法相同。对象不能是 Vue 实例，或者 Vue 实例的根数据对象</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">    (<span class="title function_">isUndef</span>(target) || <span class="title function_">isPrimitive</span>(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;target&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1. 判断如果传入的target是数组并且传入的key是有效索引的话，那么就取当前数组长度与key这两者的最大值作为数组的新长度，然后使用数组的splice方法将传入的索引key对应的val值添加进数组</span></span><br><span class="line">  <span class="comment">// splice方法已经被重写，当使用splice方法向数组内添加元素时，该元素会自动被变成响应式的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isValidArrayIndex</span>(key)) &#123;</span><br><span class="line">    target.<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(target.<span class="property">length</span>, key);</span><br><span class="line">    target.<span class="title function_">splice</span>(key, <span class="number">1</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 判断传入的key是否已经存在于target中，如果存在，表明这次操作不是新增属性，而是对已有的属性进行简单的修改值，那么就只修改属性值即可</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 获取到traget的__ob__属性，该属性是否为true标志着target是否为响应式对象，接着判断如果tragte是 Vue 实例，或者是 Vue 实例的根数据对象，则抛出警告并退出程序</span></span><br><span class="line">  <span class="keyword">const</span> ob = target.<span class="property">__ob__</span>;</span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">_isVue</span> || (ob &amp;&amp; ob.<span class="property">vmCount</span>)) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&quot;Avoid adding reactive properties to a Vue instance or its root $data &quot;</span> +</span><br><span class="line">          <span class="string">&quot;at runtime - declare it upfront in the data option.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 判断如果ob属性为false，那么表明target不是一个响应式对象，那么我们只需简单给它添加上新的属性，不用将新属性转化成响应式</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 如果target是对象，并且是响应式，那么就调用defineReactive方法将新属性值添加到target上，defineReactive方会将新属性添加完之后并将其转化成响应式，最后通知依赖更新</span></span><br><span class="line">  <span class="title function_">defineReactive</span>(ob.<span class="property">value</span>, key, val);</span><br><span class="line">  ob.<span class="property">dep</span>.<span class="title function_">notify</span>();</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a>vm.$delete</h4><blockquote><p>全局 Vue.delete 的别名，其用法相同。删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制</p><ul><li>目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象</li><li>原理基本与 set 相同</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">del</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">    (<span class="title function_">isUndef</span>(target) || <span class="title function_">isPrimitive</span>(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Cannot delete reactive property on undefined, null, or primitive value: <span class="subst">$&#123;target&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isValidArrayIndex</span>(key)) &#123;</span><br><span class="line">    target.<span class="title function_">splice</span>(key, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = target.<span class="property">__ob__</span>;</span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">_isVue</span> || (ob &amp;&amp; ob.<span class="property">vmCount</span>)) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&quot;Avoid deleting properties on a Vue instance or its root $data &quot;</span> +</span><br><span class="line">          <span class="string">&quot;- just set it to null.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断传入的key是否存在于target中，如果key本来就不存在于target中，那就不用删除，直接退出程序即可</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">hasOwn</span>(target, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果target是对象，并且传入的key也存在于target中，那么就从target中将该属性删除，</span></span><br><span class="line">  <span class="comment">// 同时判断当前的target是否为响应式对象，如果是响应式对象，则通知依赖更新；如果不是，删除完后直接返回不通知更新</span></span><br><span class="line">  <span class="keyword">delete</span> target[key];</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ob.<span class="property">dep</span>.<span class="title function_">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="comment">// 键路径</span></span><br><span class="line">vm.$watch(</span><br><span class="line">  <span class="string">&quot;a.b.c&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (unwatch) &#123;</span><br><span class="line">      <span class="title function_">unwatch</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 监听数组的变动不需要</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="comment">// 不能在第一次回调时取消侦听给定的 property</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line">vm.$watch(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 表达式 `this.a + this.b` 每次得出一个不同的结果时</span></span><br><span class="line">    <span class="comment">// 处理函数都会被调用。</span></span><br><span class="line">    <span class="comment">// 这就像监听一个未被定义的计算属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 做点什么</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个取消观察函数，用来停止触发回调</span></span><br><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(<span class="string">&quot;a&quot;</span>, cb);</span><br><span class="line"><span class="title function_">unwatch</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$watch</span> = <span class="keyword">function</span> (<span class="params">expOrFn, cb, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 1. 判断传入的回调函数是否为一个对象</span></span><br><span class="line">  <span class="comment">// - 如果是，表明是把第二个参数回调函数cb和第三个参数选项options合起来传入的，此时调用createWatcher函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(cb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createWatcher</span>(vm, expOrFn, cb, options);</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="comment">// 2. 表示实例是用户手动调用$watch方法创建而来的，区分用户创建的watcher实例和Vue内部创建的watcher实例</span></span><br><span class="line">  options.<span class="property">user</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 3. 创建一个watcher实例</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, expOrFn, cb, options);</span><br><span class="line">  <span class="comment">// 4. 判断如果在选项参数options中指定的immediate为true，则立即用被观察数据当前的值触发回调</span></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">    cb.<span class="title function_">call</span>(vm, watcher.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 返回一个取消观察函数unwatchFn，用来停止触发回调</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">unwatchFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    watcher.<span class="title function_">teardown</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁分析</span></span><br><span class="line">  <span class="comment">// 1. 上面watcher实例，它观察了数据a和数据b，那么它就依赖了数据a和数据b，那么这个watcher实例就存在于数据a和数据b的依赖管理器depA和depB中，</span></span><br><span class="line">  <span class="comment">// 同时watcher实例的deps属性中也记录了这两个依赖管理器，即this.deps=[depA,depB]</span></span><br><span class="line">  <span class="comment">// 2. 当取消观察时，就遍历this.deps，让每个依赖管理器调用其removeSub方法将这个watcher实例从自己的依赖列表中删除</span></span><br><span class="line">  vm.$watch(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) &#123;</span><br><span class="line">      <span class="comment">// 做点什么</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deep 原理</span></span><br><span class="line"><span class="comment">// 思路: </span></span><br><span class="line"><span class="comment">// 1. 成为内层数据的依赖: 数据变化会通知所有的依赖</span></span><br><span class="line"><span class="comment">// 2. 创建 watcher 实例时把对象内部所有的值都递归读取一遍，watcher 实例加入到对象内部所有值的依赖列表中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="comment">/* ... */</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// &quot;touch&quot; every property so they are all tracked as dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">      <span class="title function_">traverse</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> seenObjects = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="title function_">_traverse</span>(val, seenObjects);</span><br><span class="line">  seenObjects.<span class="title function_">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_traverse</span>(<span class="params">val, seen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys;</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(val);</span><br><span class="line">  <span class="comment">// 1. 判断传入的val类型，如果它不是Array或object，再或者已经被冻结，那么直接返回，退出程序</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!isA &amp;&amp; !<span class="title function_">isObject</span>(val)) ||</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(val) ||</span><br><span class="line">    val <span class="keyword">instanceof</span> <span class="title class_">VNode</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 拿到val的dep.id，存入创建好的集合Set中，因为集合相比数据而言它有天然的去重效果，以此来保证存入的dep.id没有重复，不会造成重复收集依赖</span></span><br><span class="line">  <span class="keyword">if</span> (val.<span class="property">__ob__</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.<span class="property">__ob__</span>.<span class="property">dep</span>.<span class="property">id</span>;</span><br><span class="line">    <span class="keyword">if</span> (seen.<span class="title function_">has</span>(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seen.<span class="title function_">add</span>(depId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 判断如果是数组，则循环数组，将数组中每一项递归调用_traverse；如果是对象，则取出对象所有的key，然后执行读取操作，再递归内部值</span></span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) <span class="title function_">_traverse</span>(val[i], seen);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(val);</span><br><span class="line">    i = keys.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) <span class="title function_">_traverse</span>(val[keys[i]], seen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h3><blockquote><p>通过 eventsMixin 方法中挂载到 vue 原型上</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">eventsMixin</span>(<span class="params"><span class="title class_">Vue</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$on</span> = <span class="keyword">function</span> (<span class="params">event, fn</span>) &#123;&#125;;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$once</span> = <span class="keyword">function</span> (<span class="params">event, fn</span>) &#123;&#125;;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$off</span> = <span class="keyword">function</span> (<span class="params">event, fn</span>) &#123;&#125;;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$emit</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-on"><a href="#vm-on" class="headerlink" title="vm.$on"></a>vm.$on</h4><blockquote><p>监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数<br>定义一个事件中心，通过 $on 订阅事件，将事件存储在事件中心里面，然后通过 $emit 触发事件中心里面存储的订阅事件</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$on</span> = <span class="keyword">function</span> (<span class="params">event, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 1. 判断传入的事件名是否是一个数组，如果是数组，就表示需要一次性订阅多个事件，就遍历该数组，将数组中的每一个事件都递归调用$on方法将其作为单个事件订阅</span></span><br><span class="line">  <span class="comment">// 2. 不是就当做单个事件名来处理，以该事件名作为key，先尝试在当前实例的_events属性中获取其对应的事件列表，如果获取不到就给其赋空数组为默认值，并将第二个参数回调函数添加进去</span></span><br><span class="line">  <span class="comment">// --&gt; _events属性用来作为当前实例的事件中心，所有绑定在这个实例上的事件都会存储在事件中心_events属性中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$on(event[i], fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (vm.<span class="property">_events</span>[event] || (vm.<span class="property">_events</span>[event] = [])).<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="vm-emit"><a href="#vm-emit" class="headerlink" title="vm.$emit"></a>vm.$emit</h4><blockquote><p>触发当前实例上的事件。附加参数都会传给监听器回调</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$emit</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 1. 根据传入的事件名从当前实例的_events属性（即事件中心）中获取到该事件名所对应的回调函数cbs</span></span><br><span class="line">  <span class="keyword">let</span> cbs = vm.<span class="property">_events</span>[event];</span><br><span class="line">  <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">    cbs = cbs.<span class="property">length</span> &gt; <span class="number">1</span> ? <span class="title function_">toArray</span>(cbs) : cbs;</span><br><span class="line">    <span class="comment">// 2. 获取传入的附加参数args</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="title function_">toArray</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. 遍历执行回调函数并将附加参数args传给该回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cbs[i].<span class="title function_">apply</span>(vm, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`event handler for &quot;<span class="subst">$&#123;event&#125;</span>&quot;`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="vm-off"><a href="#vm-off" class="headerlink" title="vm.$off"></a>vm.$off</h4><blockquote><p>移除自定义事件监听器</p><ul><li>如果没有提供参数，则移除所有的事件监听器</li><li>如果只提供了事件，则移除该事件所有的监听器</li><li>如果同时提供了事件与回调，则只移除这个回调的监听器</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$off</span> = <span class="keyword">function</span> (<span class="params">event, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 1. 如果没有提供参数，则移除所有的事件监听器。把_events属性重新置为空对象即可</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">arguments</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    vm.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> vm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 如果传入的需要移除的事件名是一个数组，就表示需要一次性移除多个事件，那么我们只需同订阅多个事件一样，遍历该数组，然后将数组中的每一个事件都递归调用$off方法进行移除即可</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$off(event[i], fn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 获取到需要移除的事件名在事件中心中对应的回调函数cbs</span></span><br><span class="line">  <span class="keyword">const</span> cbs = vm.<span class="property">_events</span>[event];</span><br><span class="line">  <span class="comment">// 如果cbs不存在，那表明在事件中心从来没有订阅过该事件，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">    <span class="keyword">return</span> vm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 如果cbs存在，但是没有传入回调函数fn，这就是第二种情况: 如果只提供了事件，则移除该事件所有的监听器</span></span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    vm.<span class="property">_events</span>[event] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> vm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 如果既传入了事件名，又传入了回调函数，cbs也存在，那这就是第三种情况: 如果同时提供了事件与回调，则只移除这个回调的监听器</span></span><br><span class="line">  <span class="comment">// 遍历所有回调函数数组cbs，如果cbs中某一项与fn相同，或者某一项的fn属性与fn相同，那么就将其从数组中删除即可</span></span><br><span class="line">  <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">    <span class="comment">// specific handler</span></span><br><span class="line">    <span class="keyword">let</span> cb;</span><br><span class="line">    <span class="keyword">let</span> i = cbs.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      cb = cbs[i];</span><br><span class="line">      <span class="keyword">if</span> (cb === fn || cb.<span class="property">fn</span> === fn) &#123;</span><br><span class="line">        cbs.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="vm-once"><a href="#vm-once" class="headerlink" title="vm.$once"></a>vm.$once</h4><blockquote><p>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除<br>定义一个子函数，用这个子函数来替换原本订阅事件所对应的回调，当触发订阅事件时，其实执行的是这个子函数，然后再子函数内部先把该订阅移除，再执行原本的回调，以此来达到只触发一次的目的</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$once</span> = <span class="keyword">function</span> (<span class="params">event, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 先通过$off方法移除订阅的事件，这样确保该事件不会被再次触发，接着执行原本的回调fn</span></span><br><span class="line">    vm.$off(event, on);</span><br><span class="line">    fn.<span class="title function_">apply</span>(vm, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 防止在触发该事件后再调用 $off 方法移除事件失败，因为 _events 中该事件订阅的事件被替换了</span></span><br><span class="line">  <span class="comment">// 为了解决这一问题，需要给on上绑定一个fn属性，属性值为用户传入的回调fn，这样在使用$off移除事件的时候，$off内部会判断如果回调函数列表中某一项的fn属性与fn相同时，就可以成功移除事件了</span></span><br><span class="line">  on.<span class="property">fn</span> = fn;</span><br><span class="line">  <span class="comment">// 1. 先通过$on方法订阅事件，同时所使用的回调函数并不是原本的fn而是子函数on</span></span><br><span class="line">  vm.$on(event, on);</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="生命周期相关"><a href="#生命周期相关" class="headerlink" title="生命周期相关"></a>生命周期相关</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">lifecycleMixin</span>(<span class="params"><span class="title class_">Vue</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$forceUpdate</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$destroy</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderMixin</span>(<span class="params"><span class="title class_">Vue</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$nextTick</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a>vm.$mount</h4><blockquote><p>在跨平台的代码中挂载到 Vue 原型上的</p><ul><li>vm.$mount(<code>[elementOrSelector]</code>)，这个方法返回实例自身，因而可以链式调用其它实例方法</li><li>如果 Vue 实例在实例化时没有收到 el 选项，则它处于 未挂载 状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例</li><li>如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且必须使用原生 DOM API 把它插入文档中</li></ul></blockquote><h4 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate"></a>vm.$forceUpdate</h4><blockquote><p>在 lifecycleMixin 函数中挂载到 Vue 原型上的</p><ul><li>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件</li><li>实例 watcher 执行了 update 方法</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$forceUpdate</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_watcher</span>) &#123;</span><br><span class="line">    vm.<span class="property">_watcher</span>.<span class="title function_">update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="vm-nextTick"><a href="#vm-nextTick" class="headerlink" title="vm.$nextTick"></a>vm.$nextTick</h4><blockquote><p>在 renderMixin 函数中挂载到 Vue 原型上的</p><ul><li>vm.$nextTick 是全局 Vue.nextTick 的别名，其用法相同</li><li>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上</li><li>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个事件队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到事件队列中一次</li></ul></blockquote><div class="tip bolt"><p>内部原理: </p></div><ol><li>能力检测</li></ol><ul><li>内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替</li><li>宏任务耗费的时间是大于微任务的，在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，使用宏任务；但是，各种宏任务之间也有效率的不同，需要根据浏览器的支持情况，使用不同的宏任务</li></ul><ol><li>根据能力检测以不同方式执行回调队列，两个注意点</li></ol><ul><li>如何保证只在接收第一个回调函数时执行异步方法</li><li><ul><li>nextTick 源码中使用了一个异步锁的概念，即接收第一个回调函数时，先关上锁，执行异步方法。此时，浏览器处于等待执行完同步代码就执行异步代码的情况</li></ul></li><li><p>执行 flushCallbacks 函数时为什么需要备份回调函数队列？执行的也是备份的回调函数队列？</p></li><li><ul><li>可能会出现这么一种情况: nextTick 的回调函数中还使用 nextTick。如果 flushCallbacks 不做特殊处理，直接循环执行回调函数，会导致里面 nextTick 中的回调函数会进入回调队列</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 能力检测</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerFunc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      p.<span class="title function_">then</span>(flushCallbacks);</span><br><span class="line">      <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop);</span><br><span class="line">    &#125;;</span><br><span class="line">    isUsingMicroTask = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    !isIE &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class="line">    (<span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">      <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&quot;[object MutationObserverConstructor]&quot;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks);</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">      <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">      textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">    &#125;;</span><br><span class="line">    isUsingMicroTask = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setImmediate</span>(flushCallbacks);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行回调队列</span></span><br><span class="line"><span class="keyword">const</span> callbacks = [];</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>; <span class="comment">// 异步锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 防止出现nextTick中包含nextTick时出现问题，在执行回调函数队列前，提前复制备份并清空回调函数队列</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb, ctx</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line">  <span class="comment">// 将回调函数推入回调队列</span></span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&quot;nextTick&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 如果异步锁未锁上，锁上异步锁，调用异步函数，准备等同步函数执行完后，就开始执行回调函数队列</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">timerFunc</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有提供回调，并且支持Promise，返回一个Promise</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-destory"><a href="#vm-destory" class="headerlink" title="vm.$destory"></a>vm.$destory</h4><blockquote><p>在 lifecycleMixin 函数中挂载到 Vue 原型上的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 生命周期</title>
      <link href="/articles/vue/lifeCycle/"/>
      <url>/articles/vue/lifeCycle/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/vue/lCycle_1.png" alt=""></p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><blockquote><p>为 Vue 实例上初始化一些属性，事件以及响应式数据</p></blockquote><h4 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue()"></a>new Vue()</h4><blockquote><p>合并属性: mergeOptions</p><ul><li>把 parent 和 child 这两个对象根据一些合并策略，合并成一个新对象并返回</li><li>resolveConstructorOptions: 返回 vm.constructor.options，相当于 Vue.options。</li><li>initGlobalAPI 中定义了 Vue.options</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&quot;Vue is a constructor and should be called with the `new` keyword&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initMixin</span>(<span class="params"><span class="title class_">Vue</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">    vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">      <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">    vm.<span class="property">_self</span> = vm;</span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm); <span class="comment">// 初始化生命周期</span></span><br><span class="line">    <span class="title function_">initEvents</span>(vm); <span class="comment">// 初始化事件</span></span><br><span class="line">    <span class="title function_">initRender</span>(vm); <span class="comment">// 初始化渲染</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&quot;beforeCreate&quot;</span>); <span class="comment">// 调用生命周期钩子函数</span></span><br><span class="line">    <span class="title function_">initInjections</span>(vm); <span class="comment">//初始化injections, resolve injections before data/props</span></span><br><span class="line">    <span class="title function_">initState</span>(vm); <span class="comment">// 初始化props,methods,data,computed,watch</span></span><br><span class="line">    <span class="title function_">initProvide</span>(vm); <span class="comment">// 初始化 provide, resolve provide after data/props</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&quot;created&quot;</span>); <span class="comment">// 调用生命周期钩子函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户是否传入了el选项，如果传入了则调用$mount函数进入模板编译与挂载阶段，如果没有传入el选项，则不进入下一个生命周期阶段，需要用户手动执行vm.$mount方法才进入下一个生命周期阶段</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">      vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initGlobalAPI</span>(<span class="params"><span class="title class_">Vue</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">options</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="variable constant_">ASSET_TYPES</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params"><span class="keyword">type</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property">options</span>[<span class="keyword">type</span> + <span class="string">&quot;s&quot;</span>] = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内置组件扩展到 Vue.options.components</span></span><br><span class="line">  <span class="comment">// Vue 的内置组件目前 有&lt;keep-alive&gt;、&lt;transition&gt; 和&lt;transition-group&gt; 组件，所以使用这些组件不需要注册</span></span><br><span class="line">  <span class="title function_">extend</span>(<span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">components</span>, builtInComponents);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ASSET_TYPES</span> = [<span class="string">&quot;component&quot;</span>, <span class="string">&quot;directive&quot;</span>, <span class="string">&quot;filter&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mergeOptions</span>(<span class="params">parent, child, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    child = child.<span class="property">options</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1. 递归把 extends 和 mixins 合并到 parent 上</span></span><br><span class="line">  <span class="keyword">const</span> extendsFrom = child.<span class="property">extends</span>;</span><br><span class="line">  <span class="keyword">if</span> (extendsFrom) &#123;</span><br><span class="line">    parent = <span class="title function_">mergeOptions</span>(parent, extendsFrom, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child.<span class="property">mixins</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.<span class="property">mixins</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">mixins</span>[i], vm);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 创建一个空对象options，遍历 parent，把parent中的每一项通过调用 mergeField函数合并到空对象options里</span></span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> key;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="title function_">mergeField</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 接着再遍历 child，把存在于child里但又不在 parent中 的属性继续调用 mergeField函数合并到空对象options里</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">hasOwn</span>(parent, key)) &#123;</span><br><span class="line">      <span class="title function_">mergeField</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 策略模式: 针对不同的选项有不同的合并策略，比如针对 data: strats.data方法，针对 watch: strats.watch方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mergeField</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat;</span><br><span class="line">    options[key] = <span class="title function_">strat</span>(parent[key], child[key], vm, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生命周期钩子的合并策略</span></span><br><span class="line"><span class="comment">// 一旦 parent 和 child 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组，并且 parentVal 先执行，用来支持 Vue.mixin</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeHook</span>(<span class="params">parentVal, childVal</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.<span class="title function_">concat</span>(childVal)</span><br><span class="line">      : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(childVal)</span><br><span class="line">      ? childVal</span><br><span class="line">      : [childVal]</span><br><span class="line">    : parentVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">LIFECYCLE_HOOKS</span> = [</span><br><span class="line">  <span class="string">&quot;beforeCreate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="string">&quot;beforeMount&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mounted&quot;</span>,</span><br><span class="line">  <span class="string">&quot;beforeUpdate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;beforeDestroy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;destroyed&quot;</span>,</span><br><span class="line">  <span class="string">&quot;activated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;deactivated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;errorCaptured&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LIFECYCLE_HOOKS</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">callHook</span>(<span class="params">vm, hook</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取钩子名称对应的钩子函数数组，遍历执行</span></span><br><span class="line">  <span class="keyword">const</span> handlers = vm.<span class="property">$options</span>[hook];</span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        handlers[i].<span class="title function_">call</span>(vm);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle"></a>initLifecycle</h4><blockquote><p>给实例初始化了一些属性: 以 <code>$</code> 开头的供用户使用的外部属性，以 <code>_</code> 开头的供内部使用的内部属性</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initLifecycle</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.<span class="property">$options</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前组件不是抽象组件并且存在父级，向上循环查找，直到找到第一个不是抽象类型的父级时</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.<span class="property">parent</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.<span class="property">abstract</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.<span class="property">$options</span>.<span class="property">abstract</span> &amp;&amp; parent.<span class="property">$parent</span>) &#123;</span><br><span class="line">      parent = parent.<span class="property">$parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parent.<span class="property">$children</span>.<span class="title function_">push</span>(vm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$parent</span> = parent;</span><br><span class="line">  <span class="comment">// 给实例上挂载$root属性</span></span><br><span class="line">  vm.<span class="property">$root</span> = parent ? parent.<span class="property">$root</span> : vm;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$children</span> = [];</span><br><span class="line">  vm.<span class="property">$refs</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">_watcher</span> = <span class="literal">null</span>;</span><br><span class="line">  vm.<span class="property">_inactive</span> = <span class="literal">null</span>;</span><br><span class="line">  vm.<span class="property">_directInactive</span> = <span class="literal">false</span>;</span><br><span class="line">  vm.<span class="property">_isMounted</span> = <span class="literal">false</span>;</span><br><span class="line">  vm.<span class="property">_isDestroyed</span> = <span class="literal">false</span>;</span><br><span class="line">  vm.<span class="property">_isBeingDestroyed</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a>initEvents</h4><blockquote><ul><li>父组件给子组件的注册事件中，把自定义事件传给子组件，在子组件实例化的时候进行初始化；而浏览器原生事件是在父组件中处理</li><li>实初始化事件函数 initEvents 实际上初始化的是父组件在模板中使用 v-on 或 @ 注册的监听子组件内触发的事件</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onRE = <span class="regexp">/^@|^v-on:/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dirRE = <span class="regexp">/^v-|^@|^:/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processAttrs</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> list = el.<span class="property">attrsList</span>;</span><br><span class="line">  <span class="keyword">let</span> i, l, name, value, modifiers;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, l = list.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    name = list[i].<span class="property">name</span>;</span><br><span class="line">    value = list[i].<span class="property">value</span>;</span><br><span class="line">    <span class="comment">// 如果是指令</span></span><br><span class="line">    <span class="keyword">if</span> (dirRE.<span class="title function_">test</span>(name)) &#123;</span><br><span class="line">      <span class="comment">// 解析修饰符</span></span><br><span class="line">      modifiers = <span class="title function_">parseModifiers</span>(name);</span><br><span class="line">      <span class="keyword">if</span> (modifiers) &#123;</span><br><span class="line">        name = name.<span class="title function_">replace</span>(modifierRE, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (onRE.<span class="title function_">test</span>(name)) &#123;</span><br><span class="line">        <span class="comment">// v-on 事件指令</span></span><br><span class="line">        name = name.<span class="title function_">replace</span>(onRE, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="title function_">addHandler</span>(el, name, value, modifiers, <span class="literal">false</span>, warn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">addHandler</span>(<span class="params">el, name, value, modifiers</span>) &#123;</span><br><span class="line">  modifiers = modifiers || emptyObject;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 首先根据 modifier 修饰符对事件名 name 做处理</span></span><br><span class="line">  <span class="comment">// check capture modifier 判断是否有capture修饰符</span></span><br><span class="line">  <span class="keyword">if</span> (modifiers.<span class="property">capture</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> modifiers.<span class="property">capture</span>;</span><br><span class="line">    name = <span class="string">&quot;!&quot;</span> + name; <span class="comment">// 给事件名前加&#x27;!&#x27;用以标记capture修饰符</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否有once修饰符</span></span><br><span class="line">  <span class="keyword">if</span> (modifiers.<span class="property">once</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> modifiers.<span class="property">once</span>;</span><br><span class="line">    name = <span class="string">&quot;~&quot;</span> + name; <span class="comment">// 给事件名前加&#x27;~&#x27;用以标记once修饰符</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否有passive修饰符</span></span><br><span class="line">  <span class="keyword">if</span> (modifiers.<span class="property">passive</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> modifiers.<span class="property">passive</span>;</span><br><span class="line">    name = <span class="string">&quot;&amp;&quot;</span> + name; <span class="comment">// 给事件名前加&#x27;&amp;&#x27;用以标记passive修饰符</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 根据 modifier.native 判断事件是一个浏览器原生事件还是自定义事件</span></span><br><span class="line">  <span class="comment">// 对应生成的data: 自定义 on，原生事件 nativeOn</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//     on: &#123;&quot;select&quot;: selectHandler&#125;,</span></span><br><span class="line">  <span class="comment">//     nativeOn: &#123;&quot;click&quot;: function($event) &#123;</span></span><br><span class="line">  <span class="comment">//         return clickHandler($event)</span></span><br><span class="line">  <span class="comment">//       &#125;</span></span><br><span class="line">  <span class="comment">//    &#125;</span></span><br><span class="line">  <span class="comment">//  &#125;</span></span><br><span class="line">  <span class="keyword">let</span> events;</span><br><span class="line">  <span class="keyword">if</span> (modifiers.<span class="property">native</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> modifiers.<span class="property">native</span>;</span><br><span class="line">    events = el.<span class="property">nativeEvents</span> || (el.<span class="property">nativeEvents</span> = &#123;&#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    events = el.<span class="property">events</span> || (el.<span class="property">events</span> = &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 按照 name 对事件做归类，并把回调函数的字符串保留到对应的事件中</span></span><br><span class="line">  <span class="keyword">const</span> newHandler = &#123;</span><br><span class="line">    <span class="attr">value</span>: value.<span class="title function_">trim</span>(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (modifiers !== emptyObject) &#123;</span><br><span class="line">    newHandler.<span class="property">modifiers</span> = modifiers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handlers = events[name];</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(handlers)) &#123;</span><br><span class="line">    handlers.<span class="title function_">push</span>(newHandler);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    events[name] = [handlers, newHandler];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    events[name] = newHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  el.<span class="property">plain</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建组件节点 vnode</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponent</span>(<span class="params"><span class="title class_">Ctor</span>, data, context, children, tag</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.<span class="property">on</span>; <span class="comment">// 自定义事件data.on 赋值给了 listeners，作为 vnode 的 componentOptions 传入，放在子组件初始化阶段中处理</span></span><br><span class="line"></span><br><span class="line">  data.<span class="property">on</span> = data.<span class="property">nativeOn</span>; <span class="comment">// 浏览器原生事件 data.nativeOn 赋值给了 data.on，在当前父组件环境中处理的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || tag;</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&quot;&quot;</span>&#125;</span>`</span>,</span><br><span class="line">    data,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    context,</span><br><span class="line">    &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initEvents</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">  <span class="comment">// 存储事件</span></span><br><span class="line">  vm.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 获取父组件注册的事件赋给listeners，如果listeners不为空，则调用updateComponentListeners函数，将父组件向子组件注册的事件注册到子组件的实例中</span></span><br><span class="line">  <span class="keyword">const</span> listeners = vm.<span class="property">$options</span>.<span class="property">_parentListeners</span>;</span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    <span class="title function_">updateComponentListeners</span>(vm, listeners);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateComponentListeners</span>(<span class="params">vm, listeners, oldListeners</span>) &#123;</span><br><span class="line">  target = vm;</span><br><span class="line">  <span class="title function_">updateListeners</span>(listeners, oldListeners || &#123;&#125;, add, remove, vm);</span><br><span class="line">  target = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">event, fn, once</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (once) &#123;</span><br><span class="line">    target.$once(event, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.$on(event, fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params">event, fn</span>) &#123;</span><br><span class="line">  target.$off(event, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比listeners和oldListeners的不同，并调用参数中提供的add和remove进行相应的注册事件和卸载事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateListeners</span>(<span class="params"></span></span><br><span class="line"><span class="params">  on, <span class="comment">// listeners</span></span></span><br><span class="line"><span class="params">  oldOn, <span class="comment">// oldListeners</span></span></span><br><span class="line"><span class="params">  add,</span></span><br><span class="line"><span class="params">  remove,</span></span><br><span class="line"><span class="params">  vm</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name, def, cur, old, event;</span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> on) &#123;</span><br><span class="line">    def = cur = on[name];</span><br><span class="line">    old = oldOn[name];</span><br><span class="line">    event = <span class="title function_">normalizeEvent</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(cur)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Invalid handler for event &quot;<span class="subst">$&#123;event.name&#125;</span>&quot;: got `</span> + <span class="title class_">String</span>(cur),</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(old)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(cur.<span class="property">fns</span>)) &#123;</span><br><span class="line">        cur = on[name] = <span class="title function_">createFnInvoker</span>(cur);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">add</span>(</span><br><span class="line">        event.<span class="property">name</span>,</span><br><span class="line">        cur,</span><br><span class="line">        event.<span class="property">once</span>,</span><br><span class="line">        event.<span class="property">capture</span>,</span><br><span class="line">        event.<span class="property">passive</span>,</span><br><span class="line">        event.<span class="property">params</span></span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur !== old) &#123;</span><br><span class="line">      <span class="comment">// 保证事件回调只添加一次，之后仅仅去修改它的回调函数的引用</span></span><br><span class="line">      old.<span class="property">fns</span> = cur;</span><br><span class="line">      on[name] = old;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> oldOn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(on[name])) &#123;</span><br><span class="line">      event = <span class="title function_">normalizeEvent</span>(name);</span><br><span class="line">      <span class="title function_">remove</span>(event.<span class="property">name</span>, oldOn[name], event.<span class="property">capture</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h4><blockquote><ul><li>provide 和 inject 选项绑定的数据不是响应式的</li><li>先调用 initInjections，后调用 initProvide: 需要保证 inject 能在 data 等 state 中获取到，initInjections -&gt; initState -&gt; initProvide</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initInjections</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">  <span class="comment">// 将 inject 选项中的数据转化成键值对的形式赋给result</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">resolveInject</span>(vm.<span class="property">$options</span>.<span class="property">inject</span>, vm);</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 内部把 shouldObserve = false，为了告诉 defineReactive 函数仅仅是把键值添加到当前实例上而不需要将其转换成响应式</span></span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 遍历键值对，调用defineReactive函数将其添加当前实例上</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(result).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(vm, key, result[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> shouldObserve = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">toggleObserving</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  shouldObserve = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveInject</span>(<span class="params">inject, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (inject) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(inject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取当前inject 选项中的所有key，然后遍历每一个key，拿到每一个key的from属性记作provideKey，provideKey是上游父级组件提供的源属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[i];</span><br><span class="line">      <span class="keyword">const</span> provideKey = inject[key].<span class="property">from</span>;</span><br><span class="line">      <span class="keyword">let</span> source = vm;</span><br><span class="line">      <span class="comment">// 2. 向上游父级组件的_provided属性中（父级组件使用provide选项注入数据时会将注入的数据存入自己的实例的_provided属性中）查找，直到查找到源属性的对应的值，将其存入result中</span></span><br><span class="line">      <span class="keyword">while</span> (source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.<span class="property">_provided</span> &amp;&amp; <span class="title function_">hasOwn</span>(source.<span class="property">_provided</span>, provideKey)) &#123;</span><br><span class="line">          result[key] = source.<span class="property">_provided</span>[provideKey];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        source = source.<span class="property">$parent</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3. 如果没有找到，那么就看inject 选项中当前的数据key是否设置了默认值，即是否有default属性，如果有的话，则拿到这个默认值</span></span><br><span class="line">      <span class="keyword">if</span> (!source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;default&quot;</span> <span class="keyword">in</span> inject[key]) &#123;</span><br><span class="line">          <span class="keyword">const</span> provideDefault = inject[key].<span class="property">default</span>;</span><br><span class="line">          result[key] =</span><br><span class="line">            <span class="keyword">typeof</span> provideDefault === <span class="string">&quot;function&quot;</span></span><br><span class="line">              ? provideDefault.<span class="title function_">call</span>(vm)</span><br><span class="line">              : provideDefault;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">`Injection &quot;<span class="subst">$&#123;key&#125;</span>&quot; not found`</span>, vm);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范化 inject 选项数据，添加 from 属性</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Child</span> = &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&quot;foo&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = &#123;</span><br><span class="line">  <span class="attr">inject</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123; <span class="attr">default</span>: <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = &#123;</span><br><span class="line">  <span class="attr">inject</span>: &#123;</span><br><span class="line">    foo,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一格式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = &#123;</span><br><span class="line">  <span class="attr">inject</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">from</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&quot;xxx&quot;</span>, <span class="comment">//如果有默认的值就有default属性</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeInject</span>(<span class="params">options, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inject = options.<span class="property">inject</span>;</span><br><span class="line">  <span class="keyword">if</span> (!inject) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> normalized = (options.<span class="property">inject</span> = &#123;&#125;);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inject.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      normalized[inject[i]] = &#123; <span class="attr">from</span>: inject[i] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> inject) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = inject[key];</span><br><span class="line">      normalized[key] = <span class="title function_">isPlainObject</span>(val)</span><br><span class="line">        ? <span class="title function_">extend</span>(&#123; <span class="attr">from</span>: key &#125;, val)</span><br><span class="line">        : &#123; <span class="attr">from</span>: val &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Invalid value for option &quot;inject&quot;: expected an Array or an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(inject)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initState-处理-options"><a href="#initState-处理-options" class="headerlink" title="initState (处理 options)"></a>initState (处理 options)</h4><blockquote><p>处理 props、methods、data、computed、watch</p></blockquote><h5 id="初始化-props"><a href="#初始化-props" class="headerlink" title="初始化 props"></a>初始化 props</h5><blockquote><ul><li>规范化数据: normalizeProps</li><li>initProps</li><li>validateProp</li><li>getPropDefaultValue</li><li>assertProp</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">  vm.<span class="property">_watchers</span> = []; <span class="comment">// 组件级别的侦测</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span>;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>);</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>);</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">initData</span>(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>((vm.<span class="property">_data</span> = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>);</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params">vm, propsOptions</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;; <span class="comment">// 父组件传入的真实props数据</span></span><br><span class="line">  <span class="keyword">const</span> props = (vm.<span class="property">_props</span> = &#123;&#125;); <span class="comment">// 指向vm._props的指针，所有设置到props变量中的属性都会保存到vm._props中</span></span><br><span class="line">  <span class="keyword">const</span> keys = (vm.<span class="property">$options</span>.<span class="property">_propKeys</span> = []); <span class="comment">// 指向vm.$options._propKeys的指针，缓存props对象中的key，将来更新props时只需遍历vm.$options._propKeys数组即可得到所有props的key</span></span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.<span class="property">$parent</span>; <span class="comment">// 当前组件是否为根组件</span></span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    <span class="comment">// 非根组件，则不需要将props数组转换为响应式的</span></span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 历props选项拿到每一对键值，先将键名添加到keys中，</span></span><br><span class="line">  <span class="comment">// 然后调用validateProp函数（关于该函数下面会介绍）校验父组件传入的props数据类型是否匹配并获取到传入的值value，</span></span><br><span class="line">  <span class="comment">// 然后将键和值通过defineReactive函数添加到props（即vm._props）中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    keys.<span class="title function_">push</span>(key);</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = <span class="title function_">hyphenate</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="title function_">isReservedAttribute</span>(hyphenatedKey) ||</span><br><span class="line">        config.<span class="title function_">isReservedAttr</span>(hyphenatedKey)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`&quot;<span class="subst">$&#123;hyphenatedKey&#125;</span>&quot; is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">defineReactive</span>(props, key, value, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.<span class="property">$parent</span> &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">              <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">              <span class="string">`Instead, use a data or computed property based on the prop&#x27;s `</span> +</span><br><span class="line">              <span class="string">`value. Prop being mutated: &quot;<span class="subst">$&#123;key&#125;</span>&quot;`</span>,</span><br><span class="line">            vm</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(props, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个key在当前实例vm中是否存在，如果不存在，则调用proxy函数在vm上设置一个以key为属性的代码，当使用vm[key]访问数据时，其实访问的是vm._props[key]</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_props`</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toggleObserving</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">validateProp</span>(<span class="params">key, propOptions, propsData, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prop = propOptions[key]; <span class="comment">// 当前key在propOptions中对应的值</span></span><br><span class="line">  <span class="keyword">const</span> absent = !<span class="title function_">hasOwn</span>(propsData, key); <span class="comment">// 当前key是否在propsData中存在，即父组件是否传入了该属性</span></span><br><span class="line">  <span class="keyword">let</span> value = propsData[key]; <span class="comment">// 当前key在propsData中对应的值，即父组件对于该属性传入的真实值</span></span><br><span class="line">  <span class="keyword">const</span> booleanIndex = <span class="title function_">getTypeIndex</span>(<span class="title class_">Boolean</span>, prop.<span class="property">type</span>);</span><br><span class="line">  <span class="keyword">if</span> (booleanIndex &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果absent为true，即父组件没有传入该prop属性并且该属性也没有默认值的时候，将该属性值设置为false</span></span><br><span class="line">    <span class="keyword">if</span> (absent &amp;&amp; !<span class="title function_">hasOwn</span>(prop, <span class="string">&quot;default&quot;</span>)) &#123;</span><br><span class="line">      value = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父组件传入了该prop属性，则需满足</span></span><br><span class="line">    <span class="comment">// 1. 该属性值为空字符串或者 属性值与属性名相等（先将属性名由驼峰式转换成用-连接的字符串，比如 &lt;Child userName=&quot;user-name&quot;&gt;&lt;/Child&gt; 为 true）</span></span><br><span class="line">    <span class="comment">// 2. prop 的 type 属性中不存在 String 类型</span></span><br><span class="line">    <span class="comment">// 3. 如果 prop 的 type 属性中存在 String 类型，那么 Boolean 类型在 type 属性中的索引必须小于 String 类型的索引，即 Boolean 类型的优先级更高</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span> || value === <span class="title function_">hyphenate</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> stringIndex = <span class="title function_">getTypeIndex</span>(<span class="title class_">String</span>, prop.<span class="property">type</span>);</span><br><span class="line">      <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">        value = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果不是布尔类型，是其它类型的话，那就只需判断父组件是否传入该属性即可，如果没有传入，则该属性值为undefined</span></span><br><span class="line">  <span class="comment">// 此时调用 getPropDefaultValue 函数获取该属性的默认值，并将其转换成响应式</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    value = <span class="title function_">getPropDefaultValue</span>(vm, prop, key);</span><br><span class="line">    <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">    <span class="comment">// make sure to observe it.</span></span><br><span class="line">    <span class="keyword">const</span> prevShouldObserve = shouldObserve;</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">observe</span>(value);</span><br><span class="line">    <span class="title function_">toggleObserving</span>(prevShouldObserve);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果父组件传入了该属性并且也有对应的真实值，那么在非生产环境下会调用 assertProp 函数校验该属性值是否与要求的类型相匹配</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">assertProp</span>(prop, key, value, vm, absent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将父组件传入的该属性的真实值返回</span></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据子组件 props 选项中的 key 获取其对应的默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPropDefaultValue</span>(<span class="params">vm, prop, key</span>) &#123;</span><br><span class="line">  <span class="comment">// no default, return undefined</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">hasOwn</span>(prop, <span class="string">&quot;default&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> def = prop.<span class="property">default</span>;</span><br><span class="line">  <span class="comment">// 对象或数组默认值必须从一个工厂函数获取，注意点</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; <span class="title function_">isObject</span>(def)) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;Invalid default value for prop &quot;&#x27;</span> +</span><br><span class="line">        key +</span><br><span class="line">        <span class="string">&#x27;&quot;: &#x27;</span> +</span><br><span class="line">        <span class="string">&quot;Props with type Object/Array must use a factory function &quot;</span> +</span><br><span class="line">        <span class="string">&quot;to return the default value.&quot;</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果父组件没有传入该props属性，但是在vm._props中有该属性值，这说明vm._props中的该属性值就是默认值</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    vm &amp;&amp;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">propsData</span> &amp;&amp;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">propsData</span>[key] === <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    vm.<span class="property">_props</span>[key] !== <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> vm.<span class="property">_props</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断def是否为函数并且prop.type不为Function，如果是的话表明def是一个返回对象或数组的工厂函数，那么将函数的返回值作为默认值返回；如果def不是函数，那么则将def作为默认值返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> def === <span class="string">&quot;function&quot;</span> &amp;&amp; <span class="title function_">getType</span>(prop.<span class="property">type</span>) !== <span class="string">&quot;Function&quot;</span></span><br><span class="line">    ? def.<span class="title function_">call</span>(vm)</span><br><span class="line">    : def;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验父组件传来的真实值是否与prop的type类型相匹配，如果不匹配则在非生产环境下抛出警告</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assertProp</span>(<span class="params">prop, name, value, vm, absent</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断prop中如果设置了必填项（即prop.required为true）并且父组件又没有传入该属性，此时则抛出警告: 提示该项必填</span></span><br><span class="line">  <span class="keyword">if</span> (prop.<span class="property">required</span> &amp;&amp; absent) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Missing required prop: &quot;&#x27;</span> + name + <span class="string">&#x27;&quot;&#x27;</span>, vm);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断如果该项不是必填的并且该项的值value不存在，那么此时是合法的，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; !prop.<span class="property">required</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">type</span> = prop.<span class="property">type</span>; <span class="comment">// prop中的type类型(可以是一个原生构造函数，也可以是一个包含多种类型的数组，还可以不设置该属性)</span></span><br><span class="line">  <span class="keyword">let</span> valid = !<span class="keyword">type</span> || <span class="keyword">type</span> === <span class="literal">true</span>; <span class="comment">// 校验是否成功(如果用户设置的是原生构造函数或数组，那么此时vaild默认为false（!type），如果用户没有设置该属性，表示不需要校验，那么此时vaild默认为true，即校验成功)</span></span><br><span class="line">  <span class="keyword">const</span> expectedTypes = []; <span class="comment">// 保存期望类型的数组，当校验失败抛出警告时，会提示用户该属性所期望的类型是什么</span></span><br><span class="line">  <span class="comment">// 判断该属性是不是数组，如果不是，则统一转化为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="keyword">type</span> = [<span class="keyword">type</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历type数组，并调用assertType函数校验value。assertType函数校验后会返回一个对象: &#123; vaild:true, // 表示是否校验成功 expectedType: &#x27;Boolean&#x27; // 表示被校验的类型 &#125;</span></span><br><span class="line">    <span class="comment">// 判断条件 !valid，即type数组中还要有一个校验成功，循环立即结束，表示校验通过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">type</span>.<span class="property">length</span> &amp;&amp; !valid; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> assertedType = <span class="title function_">assertType</span>(value, <span class="keyword">type</span>[i]);</span><br><span class="line">      expectedTypes.<span class="title function_">push</span>(assertedType.<span class="property">expectedType</span> || <span class="string">&quot;&quot;</span>);</span><br><span class="line">      valid = assertedType.<span class="property">valid</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果循环完毕后vaild为false，即表示校验未通过，则抛出警告</span></span><br><span class="line">  <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Invalid prop: type check failed for prop &quot;<span class="subst">$&#123;name&#125;</span>&quot;.`</span> +</span><br><span class="line">        <span class="string">` Expected <span class="subst">$&#123;expectedTypes.map(capitalize).join(<span class="string">&quot;, &quot;</span>)&#125;</span>`</span> +</span><br><span class="line">        <span class="string">`, got <span class="subst">$&#123;toRawType(value)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此外，props 选项支持自定义校验函数。获取校验函数并检验</span></span><br><span class="line">  <span class="comment">// props:&#123;</span></span><br><span class="line">  <span class="comment">//     propF: &#123;</span></span><br><span class="line">  <span class="comment">//         validator: function (value) &#123;</span></span><br><span class="line">  <span class="comment">//         // 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">  <span class="comment">//         return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1</span></span><br><span class="line">  <span class="comment">//         &#125;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">const</span> validator = prop.<span class="property">validator</span>;</span><br><span class="line">  <span class="keyword">if</span> (validator) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">validator</span>(value)) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop: custom validator check failed for prop &quot;&#x27;</span> + name + <span class="string">&#x27;&quot;.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-methods"><a href="#初始化-methods" class="headerlink" title="初始化 methods"></a>初始化 methods</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initMethods</span>(<span class="params">vm, methods</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 只有方法名没有方法体时，抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (methods[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has an undefined value in the component definition. `</span> +</span><br><span class="line">            <span class="string">`Did you reference the function correctly?`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果methods中某个方法名与props中某个属性名重复了，就抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a prop.`</span>, vm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果methods中某个方法名如果在实例vm中已经存在并且方法名是以_或$开头的，就抛出异常: 提示用户方法名命名不规范。</span></span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm &amp;&amp; <span class="title function_">isReserved</span>(key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; conflicts with an existing Vue instance method. `</span> +</span><br><span class="line">            <span class="string">`Avoid defining component methods that start with _ or $.`</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述判断都没问题，那就method绑定到实例vm上，通过this.xxx来访问</span></span><br><span class="line">    vm[key] = methods[key] == <span class="literal">null</span> ? noop : <span class="title function_">bind</span>(methods[key], vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-data"><a href="#初始化-data" class="headerlink" title="初始化 data"></a>初始化 data</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span>(<span class="params">vm</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 获取到用户传入的data选项，赋给变量data，同时将变量data作为指针指向vm._data</span></span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="comment">// 2. 判断data是不是一个函数，如果是就调用getData函数获取其返回值，将其保存到vm._data中。如果不是，就将其本身保存到vm._data中</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&quot;function&quot;</span> ? <span class="title function_">getData</span>(data, vm) : data || &#123;&#125;;</span><br><span class="line">  <span class="comment">// 3. 无论传入的data选项是不是一个函数，它最终的值都应该是一个对象，如果不是对象的话，就抛出警告: 提示用户data应该是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123;</span><br><span class="line">    data = &#123;&#125;;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&quot;data functions should return an object:\n&quot;</span> +</span><br><span class="line">          <span class="string">&quot;https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function&quot;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data);</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span>;</span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    <span class="comment">// 4. 判断data对象中是否存在某一项的key与methods中某个属性名重复，如果存在重复，就抛出警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 再判断是否存在某一项的key与prop中某个属性名重复，如果存在重复，就抛出警告: 提示用户属性名重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">            <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 如果都没有重复，则调用proxy函数将data对象中key不以_或$开头的属性代理到实例vm上</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 7. 调用observe函数将data中的数据转化成响应式</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-computed"><a href="#初始化-computed" class="headerlink" title="初始化 computed"></a>初始化 computed</h5><blockquote><ul><li>initComputed</li><li>defineComputed</li><li>createComputedGetter</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整用法</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 仅读取</span></span><br><span class="line">    <span class="attr">aDouble</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 读取和设置</span></span><br><span class="line">    <span class="attr">aPlus</span>: &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="number">1</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = v - <span class="number">1</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">vm.<span class="property">aPlus</span>; <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.<span class="property">aPlus</span> = <span class="number">3</span>;</span><br><span class="line">vm.<span class="property">a</span>; <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.<span class="property">aDouble</span>; <span class="comment">// =&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initComputed</span>(<span class="params">vm, computed</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 定义了一个变量watchers并将其赋值为空对象，同时将其作为指针指向vm._computedWatchers</span></span><br><span class="line">  <span class="keyword">const</span> watchers = (vm.<span class="property">_computedWatchers</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>));</span><br><span class="line">  <span class="keyword">const</span> isSSR = <span class="title function_">isServerRendering</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="comment">// 2. 如果是函数，则该函数默认为取值器getter，将其赋值给变量getter；如果不是函数，则说明是一个对象，则取对象中的get属性作为取值器赋给变量getter</span></span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key];</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&quot;function&quot;</span> ? userDef : userDef.<span class="property">get</span>;</span><br><span class="line">    <span class="comment">// 3. 如果上面两种情况取到的取值器不存在，则抛出警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Getter is missing for computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot;.`</span>, vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 如果不是在服务端渲染环境下，则创建一个watcher实例，并将当前循环到的的属性名作为键，创建的watcher实例作为值存入watchers对象中</span></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      <span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">computed</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 判断当前循环到的的属性名是否存在于当前实例vm上，如果存在，则在非生产环境下抛出警告；如果不存在，则调用defineComputed函数为实例vm上设置计算属性</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">defineComputed</span>(vm, key, userDef);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">props</span> &amp;&amp; key <span class="keyword">in</span> vm.<span class="property">$options</span>.<span class="property">props</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  <span class="attr">set</span>: noop,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineComputed</span>(<span class="params">target, key, userDef</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !<span class="title function_">isServerRendering</span>(); <span class="comment">// 标识计算属性是否应该有缓存。该变量的值是当前环境是否为非服务端渲染环境，如果是非服务端渲染环境则该变量为true。也就是说，只有在非服务端渲染环境下计算属性才应该有缓存</span></span><br><span class="line">  <span class="comment">// 如果userDef是一个函数，则该函数默认为取值器getter</span></span><br><span class="line">  <span class="comment">// 调用createComputedGetter函数（关于该函数下面会介绍）创建了一个getter，</span></span><br><span class="line">  <span class="comment">// 这是因为userDef只是一个普通的getter，它并没有缓存功能，所以我们需要额外创建一个具有缓存功能的getter，</span></span><br><span class="line">  <span class="comment">// 而在服务端渲染环境下可以直接使用userDef作为getter，因为在服务端渲染环境下计算属性不需要缓存。</span></span><br><span class="line">  <span class="comment">// 由于用户没有设置setter函数，所以将sharedPropertyDefinition.set设置为noop</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = shouldCache</span><br><span class="line">      ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">      : userDef;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = noop;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果userDef不是一个函数，那么就将它当作对象处理。</span></span><br><span class="line">    <span class="comment">// 在设置sharedPropertyDefinition.get的时候先判断userDef.get是否存在，如果不存在，则将其设置为noop</span></span><br><span class="line">    <span class="comment">// 如果存在，则同上面一样</span></span><br><span class="line">    <span class="comment">// 设置sharedPropertyDefinition.set为userDef.set函数</span></span><br><span class="line">    sharedPropertyDefinition.<span class="property">get</span> = userDef.<span class="property">get</span></span><br><span class="line">      ? shouldCache &amp;&amp; userDef.<span class="property">cache</span> !== <span class="literal">false</span></span><br><span class="line">        ? <span class="title function_">createComputedGetter</span>(key)</span><br><span class="line">        : userDef.<span class="property">get</span></span><br><span class="line">      : noop;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = userDef.<span class="property">set</span> ? userDef.<span class="property">set</span> : noop;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断在非生产环境下如果用户没有设置setter的话，那么就给setter一个默认函数，这是为了防止用户在没有设置setter的情况下修改计算属性，从而为其抛出警告</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> === noop</span><br><span class="line">  ) &#123;</span><br><span class="line">    sharedPropertyDefinition.<span class="property">set</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`Computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="variable language_">this</span></span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用Object.defineProperty方法将属性key绑定到target上，其中的属性描述符就是上面设置的sharedPropertyDefinition。如此以来，就将计算属性绑定到实例vm上了</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComputedGetter</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">computedGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[key];</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      watcher.<span class="title function_">depend</span>();</span><br><span class="line">      <span class="keyword">return</span> watcher.<span class="title function_">evaluate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化-watch"><a href="#初始化-watch" class="headerlink" title="初始化 watch"></a>初始化 watch</h5><blockquote><ul><li>initWatch</li><li>createWatcher</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整用法</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">e</span>: &#123;</span><br><span class="line">      <span class="attr">f</span>: &#123;</span><br><span class="line">        <span class="attr">g</span>: <span class="number">5</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="keyword">function</span> (<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new: %s, old: %s&quot;</span>, val, oldVal);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// methods选项中的方法名</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&quot;someMethod&quot;</span>,</span><br><span class="line">    <span class="comment">// 深度侦听，该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    <span class="attr">c</span>: &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="keyword">function</span> (<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    <span class="attr">d</span>: &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="string">&quot;someMethod&quot;</span>,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 调用多个回调</span></span><br><span class="line">    <span class="attr">e</span>: [</span><br><span class="line">      <span class="string">&quot;handle1&quot;</span>,</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">handle2</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">handler</span>: <span class="keyword">function</span> <span class="title function_">handle3</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">          <span class="comment">/* ... */</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 侦听表达式</span></span><br><span class="line">    <span class="string">&quot;e.f&quot;</span>: <span class="keyword">function</span> (<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">vm.<span class="property">a</span> = <span class="number">2</span>; <span class="comment">// =&gt; new: 2, old: 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initWatch</span>(<span class="params">vm, watch</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">createWatcher</span>(vm, key, handler[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">createWatcher</span>(vm, key, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWatcher</span>(<span class="params">vm, expOrFn, handler, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 写法 c d e</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(handler)) &#123;</span><br><span class="line">    options = handler;</span><br><span class="line">    handler = handler.<span class="property">handler</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写法 b</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    handler = vm[handler];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他情况，认为它是一个函数，就不做任何处理</span></span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板编译阶段"><a href="#模板编译阶段" class="headerlink" title="模板编译阶段"></a>模板编译阶段</h3><blockquote><p>将模板编译成渲染函数，vm.$mount 方法开始<br>模板编译阶段并不是存在于 Vue 的所有构建版本中，它只存在于完整版 (即 vue.js) 中，在只包含运行时版本 (即 vue.runtime.js) 中并不存在该阶段。vue 基于源码构建的有两个版本</p><ul><li>当使用 vue-loader 或 vueify 时，*.vue 文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段，由上一步的初始化阶段直接进入下一阶段的挂载阶段</li><li>运行时版本相比完整版体积要小大约 30%，实际开发中，需要借助像 webpack 的 vue-loader 这类工具进行编译，将 Vue 对模板的编译阶段合并到 webpack 的构建流程中，不仅减少了生产环境代码的体积，也大大提高了运行时的性能</li></ul></blockquote><h4 id="runtime-only"><a href="#runtime-only" class="headerlink" title="runtime only"></a>runtime only</h4><blockquote><p>包含运行时的版本，创建 Vue 实例、渲染并处理 Virtual DOM 等功能，有两种场景</p><ul><li>通过手写 render 函数去定义渲染过程，这个时候并不需要包含编译器的版本便可完整执行，<code>new Vue(&#123; render (h) &#123; return h(&#39;div&#39;, this.hi) &#125;&#125;)</code></li><li>借助 vue-loader 等编译工具进行编译，尽管也是利用 template 模板标签去书写代码，但是此时的 Vue 已经不需要利用编译器去负责模板的编译工作了，这个过程交给了插件去实现</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el, hydrating</span>) &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="runtime-compiler"><a href="#runtime-compiler" class="headerlink" title="runtime + compiler"></a>runtime + compiler</h4><blockquote><p>同时包含编译器和运行时的完整版本<br>对 template 进行编译，<code>new Vue(&#123; template: &#39;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#39; &#125;)</code></p><ul><li>先将 Vue 原型上的 $mount 方法先缓存起来，记作变量 mount</li><li>在源码中，是先定义只包含运行时版本的 $mount 方法，再定义完整版本的 $mount 方法，所以此时缓存的 mount 变量就是只包含运行时版本的 $mount 方法</li><li>在完整版本的 $mount 方法中将模板编译完成后需要回头去调只包含运行时版本的 $mount 方法以进入挂载阶段</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el, hydrating</span>) &#123;</span><br><span class="line">  <span class="comment">// 省略获取模板及编译代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整实现</span></span><br><span class="line"><span class="keyword">var</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el, hydrating</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 根据传入的el参数获取DOM元素</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el);</span><br><span class="line">  <span class="comment">// 2. 获取到el对应的DOM元素如果是body或html元素时，将会抛出警告</span></span><br><span class="line">  <span class="comment">// 因为Vue会将模板中的内容替换el对应的DOM元素，如果是body或html元素时，替换之后将会破坏整个DOM文档，所以不允许el是body或html</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&quot;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> options = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">  <span class="comment">// 3. 没有手写render函数的情况下获取传入的模板template</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> template = options.<span class="property">template</span>;</span><br><span class="line">    <span class="comment">// 4. 获取用户传入的template选项赋给变量template，如果变量template存在，则接着判断如果template是字符串并且以##开头，则认为template是id选择符，则调用idToTemplate函数获取到选择符对应的DOM元素的innerHTML作为模板</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template);</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (!template) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">&quot;Template element not found or is empty: &quot;</span> + options.<span class="property">template</span>,</span><br><span class="line">              <span class="variable language_">this</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 5. 如果template不是字符串，那就判断它是不是一个DOM元素，如果是，则使用该DOM元素的innerHTML作为模板</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">        template = template.<span class="property">innerHTML</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 6. 如果既不是字符串，也不是DOM元素，此时会抛出警告: 提示用户template选项无效</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">&quot;invalid template option:&quot;</span> + template, <span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 如果变量template不存在，表明用户没有传入template选项，则根据传入的el参数调用getOuterHTML函数获取外部模板</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getOuterHTML</span>(<span class="params">el</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (el.<span class="property">outerHTML</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> el.<span class="property">outerHTML</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        container.<span class="title function_">appendChild</span>(el.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">return</span> container.<span class="property">innerHTML</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 将template编译成渲染函数，并设置到$options上</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&quot;compile&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> ref = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">        template,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">outputSourceRange</span>: <span class="string">&quot;development&quot;</span> !== <span class="string">&quot;production&quot;</span>,</span><br><span class="line">          <span class="attr">shouldDecodeNewlines</span>: shouldDecodeNewlines,</span><br><span class="line">          <span class="attr">shouldDecodeNewlinesForHref</span>: shouldDecodeNewlinesForHref,</span><br><span class="line">          <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">          <span class="attr">comments</span>: options.<span class="property">comments</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="variable language_">this</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">var</span> render = ref.<span class="property">render</span>;</span><br><span class="line">      <span class="keyword">var</span> staticRenderFns = ref.<span class="property">staticRenderFns</span>;</span><br><span class="line">      options.<span class="property">render</span> = render;</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&quot;compile end&quot;</span>);</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">&quot;vue &quot;</span> + <span class="variable language_">this</span>.<span class="property">_name</span> + <span class="string">&quot; compile&quot;</span>, <span class="string">&quot;compile&quot;</span>, <span class="string">&quot;compile end&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><blockquote><p>将实例挂载到指定的 DOM 上，即将模板渲染到真实 DOM 中</p><ul><li>创建 Vue 实例并用其替换 el 选项对应的 DOM 元素</li><li>开启对模板中数据 (状态) 的监控，当数据 (状态) 发生变化时通知其依赖进行视图更新</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params">vm, el, hydrating</span>) &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el;</span><br><span class="line">  <span class="comment">// 1. 不存在则设置一个默认的渲染函数createEmptyVNode，该渲染函数会创建一个注释类型的VNode节点</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 触发beforeMount生命周期，触发后标志着正式开始执行挂载操作</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&quot;beforeMount&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 定义 updateComponent 函数</span></span><br><span class="line">  <span class="comment">// 首先执行渲染函数vm._render()得到一份最新的VNode节点树，</span></span><br><span class="line">  <span class="comment">// 然后执行vm._update()方法对最新的VNode节点树与上一次渲染的旧VNode节点树进行对比并更新DOM节点(即patch操作)，完成一次渲染</span></span><br><span class="line">  <span class="comment">// --&gt;  如果调用了updateComponent函数，就会将最新的模板内容渲染到视图页面中，这样就完成了挂载操作的一半工作</span></span><br><span class="line">  <span class="comment">// --&gt;  剩下一半工作为开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新</span></span><br><span class="line">  updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="comment">// 触发数据或者函数内数据的getter方法，在getter方法中会将watcher实例添加到该数据的依赖列表中，当该数据发生变化时会通知依赖列表中所有的依赖，依赖接收到通知后就会调用第四个参数回调函数去更新视图</span></span><br><span class="line">    <span class="comment">// updateComponent函数中读取的所有数据都将被watcher所监控，这些数据中只要有任何一个发生了变化，那么watcher都将会得到通知，从而会去调用第四个参数回调函数去更新视图，如此反复，直到实例被销毁</span></span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">before</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">          <span class="title function_">callHook</span>(vm, <span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 mounted</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><blockquote><p>将当前的 Vue 实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$destroy</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 1. 判断当前实例是否处于正在被销毁的状态</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_isBeingDestroyed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 触发生命周期钩子函数beforeDestroy，标志当前实例正式开始销毁</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&quot;beforeDestroy&quot;</span>);</span><br><span class="line">  vm.<span class="property">_isBeingDestroyed</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 3. 将当前的Vue实例从其父级实例中删除</span></span><br><span class="line">  <span class="keyword">const</span> parent = vm.<span class="property">$parent</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !parent.<span class="property">_isBeingDestroyed</span> &amp;&amp; !vm.<span class="property">$options</span>.<span class="property">abstract</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(parent.<span class="property">$children</span>, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 移除依赖追踪和事件监听，实例身上的依赖包含两部分</span></span><br><span class="line">  <span class="comment">// - 实例自身依赖其他数据，需要将实例自身从其他数据的依赖列表中删除</span></span><br><span class="line">  <span class="comment">// - 实例内的数据对其他数据的依赖（如用户使用$watch创建的依赖），也需要从其他数据的依赖列表中删除实例内数据</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_watcher</span>) &#123;</span><br><span class="line">    <span class="comment">// 将实例自身从其他数据的依赖列表中删除</span></span><br><span class="line">    vm.<span class="property">_watcher</span>.<span class="title function_">teardown</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历 _watchers 列表，移除实例内数据对其他数据的依赖</span></span><br><span class="line">  <span class="keyword">let</span> i = vm.<span class="property">_watchers</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    vm.<span class="property">_watchers</span>[i].<span class="title function_">teardown</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 移除实例内响应式数据的引用、给当前实例上添加_isDestroyed属性来表示当前实例已经被销毁，同时将实例的VNode树设置为null</span></span><br><span class="line">  <span class="comment">// frozen object may not have observer.</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_data</span>.<span class="property">__ob__</span>) &#123;</span><br><span class="line">    vm.<span class="property">_data</span>.<span class="property">__ob__</span>.<span class="property">vmCount</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// call the last hook...</span></span><br><span class="line">  vm.<span class="property">_isDestroyed</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line">  vm.<span class="title function_">__patch__</span>(vm.<span class="property">_vnode</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 6. 触发生命周期钩子函数destroyed</span></span><br><span class="line">  <span class="comment">// fire destroyed hook</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&quot;destroyed&quot;</span>);</span><br><span class="line">  <span class="comment">// 7. 调用实例的vm.$off方法，移除实例上的所有事件监听器</span></span><br><span class="line">  vm.$off();</span><br><span class="line">  <span class="comment">// 8. 移除一些相关属性的引用</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">    vm.<span class="property">$el</span>.<span class="property">__vue__</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// release circular reference (##6759)</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span>) &#123;</span><br><span class="line">    vm.<span class="property">$vnode</span>.<span class="property">parent</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 模版编译</title>
      <link href="/articles/vue/template/"/>
      <url>/articles/vue/template/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将模板转化成供 Vue 实例在挂载时可调用的 render 函数。分为三个节点</p><ul><li>模板解析阶段</li><li>优化阶段</li><li>代码生成阶段</li></ul></blockquote><p><img src="/images/vue/template_1.jpg" alt=""></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span>(<span class="params"></span></span><br><span class="line"><span class="params">  template,</span></span><br><span class="line"><span class="params">  options</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 模板解析阶段: 用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options);</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 优化阶段: 遍历AST，找出其中的静态节点，并打上标记</span></span><br><span class="line">    <span class="title function_">optimize</span>(ast, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 代码生成阶段: 将AST转换成渲染函数</span></span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><blockquote><p>将模板字符串用正则等方式解析成 AST</p></blockquote><h4 id="parseHTML"><a href="#parseHTML" class="headerlink" title="parseHTML"></a>parseHTML</h4><blockquote><p>html 解析器，解析模板字符串</p><p>4 个钩子函数: start()、end()、chars()、comment()</p><p>解析不同的内容</p><ul><li>解析 HTML 注释，例如 <code>&lt;!-- 我是注释 --&gt;</code>: 正则匹配 <code>&lt;!--</code> 开头和 <code>--&gt;</code> 结尾的</li><li>解析条件注释，例如 <code>&lt;!-- [if !IE]&gt; --&gt;我是注释&lt;!--&lt; ![endif] --&gt;</code>: 正则匹配 <code>&lt;![</code> 开头和 <code>]&gt;</code> 结尾的</li><li>解析 DOCTYPE，例如 <code>&lt;!DOCTYPE html&gt;</code>: 同解析条件注释</li><li>解析开始标签: 调用 parseStartTag 函数，完成后调用 handleStartTag 生成 AST</li><li><ul><li>解析标签属性</li></ul></li><li><ul><li>解析标签是否是自闭合</li></ul></li><li>解析结束标签: 如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到 null</li><li>解析文本</li><li><ul><li>匹配 &lt; 出现的位置</li></ul></li><li><ul><li>如果第一个 &lt; 在第一个位置，那么说明模板字符串是以其它 5 种类型开始的；</li></ul></li><li><ul><li>如果第一个 &lt; 不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个 &lt; 出现的位置就都是文本内容了；</li></ul></li><li><ul><li>如果在整个模板字符串里没有找到 &lt;，那说明整个模板字符串都是文本</li></ul></li></ul><p>保证 AST 节点层级关系</p><ul><li>开始标签入栈，结束标签出栈，若没有正确闭合，则抛出警告: <code>tag has no matching end tag.</code></li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params">template, options</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">parseHTML</span>(template, &#123;</span><br><span class="line">    warn,</span><br><span class="line">    <span class="attr">expectHTML</span>: options.<span class="property">expectHTML</span>,</span><br><span class="line">    <span class="attr">isUnaryTag</span>: options.<span class="property">isUnaryTag</span>,</span><br><span class="line">    <span class="attr">canBeLeftOpenTag</span>: options.<span class="property">canBeLeftOpenTag</span>,</span><br><span class="line">    <span class="attr">shouldDecodeNewlines</span>: options.<span class="property">shouldDecodeNewlines</span>,</span><br><span class="line">    <span class="attr">shouldDecodeNewlinesForHref</span>: options.<span class="property">shouldDecodeNewlinesForHref</span>,</span><br><span class="line">    <span class="attr">shouldKeepComment</span>: options.<span class="property">comments</span>,</span><br><span class="line">    <span class="comment">// 当解析到开始标签时，调用该函数，标签名tag、标签属性attrs、标签是否自闭合unary</span></span><br><span class="line">    <span class="title function_">start</span>(<span class="params">tag, attrs, unary</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = <span class="title function_">createASTElement</span>(tag, attrs, currentParent);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当解析到结束标签时，调用该函数</span></span><br><span class="line">    <span class="title function_">end</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">// 当解析到文本时，调用该函数</span></span><br><span class="line">    <span class="comment">// parseText: 判断传入的文本是否包含变量；构造expression；构造tokens</span></span><br><span class="line">    <span class="title function_">chars</span>(<span class="params">text</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((res = <span class="title function_">parseText</span>(text))) &#123;</span><br><span class="line">        <span class="comment">// 动态文本类型 AST 节点</span></span><br><span class="line">        <span class="keyword">let</span> element = &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">expression</span>: res.<span class="property">expression</span>,</span><br><span class="line">          <span class="attr">tokens</span>: res.<span class="property">tokens</span>,</span><br><span class="line">          text,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 静态文本类型 AST 节点</span></span><br><span class="line">        <span class="keyword">let</span> element = &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="number">3</span>,</span><br><span class="line">          text,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当解析到注释时，调用该函数</span></span><br><span class="line">    <span class="title function_">comment</span>(<span class="params">text</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="number">3</span>,</span><br><span class="line">        text,</span><br><span class="line">        <span class="attr">isComment</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createASTElement</span>(<span class="params">tag, attrs, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">    tag,</span><br><span class="line">    <span class="attr">attrsList</span>: attrs,</span><br><span class="line">    <span class="attr">attrsMap</span>: <span class="title function_">makeAttrsMap</span>(attrs),</span><br><span class="line">    parent,</span><br><span class="line">    <span class="attr">children</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseHTML</span>(<span class="params">html, options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> stack = []; <span class="comment">// 维护AST节点层级的栈</span></span><br><span class="line">  <span class="keyword">var</span> expectHTML = options.<span class="property">expectHTML</span>;</span><br><span class="line">  <span class="keyword">var</span> isUnaryTag$$1 = options.<span class="property">isUnaryTag</span> || no; <span class="comment">//用来检测一个标签是否是可以省略闭合标签的非自闭合标签</span></span><br><span class="line">  <span class="keyword">var</span> canBeLeftOpenTag$$1 = options.<span class="property">canBeLeftOpenTag</span> || no;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>; <span class="comment">//解析游标，标识当前从何处开始解析模板字符串</span></span><br><span class="line">  <span class="keyword">var</span> last, <span class="comment">// 存储剩余还未解析的模板字符串</span></span><br><span class="line">    lastTag; <span class="comment">// 存储着位于 stack 栈顶的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕</span></span><br><span class="line">  <span class="keyword">while</span> (html) &#123;</span><br><span class="line">    last = html;</span><br><span class="line">    <span class="comment">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span></span><br><span class="line">    <span class="comment">// lastTag为栈顶元素，!lastTag即表示当前html字符串没有父节点，而isPlainTextElement(lastTag) 是检测 lastTag 是否为是那三个纯文本标签之一，是的话返回true，不是返回fasle</span></span><br><span class="line">    <span class="keyword">if</span> (!lastTag || !<span class="title function_">isPlainTextElement</span>(lastTag)) &#123;</span><br><span class="line">      <span class="keyword">let</span> textEnd = html.<span class="title function_">indexOf</span>(<span class="string">&quot;&lt;&quot;</span>);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果html字符串是以&#x27;&lt;&#x27;开头,则有以下几种可能</span></span><br><span class="line"><span class="comment">       * 开始标签:&lt;div&gt;</span></span><br><span class="line"><span class="comment">       * 结束标签:&lt;/div&gt;</span></span><br><span class="line"><span class="comment">       * 注释:&lt;!-- 我是注释 --&gt;</span></span><br><span class="line"><span class="comment">       * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;</span></span><br><span class="line"><span class="comment">       * DOCTYPE:&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">       * 需要一一去匹配尝试</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析是否是注释</span></span><br><span class="line">        <span class="keyword">if</span> (comment.<span class="title function_">test</span>(html)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析是否是条件注释</span></span><br><span class="line">        <span class="keyword">if</span> (conditionalComment.<span class="title function_">test</span>(html)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析是否是DOCTYPE</span></span><br><span class="line">        <span class="keyword">const</span> doctypeMatch = html.<span class="title function_">match</span>(doctype);</span><br><span class="line">        <span class="keyword">if</span> (doctypeMatch) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析是否是结束标签</span></span><br><span class="line">        <span class="keyword">const</span> endTagMatch = html.<span class="title function_">match</span>(endTag);</span><br><span class="line">        <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配是否是开始标签</span></span><br><span class="line">        <span class="keyword">const</span> startTagMatch = <span class="title function_">parseStartTag</span>();</span><br><span class="line">        <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果html字符串不是以&#x27;&lt;&#x27;开头,则解析文本类型</span></span><br><span class="line">      <span class="keyword">let</span> text, rest, next;</span><br><span class="line">      <span class="keyword">if</span> (textEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果在html字符串中没有找到&#x27;&lt;&#x27;，表示这一段html字符串都是纯文本</span></span><br><span class="line">      <span class="keyword">if</span> (textEnd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        text = html;</span><br><span class="line">        html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把截取出来的text转化成textAST</span></span><br><span class="line">      <span class="keyword">if</span> (options.<span class="property">chars</span> &amp;&amp; text) &#123;</span><br><span class="line">        options.<span class="title function_">chars</span>(text);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将整个字符串作为文本对待</span></span><br><span class="line">    <span class="keyword">if</span> (html === last) &#123;</span><br><span class="line">      options.<span class="property">chars</span> &amp;&amp; options.<span class="title function_">chars</span>(html);</span><br><span class="line">      <span class="keyword">if</span> (!stack.<span class="property">length</span> &amp;&amp; options.<span class="property">warn</span>) &#123;</span><br><span class="line">        options.<span class="title function_">warn</span>(<span class="string">&#x27;Mal-formatted tag at end of template: &quot;&#x27;</span> + html + <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// html === last，即html字符串中的标签格式有误时会跳出while循环，调用</span></span><br><span class="line">  <span class="comment">// 于处理栈中剩余未处理的标签，此时parseEndTag函数里的pos为0，那么pos&gt;=0就会恒成立，那么就会逐个警告缺少闭合标签，并调用 options.end将其闭合</span></span><br><span class="line">  <span class="title function_">parseEndTag</span>();</span><br><span class="line">  <span class="comment">//parse 开始标签</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">parseStartTag</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">//处理 parseStartTag 的结果</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStartTag</span>(<span class="params">match</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">//parse 结束标签</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">parseEndTag</span>(<span class="params">tagName, start, end</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析html注释</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> comment = <span class="regexp">/^&lt;!\--/</span>;</span><br><span class="line">  <span class="keyword">if</span> (comment.<span class="title function_">test</span>(html)) &#123;</span><br><span class="line">    <span class="comment">// 若为注释，则继续查找是否存在&#x27;--&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> commentEnd = html.<span class="title function_">indexOf</span>(<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commentEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 若存在 &#x27;--&gt;&#x27;,继续判断options中是否保留注释，可以在&lt;template&gt;&lt;/template&gt;标签上配置comments选项，对应options.shouldKeepComment</span></span><br><span class="line">      <span class="keyword">if</span> (options.<span class="property">shouldKeepComment</span>) &#123;</span><br><span class="line">        <span class="comment">// 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点</span></span><br><span class="line">        options.<span class="title function_">comment</span>(html.<span class="title function_">substring</span>(<span class="number">4</span>, commentEnd));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若不保留注释，则将游标移动到&#x27;--&gt;&#x27;之后，继续向后解析</span></span><br><span class="line">      <span class="title function_">advance</span>(commentEnd + <span class="number">3</span>);</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(</span><br><span class="line">  <span class="comment">// 解析条件注释</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> conditionalComment = <span class="regexp">/^&lt;!\[/</span>;</span><br><span class="line">    <span class="keyword">if</span> (conditionalComment.<span class="title function_">test</span>(html)) &#123;</span><br><span class="line">      <span class="comment">// 若为条件注释，则继续查找是否存在&#x27;]&gt;&#x27;</span></span><br><span class="line">      <span class="keyword">const</span> conditionalEnd = html.<span class="title function_">indexOf</span>(<span class="string">&quot;]&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (conditionalEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若存在 &#x27;]&gt;&#x27;,则从原本的html字符串中把条件注释截掉，</span></span><br><span class="line">        <span class="comment">// 把剩下的内容重新赋给html，继续向后匹配</span></span><br><span class="line">        <span class="title function_">advance</span>(conditionalEnd + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)(</span><br><span class="line">  <span class="comment">// 解析doc</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> doctype = <span class="regexp">/^&lt;!DOCTYPE [^&gt;]+&gt;/i</span>;</span><br><span class="line">    <span class="comment">// 解析是否是DOCTYPE</span></span><br><span class="line">    <span class="keyword">const</span> doctypeMatch = html.<span class="title function_">match</span>(doctype);</span><br><span class="line">    <span class="keyword">if</span> (doctypeMatch) &#123;</span><br><span class="line">      <span class="title function_">advance</span>(doctypeMatch[<span class="number">0</span>].<span class="property">length</span>);</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)(</span><br><span class="line">  <span class="comment">// 解析开始标签</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ncname = <span class="string">&quot;[a-zA-Z_][\\w\\-\\.]*&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>;</span><br><span class="line">    <span class="keyword">const</span> attribute =</span><br><span class="line">      <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">parseStartTag</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> start = html.<span class="title function_">match</span>(startTagOpen);</span><br><span class="line">      <span class="comment">// &#x27;&lt;div&gt;&lt;/div&gt;&#x27;.match(startTagOpen)  =&gt; [&#x27;&lt;div&#x27;,&#x27;div&#x27;,index:0,input:&#x27;&lt;div&gt;&lt;/div&gt;&#x27;]</span></span><br><span class="line">      <span class="keyword">if</span> (start) &#123;</span><br><span class="line">        <span class="keyword">const</span> match = &#123;</span><br><span class="line">          <span class="attr">tagName</span>: start[<span class="number">1</span>],</span><br><span class="line">          <span class="attr">attrs</span>: [],</span><br><span class="line">          <span class="attr">start</span>: index,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">advance</span>(start[<span class="number">0</span>].<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">let</span> end, attr;</span><br><span class="line">        <span class="comment">/** 解析标签属性</span></span><br><span class="line"><span class="comment">         * &lt;div a=1 b=2 c=3&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">         * 从&lt;div之后到开始标签的结束符号&#x27;&gt;&#x27;之前，一直匹配属性attrs</span></span><br><span class="line"><span class="comment">         * 所有属性匹配完之后，html字符串还剩下</span></span><br><span class="line"><span class="comment">         * 自闭合标签剩下: &#x27;/&gt;&#x27;</span></span><br><span class="line"><span class="comment">         * 非自闭合标签剩下: &#x27;&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (</span><br><span class="line">          !(end = html.<span class="title function_">match</span>(startTagClose)) &amp;&amp;</span><br><span class="line">          (attr = html.<span class="title function_">match</span>(attribute))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="title function_">advance</span>(attr[<span class="number">0</span>].<span class="property">length</span>);</span><br><span class="line">          match.<span class="property">attrs</span>.<span class="title function_">push</span>(attr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 解析标签是否是自闭合</span></span><br><span class="line"><span class="comment">         * 这里判断了该标签是否为自闭合标签</span></span><br><span class="line"><span class="comment">         * 自闭合标签如:&lt;input type=&#x27;text&#x27; /&gt;</span></span><br><span class="line"><span class="comment">         * 非自闭合标签如:&lt;div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">         * &#x27;&gt;&lt;/div&gt;&#x27;.match(startTagClose) =&gt; [&quot;&gt;&quot;, &quot;&quot;, index: 0, input: &quot;&gt;&lt;/div&gt;&quot;, groups: undefined]</span></span><br><span class="line"><span class="comment">         * &#x27;/&gt;&lt;div&gt;&lt;/div&gt;&#x27;.match(startTagClose) =&gt; [&quot;/&gt;&quot;, &quot;/&quot;, index: 0, input: &quot;/&gt;&lt;div&gt;&lt;/div&gt;&quot;, groups: undefined]</span></span><br><span class="line"><span class="comment">         * 因此，我们可以通过end[1]是否是&quot;/&quot;来判断该标签是否是自闭合标签</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end) &#123;</span><br><span class="line">          match.<span class="property">unarySlash</span> = end[<span class="number">1</span>];</span><br><span class="line">          <span class="title function_">advance</span>(end[<span class="number">0</span>].<span class="property">length</span>);</span><br><span class="line">          match.<span class="property">end</span> = index;</span><br><span class="line">          <span class="keyword">return</span> match;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleStartTag</span>(<span class="params">match</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> tagName = match.<span class="property">tagName</span>; <span class="comment">// 开始标签的标签名</span></span><br><span class="line">      <span class="keyword">const</span> unarySlash = match.<span class="property">unarySlash</span>; <span class="comment">// 是否为自闭合标签的标志，自闭合为&quot;&quot;,非自闭合为&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expectHTML) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> unary = <span class="title function_">isUnaryTag</span>(tagName) || !!unarySlash; <span class="comment">// 布尔值，标志是否为自闭合标签</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> l = match.<span class="property">attrs</span>.<span class="property">length</span>; <span class="comment">// match.attrs 数组的长度</span></span><br><span class="line">      <span class="keyword">const</span> attrs = <span class="keyword">new</span> <span class="title class_">Array</span>(l); <span class="comment">// 一个与match.attrs数组长度相等的数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> args = match.<span class="property">attrs</span>[i];</span><br><span class="line">        <span class="keyword">const</span> value = args[<span class="number">3</span>] || args[<span class="number">4</span>] || args[<span class="number">5</span>] || <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 shouldDecodeNewlines 为 true，意味着 Vue 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。</span></span><br><span class="line">        <span class="comment">// 而shouldDecodeNewlinesForHref为 true 意味着Vue在编译模板的时候，要对a标签的 href属性值中的换行符或制表符做兼容处理。</span></span><br><span class="line">        <span class="keyword">const</span> shouldDecodeNewlines =</span><br><span class="line">          tagName === <span class="string">&quot;a&quot;</span> &amp;&amp; args[<span class="number">1</span>] === <span class="string">&quot;href&quot;</span></span><br><span class="line">            ? options.<span class="property">shouldDecodeNewlinesForHref</span></span><br><span class="line">            : options.<span class="property">shouldDecodeNewlines</span>;</span><br><span class="line"></span><br><span class="line">        attrs[i] = &#123;</span><br><span class="line">          <span class="attr">name</span>: args[<span class="number">1</span>], <span class="comment">// 标签属性的属性名，如class</span></span><br><span class="line">          <span class="attr">value</span>: <span class="title function_">decodeAttr</span>(value, shouldDecodeNewlines), <span class="comment">// 标签属性的属性值，如class对应的a</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 非自闭合标签</span></span><br><span class="line">      <span class="keyword">if</span> (!unary) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(&#123;</span><br><span class="line">          <span class="attr">tag</span>: tagName,</span><br><span class="line">          <span class="attr">lowerCasedTag</span>: tagName.<span class="title function_">toLowerCase</span>(),</span><br><span class="line">          <span class="attr">attrs</span>: attrs,</span><br><span class="line">        &#125;);</span><br><span class="line">        lastTag = tagName;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 自闭合标签</span></span><br><span class="line">      <span class="keyword">if</span> (options.<span class="property">start</span>) &#123;</span><br><span class="line">        options.<span class="title function_">start</span>(tagName, attrs, unary, match.<span class="property">start</span>, match.<span class="property">end</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)(</span><br><span class="line">  <span class="comment">// 解析结束标签</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ncname = <span class="string">&quot;[a-zA-Z_][\\w\\-\\.]*&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^&lt;\\/<span class="subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>);</span><br><span class="line">    <span class="keyword">const</span> endTagMatch = html.<span class="title function_">match</span>(endTag);</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&lt;/div&gt;&quot;</span>.<span class="title function_">match</span>(endTag); <span class="comment">// [&quot;&lt;/div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;/div&gt;&quot;, groups: undefined]</span></span><br><span class="line">    <span class="string">&quot;&lt;div&gt;&quot;</span>.<span class="title function_">match</span>(endTag); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">      <span class="keyword">const</span> curIndex = index;</span><br><span class="line">      <span class="title function_">advance</span>(endTagMatch[<span class="number">0</span>].<span class="property">length</span>);</span><br><span class="line">      <span class="title function_">parseEndTag</span>(endTagMatch[<span class="number">1</span>], curIndex, index);</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三个可选参数</span></span><br><span class="line">    <span class="comment">// 第一种是三个参数都传递，用于处理普通的结束标签</span></span><br><span class="line">    <span class="comment">// 第二种是只传递tagName</span></span><br><span class="line">    <span class="comment">// 第三种是三个参数都不传递，用于处理栈中剩余未处理的标签</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">parseEndTag</span>(<span class="params">tagName, start, end</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> pos, lowerCasedTagName;</span><br><span class="line">      <span class="keyword">if</span> (start == <span class="literal">null</span>) start = index;</span><br><span class="line">      <span class="keyword">if</span> (end == <span class="literal">null</span>) end = index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (tagName) &#123;</span><br><span class="line">        lowerCasedTagName = tagName.<span class="title function_">toLowerCase</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果tagName存在，那么就从后往前遍历栈，在栈中寻找与tagName相同的标签并记录其所在的位置pos，如果tagName不存在，则将pos置为0</span></span><br><span class="line">      <span class="keyword">if</span> (tagName) &#123;</span><br><span class="line">        <span class="keyword">for</span> (pos = stack.<span class="property">length</span> - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; pos--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (stack[pos].<span class="property">lowerCasedTag</span> === lowerCasedTagName) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Close all the open elements, up the stack</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = stack.<span class="property">length</span> - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">          <span class="comment">// 如果发现stack栈中存在索引大于pos的元素，那么该元素一定是缺少闭合标签的</span></span><br><span class="line">          <span class="comment">// 这是因为在正常情况下，stack栈的栈顶元素应该和当前的结束标签tagName 匹配，也就是说正常的pos应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">            (i &gt; pos || !tagName) &amp;&amp;</span><br><span class="line">            options.<span class="property">warn</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            options.<span class="title function_">warn</span>(<span class="string">`tag &lt;<span class="subst">$&#123;stack[i].tag&#125;</span>&gt; has no matching end tag.`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 立即将其闭合，为了保证解析结果的正确性</span></span><br><span class="line">          <span class="keyword">if</span> (options.<span class="property">end</span>) &#123;</span><br><span class="line">            options.<span class="title function_">end</span>(stack[i].<span class="property">tag</span>, start, end);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把pos位置以后的元素都从stack栈中弹出，以及把lastTag更新为栈顶元素</span></span><br><span class="line">        stack.<span class="property">length</span> = pos;</span><br><span class="line">        lastTag = pos &amp;&amp; stack[pos - <span class="number">1</span>].<span class="property">tag</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 单独判断 br 或p标签</span></span><br><span class="line">      <span class="comment">// 浏览器会自动把&lt;/br&gt;标签解析为正常的 &lt;br&gt;标签，而对于&lt;/p&gt;浏览器则自动将其补全为&lt;p&gt;&lt;/p&gt;，所以Vue为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (lowerCasedTagName === <span class="string">&quot;br&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">start</span>) &#123;</span><br><span class="line">          options.<span class="title function_">start</span>(tagName, [], <span class="literal">true</span>, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowerCasedTagName === <span class="string">&quot;p&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">start</span>) &#123;</span><br><span class="line">          options.<span class="title function_">start</span>(tagName, [], <span class="literal">false</span>, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">end</span>) &#123;</span><br><span class="line">          options.<span class="title function_">end</span>(tagName, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)(</span><br><span class="line">  <span class="comment">// 解析文本</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> textEnd = html.<span class="title function_">indexOf</span>(<span class="string">&quot;&lt;&quot;</span>);</span><br><span class="line">    <span class="comment">// &#x27;&lt;&#x27; 在第一个位置，为其余5种类型</span></span><br><span class="line">    <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &#x27;&lt;&#x27; 不在第一个位置，文本开头</span></span><br><span class="line">    <span class="keyword">if</span> (textEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果html字符串不是以&#x27;&lt;&#x27;开头,说明&#x27;&lt;&#x27;前面的都是纯文本，无需处理</span></span><br><span class="line">      <span class="comment">// 那就把&#x27;&lt;&#x27;以后的内容拿出来赋给rest</span></span><br><span class="line">      rest = html.<span class="title function_">slice</span>(textEnd);</span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        !endTag.<span class="title function_">test</span>(rest) &amp;&amp;</span><br><span class="line">        !startTagOpen.<span class="title function_">test</span>(rest) &amp;&amp;</span><br><span class="line">        !comment.<span class="title function_">test</span>(rest) &amp;&amp;</span><br><span class="line">        !conditionalComment.<span class="title function_">test</span>(rest)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// &lt; in plain text, be forgiving and treat it as text</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用&#x27;&lt;&#x27;以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span></span><br><span class="line"><span class="comment">         * 如果都匹配不上，表示&#x27;&lt;&#x27;是属于文本本身的内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 在&#x27;&lt;&#x27;之后查找是否还有&#x27;&lt;&#x27;</span></span><br><span class="line">        next = rest.<span class="title function_">indexOf</span>(<span class="string">&quot;&lt;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果没有了，表示&#x27;&lt;&#x27;后面也是文本</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果还有，表示&#x27;&lt;&#x27;是文本中的一个字符</span></span><br><span class="line">        textEnd += next;</span><br><span class="line">        <span class="comment">// 那就把next之后的内容截出来继续下一轮循环匹配</span></span><br><span class="line">        rest = html.<span class="title function_">slice</span>(textEnd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// &#x27;&lt;&#x27;是结束标签的开始 ,说明从开始到&#x27;&lt;&#x27;都是文本，截取出来</span></span><br><span class="line">      text = html.<span class="title function_">substring</span>(<span class="number">0</span>, textEnd);</span><br><span class="line">      <span class="title function_">advance</span>(textEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本</span></span><br><span class="line">    <span class="keyword">if</span> (textEnd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      text = html;</span><br><span class="line">      html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把截取出来的text转化成textAST</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">chars</span> &amp;&amp; text) &#123;</span><br><span class="line">      options.<span class="title function_">chars</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="parseText"><a href="#parseText" class="headerlink" title="parseText"></a>parseText</h4><blockquote><p>文本解析器，解析静态和动态文本</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;我叫&#123;&#123;name&#125;&#125;，我今年&#123;&#123;age&#125;&#125;岁了&quot;</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">parseText</span>(text)</span><br><span class="line">res = &#123;</span><br><span class="line">    <span class="attr">expression</span>:<span class="string">&quot;我叫&quot;</span>+<span class="title function_">_s</span>(name)+<span class="string">&quot;，我今年&quot;</span>+<span class="title function_">_s</span>(age)+<span class="string">&quot;岁了&quot;</span>,</span><br><span class="line">    <span class="attr">tokens</span>:[</span><br><span class="line">        <span class="string">&quot;我叫&quot;</span>,</span><br><span class="line">        &#123;<span class="string">&#x27;@binding&#x27;</span>: name &#125;,</span><br><span class="line">        <span class="string">&quot;，我今年&quot;</span></span><br><span class="line">        &#123;<span class="string">&#x27;@binding&#x27;</span>: age &#125;,</span><br><span class="line">    <span class="string">&quot;岁了&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultTagRE = <span class="regexp">/\&#123;\&#123;((?:.|\n)+?)\&#125;\&#125;/g</span>;</span><br><span class="line"><span class="keyword">const</span> buildRegex = <span class="title function_">cached</span>(<span class="function">(<span class="params">delimiters</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> open = delimiters[<span class="number">0</span>].<span class="title function_">replace</span>(regexEscapeRE, <span class="string">&quot;\\$&amp;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> close = delimiters[<span class="number">1</span>].<span class="title function_">replace</span>(regexEscapeRE, <span class="string">&quot;\\$&amp;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(open + <span class="string">&quot;((?:.|\\n)+?)&quot;</span> + close, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseText</span>(<span class="params">text, delimiters</span>) &#123;</span><br><span class="line">  <span class="comment">// 一个正则表达式，用来检查文本中是否包含变量</span></span><br><span class="line">  <span class="comment">// delimiters 默认为 &#123;&#123;&#125;&#125;，也可以自定义变量包裹符，比如 %name%</span></span><br><span class="line">  <span class="keyword">const</span> tagRE = delimiters ? <span class="title function_">buildRegex</span>(delimiters) : defaultTagRE;</span><br><span class="line">  <span class="keyword">if</span> (!tagRE.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tokens = [];</span><br><span class="line">  <span class="keyword">const</span> rawTokens = [];</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * let lastIndex = tagRE.lastIndex = 0</span></span><br><span class="line"><span class="comment">   * 上面这行代码等同于下面这两行代码:</span></span><br><span class="line"><span class="comment">   * tagRE.lastIndex = 0</span></span><br><span class="line"><span class="comment">   * let lastIndex = tagRE.lastIndex</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> lastIndex = (tagRE.<span class="property">lastIndex</span> = <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> match, index, tokenValue;</span><br><span class="line">  <span class="keyword">while</span> ((match = tagRE.<span class="title function_">exec</span>(text))) &#123;</span><br><span class="line">    index = match.<span class="property">index</span>;</span><br><span class="line">    <span class="comment">// push text token</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; lastIndex) &#123;</span><br><span class="line">      <span class="comment">// 先把&#x27;&#123;&#123;&#x27;前面的文本放入tokens中</span></span><br><span class="line">      rawTokens.<span class="title function_">push</span>((tokenValue = text.<span class="title function_">slice</span>(lastIndex, index)));</span><br><span class="line">      tokens.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(tokenValue));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tag token</span></span><br><span class="line">    <span class="comment">// 取出&#x27;&#123;&#123; &#125;&#125;&#x27;中间的变量exp</span></span><br><span class="line">    <span class="keyword">const</span> exp = <span class="title function_">parseFilters</span>(match[<span class="number">1</span>].<span class="title function_">trim</span>());</span><br><span class="line">    <span class="comment">// 把变量exp改成_s(exp)形式也放入tokens中</span></span><br><span class="line">    tokens.<span class="title function_">push</span>(<span class="string">`_s(<span class="subst">$&#123;exp&#125;</span>)`</span>);</span><br><span class="line">    rawTokens.<span class="title function_">push</span>(&#123; <span class="string">&quot;@binding&quot;</span>: exp &#125;);</span><br><span class="line">    <span class="comment">// 设置lastIndex 以保证下一轮循环时，只从&#x27;&#125;&#125;&#x27;后面再开始匹配正则</span></span><br><span class="line">    lastIndex = index + match[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当剩下的text不再被正则匹配上时，表示所有变量已经处理完毕</span></span><br><span class="line">  <span class="comment">// 此时如果lastIndex &lt; text.length，表示在最后一个变量后面还有文本</span></span><br><span class="line">  <span class="comment">// 最后将后面的文本再加入到tokens中</span></span><br><span class="line">  <span class="keyword">if</span> (lastIndex &lt; text.<span class="property">length</span>) &#123;</span><br><span class="line">    rawTokens.<span class="title function_">push</span>((tokenValue = text.<span class="title function_">slice</span>(lastIndex)));</span><br><span class="line">    tokens.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(tokenValue));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后把数组tokens中的所有元素用&#x27;+&#x27;拼接起来</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">expression</span>: tokens.<span class="title function_">join</span>(<span class="string">&quot;+&quot;</span>),</span><br><span class="line">    <span class="attr">tokens</span>: rawTokens,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>遍历 AST，找出其中的静态节点，并打上标记，从而在 patch 过程中，diff 算法直接跳过静态节点，减少比较的过程</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">optimize</span>(<span class="params">root, options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  isStaticKey = <span class="title function_">genStaticKeysCached</span>(options.<span class="property">staticKeys</span> || <span class="string">&quot;&quot;</span>);</span><br><span class="line">  isPlatformReservedTag = options.<span class="property">isReservedTag</span> || no;</span><br><span class="line">  <span class="comment">// 标记静态节点</span></span><br><span class="line">  <span class="title function_">markStatic</span>(root);</span><br><span class="line">  <span class="comment">// 标记静态根节点</span></span><br><span class="line">  <span class="title function_">markStaticRoots</span>(root, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记静态节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">markStatic</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  node.<span class="property">static</span> = <span class="title function_">isStatic</span>(node);</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 元素节点递归遍历子节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="title function_">isPlatformReservedTag</span>(node.<span class="property">tag</span>) &amp;&amp;</span><br><span class="line">      node.<span class="property">tag</span> !== <span class="string">&quot;slot&quot;</span> &amp;&amp;</span><br><span class="line">      node.<span class="property">attrsMap</span>[<span class="string">&quot;inline-template&quot;</span>] == <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = node.<span class="property">children</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> child = node.<span class="property">children</span>[i];</span><br><span class="line">      <span class="title function_">markStatic</span>(child);</span><br><span class="line">      <span class="keyword">if</span> (!child.<span class="property">static</span>) &#123;</span><br><span class="line">        <span class="comment">// 若有一个子节点为非静态节点，则当前节点标记为非静态节点</span></span><br><span class="line">        node.<span class="property">static</span> = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不在 children 中的子节点，比如被 v-if 隐藏了</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">ifConditions</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = node.<span class="property">ifConditions</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> block = node.<span class="property">ifConditions</span>[i].<span class="property">block</span>;</span><br><span class="line">        <span class="title function_">markStatic</span>(block);</span><br><span class="line">        <span class="keyword">if</span> (!block.<span class="property">static</span>) &#123;</span><br><span class="line">          node.<span class="property">static</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isStatic</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 包含变量的动态文本节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 不包含变量的纯文本节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 元素节点判断</span></span><br><span class="line">  <span class="keyword">return</span> !!(</span><br><span class="line">    node.<span class="property">pre</span> || <span class="comment">// 使用了v-pre指令，则是静态节点</span></span><br><span class="line">    (!node.<span class="property">hasBindings</span> &amp;&amp; <span class="comment">// 不能使用动态绑定语法，即标签上不能有v-、@、:开头的属性</span></span><br><span class="line">      !node.<span class="property">if</span> &amp;&amp;</span><br><span class="line">      !node.<span class="property">for</span> &amp;&amp; <span class="comment">// 不能使用v-if、v-else、v-for指令</span></span><br><span class="line">      !<span class="title function_">isBuiltInTag</span>(node.<span class="property">tag</span>) &amp;&amp; <span class="comment">// 不能是内置组件，即标签名不能是slot和component</span></span><br><span class="line">      <span class="title function_">isPlatformReservedTag</span>(node.<span class="property">tag</span>) &amp;&amp; <span class="comment">// 标签名必须是平台保留标签，即不能是组件</span></span><br><span class="line">      !<span class="title function_">isDirectChildOfTemplateFor</span>(node) &amp;&amp; <span class="comment">// 当前节点的父节点不能是带有 v-for 的 template 标签</span></span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(node).<span class="title function_">every</span>(isStaticKey)) <span class="comment">// 节点的所有属性的 key 都必须是静态节点才有的 key，注: 静态节点的key是有限的，它只能是type,tag,attrsList,attrsMap,plain,parent,children,attrs之一</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记静态根节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">markStaticRoots</span>(<span class="params">node, isInFor</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">static</span> || node.<span class="property">once</span>) &#123;</span><br><span class="line">      node.<span class="property">staticInFor</span> = isInFor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了使节点有资格作为静态根节点，它应具有不只是静态文本的子节点。 否则，优化的成本将超过收益，最好始终将其更新。</span></span><br><span class="line">    <span class="comment">// 1. 节点本身必须是静态节点</span></span><br><span class="line">    <span class="comment">// 2. 必须拥有子节点 children</span></span><br><span class="line">    <span class="comment">// 3. 子节点不能只是只有一个文本节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      node.<span class="property">static</span> &amp;&amp;</span><br><span class="line">      node.<span class="property">children</span>.<span class="property">length</span> &amp;&amp;</span><br><span class="line">      !(node.<span class="property">children</span>.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; node.<span class="property">children</span>[<span class="number">0</span>].<span class="property">type</span> === <span class="number">3</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      node.<span class="property">staticRoot</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.<span class="property">staticRoot</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点不是静态根节点，那就继续递归遍历它的子节点node.children和node.ifConditions</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">children</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = node.<span class="property">children</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="title function_">markStaticRoots</span>(node.<span class="property">children</span>[i], isInFor || !!node.<span class="property">for</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">ifConditions</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = node.<span class="property">ifConditions</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="title function_">markStaticRoots</span>(node.<span class="property">ifConditions</span>[i].<span class="property">block</span>, isInFor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><blockquote><p>将 AST 转换成渲染函数，生成 render 函数字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">generate</span>(<span class="params">ast, option</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> <span class="title class_">CodegenState</span>(options);</span><br><span class="line">  <span class="keyword">const</span> code = ast ? <span class="title function_">genElement</span>(ast, state) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: state.<span class="property">staticRenderFns</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终生成: 元素节点，文本节点，注释节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genElement</span>(<span class="params">el, state</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genStatic</span>(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">once</span> &amp;&amp; !el.<span class="property">onceProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genOnce</span>(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genFor</span>(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">if</span> &amp;&amp; !el.<span class="property">ifProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genIf</span>(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&quot;template&quot;</span> &amp;&amp; !el.<span class="property">slotTarget</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genChildren</span>(el, state) || <span class="string">&quot;void 0&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&quot;slot&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genSlot</span>(el, state);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    <span class="keyword">let</span> code;</span><br><span class="line">    <span class="keyword">if</span> (el.<span class="property">component</span>) &#123;</span><br><span class="line">      code = <span class="title function_">genComponent</span>(el.<span class="property">component</span>, el, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = el.<span class="property">plain</span> ? <span class="literal">undefined</span> : <span class="title function_">genData</span>(el, state);</span><br><span class="line">      <span class="keyword">const</span> children = el.<span class="property">inlineTemplate</span> ? <span class="literal">null</span> : <span class="title function_">genChildren</span>(el, state, <span class="literal">true</span>);</span><br><span class="line">      code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        data ? <span class="string">`,<span class="subst">$&#123;data&#125;</span>`</span> : <span class="string">&quot;&quot;</span> // data</span></span></span><br><span class="line"><span class="subst"><span class="string">      &#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&quot;&quot;</span> // children</span></span></span><br><span class="line"><span class="subst"><span class="string">      &#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// module transforms</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.<span class="property">transforms</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      code = state.<span class="property">transforms</span>[i](el, code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成元素节点 _c</span></span><br><span class="line"><span class="keyword">const</span> data = el.<span class="property">plain</span> ? <span class="literal">undefined</span> : <span class="title function_">genData</span>(el, state);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = el.<span class="property">inlineTemplate</span> ? <span class="literal">null</span> : <span class="title function_">genChildren</span>(el, state, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 节点的标签名tagName，节点属性data，节点的子节点列表children</span></span><br><span class="line">code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">  data ? <span class="string">`,<span class="subst">$&#123;data&#125;</span>`</span> : <span class="string">&quot;&quot;</span> // data</span></span></span><br><span class="line"><span class="subst"><span class="string">&#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">  children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&quot;&quot;</span> // children</span></span></span><br><span class="line"><span class="subst"><span class="string">&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点属性data</span></span><br><span class="line"><span class="comment">// 逻辑: 在拼接字符串，先给data赋值为一个&#123;，然后判断存在哪些属性数据，就将这些数据拼接到data中，最后再加一个&#125;，最终得到节点全部属性data</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genData</span>(<span class="params">el, state</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> dirs = <span class="title function_">genDirectives</span>(el, state);</span><br><span class="line">  <span class="keyword">if</span> (dirs) data += dirs + <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// key</span></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">key</span>) &#123;</span><br><span class="line">    data += <span class="string">`key:<span class="subst">$&#123;el.key&#125;</span>,`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ref</span></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">ref</span>) &#123;</span><br><span class="line">    data += <span class="string">`ref:<span class="subst">$&#123;el.ref&#125;</span>,`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">refInFor</span>) &#123;</span><br><span class="line">    data += <span class="string">`refInFor:true,`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pre</span></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">pre</span>) &#123;</span><br><span class="line">    data += <span class="string">`pre:true,`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 自定义事件</span></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">events</span>) &#123;</span><br><span class="line">    data += <span class="string">`<span class="subst">$&#123;genHandlers(el.events, <span class="literal">false</span>, state.warn)&#125;</span>,`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 浏览器原生事件</span></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">nativeEvents</span>) &#123;</span><br><span class="line">    data += <span class="string">`<span class="subst">$&#123;genHandlers(el.nativeEvents, <span class="literal">true</span>, state.warn)&#125;</span>,`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 篇幅所限，省略其他情况的判断</span></span><br><span class="line">  data = data.<span class="title function_">replace</span>(<span class="regexp">/,$/</span>, <span class="string">&quot;&quot;</span>) + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子节点列表children</span></span><br><span class="line"><span class="comment">// 遍历AST的children属性中的元素，然后根据元素属性的不同生成不同的VNode创建函数调用字符串</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genChildren</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (children.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;children.map((c) =&gt; genNode(c, state)).join(<span class="string">&quot;,&quot;</span>)&#125;</span>]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">genNode</span>(<span class="params">node, state</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genElement</span>(node, state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">3</span> &amp;&amp; node.<span class="property">isComment</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genComment</span>(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genText</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成文本节点 _v</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genText</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    text.type === <span class="number">2</span></span></span></span><br><span class="line"><span class="subst"><span class="string">      ? text.expression // no need <span class="keyword">for</span> () because already wrapped <span class="keyword">in</span> _s()</span></span></span><br><span class="line"><span class="subst"><span class="string">      : transformSpecialNewlines(<span class="built_in">JSON</span>.stringify(text.text))</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成注释节点 _e</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genComment</span>(<span class="params">comment</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`_e(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(comment.text)&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><ol><li>挂载调用全局实例方法 $mount</li><li>最开始调用的 compileToFunctions 函数内部调用了 compile 函数</li><li>在 compile 函数内部又调用了 baseCompile 函数</li><li>而 baseCompile 函数返回的是代码生成阶段生成好的 render 函数字符串，在 compileToFunctions 函数内部调用 compile 函数就可以拿到生成好的 render 函数字符串</li><li>在 compileToFunction s 函数内部将 render 函数字符串传给 createFunction 函数从而变成真正的 render 函数返回出去</li><li>最后将其赋值给 options.render</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">  <span class="comment">// 如果用户没有手写render函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取模板，先尝试获取内部模板，如果获取不到则获取外部模板</span></span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span>;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">      template,</span><br><span class="line">      &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="variable language_">this</span></span><br><span class="line">    );</span><br><span class="line">    options.<span class="property">render</span> = render;</span><br><span class="line">    options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">  template,</span><br><span class="line">  &#123;</span><br><span class="line">    shouldDecodeNewlines,</span><br><span class="line">    shouldDecodeNewlinesForHref,</span><br><span class="line">    <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">    <span class="attr">comments</span>: options.<span class="property">comments</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="variable language_">this</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; compile, compileToFunctions &#125; = <span class="title function_">createCompiler</span>(baseOptions);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompilerCreator</span>(<span class="params">baseCompile</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">createCompiler</span>(<span class="params">baseOptions</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCompiler</span>(<span class="params">baseOptions</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">compile</span>(<span class="params">template, options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> compiled = <span class="title function_">baseCompile</span>(template, finalOptions);</span><br><span class="line">    compiled.<span class="property">errors</span> = errors;</span><br><span class="line">    compiled.<span class="property">tips</span> = tips;</span><br><span class="line">    <span class="keyword">return</span> compiled;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    compile,</span><br><span class="line">    <span class="attr">compileToFunctions</span>: <span class="title function_">createCompileToFunctionFn</span>(compile),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompileToFunctionFn</span>(<span class="params">compile</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">compileToFunctions</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// compile</span></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> compiled = <span class="title function_">compile</span>(template, options);</span><br><span class="line">    res.<span class="property">render</span> = <span class="title function_">createFunction</span>(compiled.<span class="property">render</span>, fnGenErrors);</span><br><span class="line">    res.<span class="property">staticRenderFns</span> = compiled.<span class="property">staticRenderFns</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createFunction</span>(code, fnGenErrors);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createFunction</span>(<span class="params">code, errors</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(code);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errors.<span class="title function_">push</span>(&#123; err, code &#125;);</span><br><span class="line">    <span class="keyword">return</span> noop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 Diff</title>
      <link href="/articles/vue/domDiff/"/>
      <url>/articles/vue/domDiff/</url>
      
        <content type="html"><![CDATA[<h2 id="Vdom"><a href="#Vdom" class="headerlink" title="Vdom"></a>Vdom</h2><h3 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">tag</span>?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">data</span>?: <span class="title class_">VNodeData</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">children</span>?: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span></span><br><span class="line"><span class="params">    <span class="attr">text</span>?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">elm</span>?: <span class="title class_">Node</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">context</span>?: <span class="title class_">Component</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">componentOptions</span>?: <span class="title class_">VNodeComponentOptions</span>,</span></span><br><span class="line"><span class="params">    <span class="attr">asyncFactory</span>?: <span class="title class_">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag; <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> =</span><br><span class="line">      data; <span class="comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children; <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text; <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm; <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ns</span> = <span class="literal">undefined</span>; <span class="comment">/*当前节点的名字空间*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context; <span class="comment">/*当前组件节点对应的Vue实例*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnContext</span> = <span class="literal">undefined</span>; <span class="comment">/*函数式组件对应的Vue实例*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnOptions</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnScopeId</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span>; <span class="comment">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentOptions</span> = componentOptions; <span class="comment">/*组件的option选项*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentInstance</span> = <span class="literal">undefined</span>; <span class="comment">/*当前节点对应的组件的实例*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span>; <span class="comment">/*当前节点的父节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">raw</span> =</span><br><span class="line">      <span class="literal">false</span>; <span class="comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isStatic</span> = <span class="literal">false</span>; <span class="comment">/*静态节点标志*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRootInsert</span> = <span class="literal">true</span>; <span class="comment">/*是否作为跟节点插入*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isComment</span> = <span class="literal">false</span>; <span class="comment">/*是否为注释节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCloned</span> = <span class="literal">false</span>; <span class="comment">/*是否为克隆节点*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOnce</span> = <span class="literal">false</span>; <span class="comment">/*是否有v-once指令*/</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncFactory</span> = asyncFactory;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncMeta</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isAsyncPlaceholder</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">child</span>(): <span class="title class_">Component</span> | <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">componentInstance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><h4 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h4><blockquote><p>createEmptyVNode + isComment</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createEmptyVNode</span> = (<span class="params"><span class="attr">text</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">VNode</span>();</span><br><span class="line">  node.<span class="property">text</span> = text;</span><br><span class="line">  node.<span class="property">isComment</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h4><blockquote><p>createTextVNode</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextVNode</span>(<span class="params"><span class="attr">val</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title class_">String</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h4><blockquote><p>tag attributes</p></blockquote><h4 id="组件节点"><a href="#组件节点" class="headerlink" title="组件节点"></a>组件节点</h4><blockquote><p>组件节点除了有元素节点具有的属性之外，它还有两个特有的属性</p><ul><li>componentOptions: 组件的 option 选项，如组件的 props 等</li><li>componentInstance: 当前组件节点对应的 Vue 实例</li></ul></blockquote><h4 id="函数式组件节点"><a href="#函数式组件节点" class="headerlink" title="函数式组件节点"></a>函数式组件节点</h4><blockquote><p>函数式组件节点相较于组件节点，它又有两个特有的属性</p><ul><li>fnContext: 函数式组件对应的 Vue 实例</li><li>fnOptions: 组件的 option 选项</li></ul></blockquote><h4 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h4><blockquote><p>cloneVNode + isCloned</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cloneVNode</span>(<span class="params"><span class="attr">vnode</span>: <span class="title class_">VNode</span></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cloned = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    vnode.<span class="property">tag</span>,</span><br><span class="line">    vnode.<span class="property">data</span>,</span><br><span class="line">    vnode.<span class="property">children</span>,</span><br><span class="line">    vnode.<span class="property">text</span>,</span><br><span class="line">    vnode.<span class="property">elm</span>,</span><br><span class="line">    vnode.<span class="property">context</span>,</span><br><span class="line">    vnode.<span class="property">componentOptions</span>,</span><br><span class="line">    vnode.<span class="property">asyncFactory</span></span><br><span class="line">  );</span><br><span class="line">  cloned.<span class="property">ns</span> = vnode.<span class="property">ns</span>;</span><br><span class="line">  cloned.<span class="property">isStatic</span> = vnode.<span class="property">isStatic</span>;</span><br><span class="line">  cloned.<span class="property">key</span> = vnode.<span class="property">key</span>;</span><br><span class="line">  cloned.<span class="property">isComment</span> = vnode.<span class="property">isComment</span>;</span><br><span class="line">  cloned.<span class="property">fnContext</span> = vnode.<span class="property">fnContext</span>;</span><br><span class="line">  cloned.<span class="property">fnOptions</span> = vnode.<span class="property">fnOptions</span>;</span><br><span class="line">  cloned.<span class="property">fnScopeId</span> = vnode.<span class="property">fnScopeId</span>;</span><br><span class="line">  cloned.<span class="property">asyncMeta</span> = vnode.<span class="property">asyncMeta</span>;</span><br><span class="line">  cloned.<span class="property">isCloned</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dom-Diff"><a href="#Dom-Diff" class="headerlink" title="Dom-Diff"></a>Dom-Diff</h2><blockquote><p>patch 过程，主要有三个过程，创建节点，删除节点，更新节点</p></blockquote><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><blockquote><p>新的 VNode 中有而旧的 oldVNode 中没有，就在旧的 oldVNode 中创建。判断三类节点</p><ul><li>元素节点: 判断该 VNode 节点是否有 tag 标签 + createElement</li><li>注释节点: isComment + createComment</li><li>文本节点: createTextNode</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElm</span>(<span class="params">vnode, parentElm, refElm</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = vnode.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> children = vnode.<span class="property">children</span>;</span><br><span class="line">  <span class="keyword">const</span> tag = vnode.<span class="property">tag</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(tag)) &#123;</span><br><span class="line">    vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createElement</span>(tag, vnode); <span class="comment">// 创建元素节点</span></span><br><span class="line">    <span class="title function_">createChildren</span>(vnode, children, insertedVnodeQueue); <span class="comment">// 创建元素节点的子节点</span></span><br><span class="line">    <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm); <span class="comment">// 插入到DOM中</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isComment</span>)) &#123;</span><br><span class="line">    vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createComment</span>(vnode.<span class="property">text</span>); <span class="comment">// 创建注释节点</span></span><br><span class="line">    <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm); <span class="comment">// 插入到DOM中</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createTextNode</span>(vnode.<span class="property">text</span>); <span class="comment">// 创建文本节点</span></span><br><span class="line">    <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm); <span class="comment">// 插入到DOM中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><blockquote><p>新的 VNode 中没有而旧的 oldVNode 中有，就从旧的 oldVNode 中删除</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeNode</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> parent = nodeOps.<span class="title function_">parentNode</span>(el); <span class="comment">// 获取父节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(parent)) &#123;</span><br><span class="line">    nodeOps.<span class="title function_">removeChild</span>(parent, el); <span class="comment">// 调用父节点的removeChild方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><blockquote><p>新的 VNode 和旧的 oldVNode 中都有，就以新的 VNode 为准，更新旧的 oldVNode。分为几种情况</p></blockquote><p>VNode / oldVNode 均为静态节点</p><blockquote><p>isStatic，跳过，无需处理</p></blockquote><p>VNode 为文本节点</p><p><img src="/images/vue/diff_1.png" alt=""></p><p>VNode 为元素节点</p><p><img src="/images/vue/diff_2.png" alt=""></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) &#123;</span><br><span class="line">  <span class="comment">// vnode与oldVnode是否完全一样？若是，退出程序</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> elm = (vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vnode与oldVnode是否都是静态节点？若是，退出程序</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="title function_">isTrue</span>(vnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">    <span class="title function_">isTrue</span>(oldVnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">    vnode.<span class="property">key</span> === oldVnode.<span class="property">key</span> &amp;&amp;</span><br><span class="line">    (<span class="title function_">isTrue</span>(vnode.<span class="property">isCloned</span>) || <span class="title function_">isTrue</span>(vnode.<span class="property">isOnce</span>))</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span>;</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.<span class="property">children</span>;</span><br><span class="line">  <span class="comment">// vnode有text属性？若没有: </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    <span class="comment">// vnode的子节点与oldVnode的子节点是否都存在？</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">// 若都存在，判断子节点是否相同，不同则更新子节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch)</span><br><span class="line">        <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若只有vnode的子节点存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 判断oldVnode是否有文本？</span></span><br><span class="line"><span class="comment">       * 若没有，则把vnode的子节点添加到真实DOM中</span></span><br><span class="line"><span class="comment">       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若只有oldnode的子节点存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 清空DOM中的子节点</span></span><br><span class="line">      <span class="title function_">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若vnode和oldnode都没有子节点，但是oldnode中有文本</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) &#123;</span><br><span class="line">      <span class="comment">// 清空oldnode文本</span></span><br><span class="line">      nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若有，vnode的text属性与oldVnode的text属性是否相同？</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">    <span class="comment">// 若不相同: 则用vnode的text替换真实DOM的文本</span></span><br><span class="line">    nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h4><blockquote><p>双层循环遍历 newChildren 和 oldChildren: 每循环外层 newChildren 数组里的一个子节点，就去内层 oldChildren 数组里找看有没有与之相同的子节点。分为几种情况</p></blockquote><h5 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h5><blockquote><p>newChildren 里有，而 oldChildren 里没有: 创建节点，创建好之后再把它插入到 DOM 中合适的位置</p></blockquote><div class="tip warning"><p>合适的位置是所有未处理节点之前，而并非所有已处理节点之后</p></div><blockquote><p>下图节点顺序插入出错</p></blockquote><p><img src="/images/vue/diff_3.png" alt=""></p><h5 id="删除子节点"><a href="#删除子节点" class="headerlink" title="删除子节点"></a>删除子节点</h5><blockquote><p>newChildren 里没有，而 oldChildren 里有</p></blockquote><h5 id="更新子节点-1"><a href="#更新子节点-1" class="headerlink" title="更新子节点"></a>更新子节点</h5><blockquote><p>newChildren 里有，且 oldChildren 里有，且位置相同</p></blockquote><h5 id="移动子节点"><a href="#移动子节点" class="headerlink" title="移动子节点"></a>移动子节点</h5><blockquote><p>newChildren 里有，且 oldChildren 里有，但位置不同: 以 newChildren 里子节点的位置为基准，调整 oldChildren 里该节点的位置，使之与在 newChildren 里的位置相同</p><ul><li>以 newChildren 里子节点的位置为基准，调整 oldChildren 里该节点的位置</li></ul></blockquote><div class="tip warning"><p>所有未处理节点之前就是要移动的目的位置</p></div><h3 id="diff-对比过程"><a href="#diff-对比过程" class="headerlink" title="diff 对比过程"></a>diff 对比过程</h3><blockquote><p>对比顺序: 4 指针双向遍历</p><ul><li>newStartIdx: newChildren 数组里开始位置的下标</li><li>newEndIdx: newChildren 数组里结束位置的下标</li><li>oldStartIdx: oldChildren 数组里开始位置的下标</li><li>oldEndIdx: oldChildren 数组里结束位置的下标</li><li>在循环的时候，每处理一个节点，newStartIdx 和 oldStartIdx 往后 +1 (只会加)，newEndIdx 和 oldEndIdx 往前 -1 (只会减)，当开始位置大于结束位置时，表示所有节点都已经遍历过了</li></ul></blockquote><h4 id="优化前策略"><a href="#优化前策略" class="headerlink" title="优化前策略"></a>优化前策略</h4><ol><li>如果 oldStartVnode 不存在，则直接跳过，将 oldStartIdx 加 1，比对下一个</li><li>如果 oldEndVnode 不存在，则直接跳过，将 oldEndIdx 减 1，比对前一个</li><li>如果新前与旧前节点相同，就把两个节点进行 patch 更新，同时 oldStartIdx 和 newStartIdx 都加 1，后移一个位置</li><li>如果新后与旧后节点相同，就把两个节点进行 patch 更新，同时 oldEndIdx 和 newEndIdx 都减 1，前移一个位置</li><li>如果新后与旧前节点相同，先把两个节点进行 patch 更新，然后把旧前节点移动到 oldChilren 中所有未处理节点之后，最后把 oldStartIdx 加 1，后移一个位置，newEndIdx 减 1，前移一个位置</li><li>如果新前与旧后节点相同，先把两个节点进行 patch 更新，然后把旧后节点移动到 oldChilren 中所有未处理节点之前，最后把 newStartIdx 加 1，后移一个位置，oldEndIdx 减 1，前移一个位置</li><li>如果不属于以上四种情况，就进行常规的循环比对 patch</li><li>如果在循环中，oldStartIdx 大于 oldEndIdx 了，表示 oldChildren 比 newChildren 先循环完毕，那么 newChildren 里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到 DOM 中</li><li>如果在循环中，newStartIdx 大于 newEndIdx 了，表示 newChildren 比 oldChildren 先循环完毕，那么 oldChildren 里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</li></ol><h4 id="优化后策略"><a href="#优化后策略" class="headerlink" title="优化后策略"></a>优化后策略</h4><ol><li>新前比旧前: 相同则进入更新节点流程，不同则进入下一步</li><li>新后比旧后: 相同则进入更新节点流程，不同则进入下一步</li><li>新后比旧前: 相同则进入更新节点流程，更新完后再将旧前移动到 oldVNode 数组中所有未处理节点之后，不同则进入下一步</li><li>新前比旧后: 相同则进入更新节点流程，更新完后再将旧后移动到 oldVNode 数组中所有未处理节点之前，不同则通过之前的循环方式查找</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环更新子节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parentElm,</span></span><br><span class="line"><span class="params">  oldCh,</span></span><br><span class="line"><span class="params">  newCh,</span></span><br><span class="line"><span class="params">  insertedVnodeQueue,</span></span><br><span class="line"><span class="params">  removeOnly</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>; <span class="comment">// oldChildren开始索引</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// oldChildren结束索引</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]; <span class="comment">// oldChildren中所有未处理节点中的第一个</span></span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]; <span class="comment">// oldChildren中所有未处理节点中的最后一个</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span>; <span class="comment">// newChildren开始索引</span></span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// newChildren结束索引</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]; <span class="comment">// newChildren中所有未处理节点中的第一个</span></span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]; <span class="comment">// newChildren中所有未处理节点中的最后一个</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transitions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">checkDuplicateKeys</span>(newCh);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以&quot;新前&quot;、&quot;新后&quot;、&quot;旧前&quot;、&quot;旧后&quot;的方式开始比对节点</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// 如果oldStartVnode不存在，则直接跳过，比对下一个</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 如果新前与旧前节点相同，就把两个节点进行patch更新</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 如果新后与旧后节点相同，就把两个节点进行patch更新</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="comment">// 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">      canMove &amp;&amp;</span><br><span class="line">        nodeOps.<span class="title function_">insertBefore</span>(</span><br><span class="line">          parentElm,</span><br><span class="line">          oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">          nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>)</span><br><span class="line">        );</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="comment">// 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">      canMove &amp;&amp;</span><br><span class="line">        nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不属于以上四种情况，就进行常规的循环比对patch</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx))</span><br><span class="line">        oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">        : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      <span class="comment">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123;</span><br><span class="line">        <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 新增节点并插入到合适位置</span></span><br><span class="line">        <span class="title function_">createElm</span>(</span><br><span class="line">          newStartVnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          parentElm,</span><br><span class="line">          oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          newCh,</span><br><span class="line">          newStartIdx</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span></span><br><span class="line">        vnodeToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="comment">// 如果两个节点相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="comment">// 调用patchVnode更新节点</span></span><br><span class="line">          <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue);</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">          <span class="comment">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span></span><br><span class="line">          canMove &amp;&amp;</span><br><span class="line">            nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="title function_">createElm</span>(</span><br><span class="line">            newStartVnode,</span><br><span class="line">            insertedVnodeQueue,</span><br><span class="line">            parentElm,</span><br><span class="line">            oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            newCh,</span><br><span class="line">            newStartIdx</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果oldChildren比newChildren先循环完毕，</span></span><br><span class="line"><span class="comment">     * 那么newChildren里面剩余的节点都是需要新增的节点，</span></span><br><span class="line"><span class="comment">     * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    refElm = <span class="title function_">isUndef</span>(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span>;</span><br><span class="line">    <span class="title function_">addVnodes</span>(</span><br><span class="line">      parentElm,</span><br><span class="line">      refElm,</span><br><span class="line">      newCh,</span><br><span class="line">      newStartIdx,</span><br><span class="line">      newEndIdx,</span><br><span class="line">      insertedVnodeQueue</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果newChildren比oldChildren先循环完毕，</span></span><br><span class="line"><span class="comment">     * 那么oldChildren里面剩余的节点都是需要删除的节点，</span></span><br><span class="line"><span class="comment">     * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码解析 双向绑定</title>
      <link href="/articles/vue/control/"/>
      <url>/articles/vue/control/</url>
      
        <content type="html"><![CDATA[<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><blockquote><p>vue2.x <a href="https://github.com/vuejs/vue">源码</a></p></blockquote><ol><li>Data 通过 observer 转换成了 getter/setter 的形式来追踪变化</li><li>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到依赖中</li><li>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖 (即 Watcher) 发送通知</li><li>Watcher 接收到通知后，向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等</li></ol><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><blockquote><p>监测数据，给数据打上响应式标记: <code>__ob__</code><br>在 getter 中收集依赖，在 setter 中通知依赖更新</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAument;</span><br><span class="line">      <span class="title function_">augment</span>(value, arrayMethods, arrayKeys);</span><br><span class="line">      <span class="comment">// 深度侦测</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">observeArray</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.<span class="property">lengtgh</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&quot;push&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;unshift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;splice&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>,</span><br><span class="line">  <span class="string">&quot;reverse&quot;</span>,</span><br><span class="line">];</span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> origianl = arrayProto[method];</span><br><span class="line">  <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = origianl.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span>;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;shift&quot;</span>:</span><br><span class="line">        inserted = <span class="literal">false</span>; <span class="comment">// 如果是push或shift方法，传参即为新增的元素</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;splice&quot;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>); <span class="comment">// 如果是splice方法，传入参数列表中下标为2的即为新增的元素</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted); <span class="comment">// 调用observe函数将新增元素转化为响应式</span></span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasProto = <span class="string">&quot;__proto__&quot;</span> <span class="keyword">in</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(arrayMethods);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">protoAugment</span>(<span class="params">target, src</span>) &#123;</span><br><span class="line">  target.<span class="property">__proto__</span> = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyAument</span>(<span class="params">target, src, keys</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    <span class="title function_">def</span>(target, key, src[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">def</span>(<span class="params">obj, key, val, enumerable = <span class="literal">true</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">value</span>: val,</span><br><span class="line">    enumerable,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value) || value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> ob;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(value, <span class="string">&quot;__ob__&quot;</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    ob = value.<span class="property">__ob__</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observer</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  <span class="keyword">let</span> childOb = <span class="title function_">observe</span>(val);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.<span class="property">dep</span>.<span class="title function_">depend</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><blockquote><p>依赖收集器</p><ul><li>渲染页面时碰到插值表达式，v-bind 等需要数据的地方，会实例化一个 watcher</li><li>实例化 watcher 就会对依赖的数据求值，从而触发 getter，数据的 getter 函数就会添加依赖自己的 watcher，从而完成依赖收集</li><li>可以理解为 watcher 在收集依赖，而代码的实现方式是在数据中存储依赖自己的 watcher</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// window.target即为 watcher</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">addSub</span>(<span class="variable language_">window</span>.<span class="property">target</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.<span class="title function_">indexOf</span>(item);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><blockquote><p>逻辑生成依赖，并添加到 Dep 中</p><p>Watcher 先把自己设置到全局唯一的指定位置 (window.target)，然后读取数据。触发这个数据的 getter。接着，在getter 中就会从全局唯一的那个位置读取当前正在读取数据的 Watcher，并把这个 watcher 收集到 Dep 中去。收集好之后，当数据发生变化时，会向 Dep 中的每个 Watcher 发送通知</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, expOrFn, cb, options, isRenderWatcher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">computed</span> = !!options.<span class="property">computed</span>; <span class="comment">// 是否为计算属性</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">computed</span>; <span class="comment">// 标志计算属性的返回值是否有变化，用于缓存，true代表重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在模板编译函数中的实例化watcher的，getter中取不到这个实例。解决方法也很简单，将watcher实例放到全局，比如放到window.target上。</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不能写window.target = new Watcher()。因为执行到getter的时候，实例化watcher还没有完成，所以window.target还是undefined</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span>;</span><br><span class="line">    <span class="comment">// 获取一下被依赖的数据, 触发该数据上面的getter, 从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个watcher收集到Dep中去</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm);</span><br><span class="line">    <span class="comment">// 处理 watch 监听中的 deep 属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">      <span class="title function_">traverse</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">target</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">value</span>, oldValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dep</span>.<span class="property">subs</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用getAndInvoke去对比计算属性的返回值是否发生了变化，如果真的发生变化，则执行回调，通知那些读取计算属性的watcher重新执行渲染逻辑</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAndInvoke</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">dep</span>.<span class="title function_">notify</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算属性取缓存还是重新计算逻辑</span></span><br><span class="line">  <span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dirty</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dep</span> &amp;&amp; <span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dep</span>.<span class="title function_">depend</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getAndInvoke</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="variable language_">this</span>.<span class="property">value</span> ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      <span class="title function_">isObject</span>(value) ||</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">handleError</span>(e, <span class="variable language_">this</span>.<span class="property">vm</span>, <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于取消 watch</span></span><br><span class="line">  <span class="title function_">teardown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">removeSub</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h2><div class="tip cogs"><p>只要触发 getter 就会收集依赖吗</p></div><blockquote><p>不会</p><ul><li>在 Dep 的 depend 方法中，只有 Dep.target 为真时才会添加依赖。比如在派发更新时会触发 watcher 的 update 方法，该方法也会触发 parsePath 来取值，但是此时的 Dep.target 为 null，不会添加依赖</li><li>仔细观察可以发现，只有 watcher 的 get 方法中会调用 pushTarget(this) 来对 Dep.target 赋值，其他时候 Dep.target 都是 null，而 get 方法只会在实例化 watcher 的时候调用</li><li>因此，在实现中，一个 watcher 的依赖在其实例化时就已经确定了，之后任何读取值的操作均不会增加依赖</li></ul></blockquote><div class="tip cogs"><p>依赖嵌套的对象属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> <span class="title class_">Watcher</span>(obj, <span class="string">&quot;b.m.n&quot;</span>, <span class="function">(<span class="params">val, oldVal</span>) =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`obj.b.m.n 从 <span class="subst">$&#123;oldVal&#125;</span>(oldVal) 变成了 <span class="subst">$&#123;val&#125;</span>(newVal)`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>w2 会依赖 obj.b.m.n，但是 w2 会依赖 obj.b, obj.b.m 吗？或者说，obj.b 和 obj.b.m，它们闭包中保存的 dep 中会有 w2 吗</p></div><blockquote><p>会</p><ul><li>如果让 obj.b = null，那么很显然 w2 的回调函数应该被触发，这就说明 w2 会依赖中间层级的对象属性</li><li>代码层面: new Watcher() 时，会调用 watcher 的 get 方法，将 Dep.target 设置为 w2，get 方法会调用 parsePath 来取值</li></ul><ol><li>局部变量 obj 为对象 obj，读取 obj.b 的值，触发 getter，触发 dep.depend() (该 dep 是 obj.b 的闭包中的 dep)，Dep.target 存在，添加依赖</li><li>局部变量 obj 为 obj.b，读取 obj.b.m 的值，触发 getter，触发 dep.depend() (该 dep 是 obj.b.m 的闭包中的 dep)，Dep.target 存在，添加依赖</li><li>局部变量 obj 为对象 obj.b.m，读取 obj.b.m.n 的值，触发 getter，触发 dep.depend() (该 dep 是 obj.b.m.n 的闭包中的 dep)，Dep.target 存在，添加依赖</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 模块化</title>
      <link href="/articles/engineering/jsModule/"/>
      <url>/articles/engineering/jsModule/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/engineering/jModule_1.png" alt=""></p><h2 id="演进历程"><a href="#演进历程" class="headerlink" title="演进历程"></a>演进历程</h2><h3 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h3><blockquote><p>面临问题</p><ul><li>需要在页面中加载不同的 JS: 动画、组件、格式化</li><li>多种 js 文件会被分在不同的文件中</li><li>不同的文件又被同一个模板所引用</li></ul><p>手动拆分各文件</p></blockquote><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote><p>利用函数的块级作用域 - 隔离区</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iifeModule = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increase</span> = (<span class="params"></span>) =&gt; ++count;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  <span class="title function_">increase</span>();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><div class="tip cogs"><p>问题 1: 独立模块本身的额外依赖，如何优化</p></div><blockquote><p>依赖其他模块的传参型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iifeModule = (<span class="function">(<span class="params">dependencyModule1, dependencyModule2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increase</span> = (<span class="params"></span>) =&gt; ++count;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  <span class="title function_">increase</span>();</span><br><span class="line">&#125;)(dependencyModule1, dependencyModule2);</span><br></pre></td></tr></table></figure><div class="tip cogs"><p>问题 2: jquery 或者其他很多开源框架的模块加载方案</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iifeModule = (<span class="function">(<span class="params">dependencyModule1, dependencyModule2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increase</span> = (<span class="params"></span>) =&gt; ++count;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  <span class="title function_">increase</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increase,</span><br><span class="line">    reset,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(dependencyModule1, dependencyModule2);</span><br><span class="line">iifeModule.<span class="title function_">increate</span>();</span><br><span class="line">iifeModule.<span class="title function_">increate</span>();</span><br></pre></td></tr></table></figure><div class="tip success"><p>总结: 揭示模式 revealing =&gt; 上层无需了解底层实现，仅关注抽象 =&gt; 框架</p></div><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h4><ul><li>通过 require 去引入外部模块</li><li>通过 module + exports 去对外暴露接口</li><li>最开始 CJS 中，<code>this</code>，<code>exports</code>，<code>module.exports</code> 是同一个东西，最后导出 module.exports</li><li>对模块的浅拷贝</li><li>同步运行，不适合前端</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span> = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">e</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">f</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终结果: this: &#123; a: 1, b: 2, f: 6&#125;  exports: &#123;c: 3, e: 5&#125;  module.exports: &#123; d: 4 &#125;</span></span><br><span class="line"><span class="comment">// 最终导出: &#123; d: 4 &#125;;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> dependencyModule1 = <span class="built_in">require</span>(<span class="string">&quot;./dependencyModule1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> dependencyModule2 = <span class="built_in">require</span>(<span class="string">&quot;./dependencyModule2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increase</span> = (<span class="params"></span>) =&gt; ++count;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"><span class="title function_">increase</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">increase</span> = increase;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">reset</span> = increase;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  increase,</span><br><span class="line">  reset,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exe</span></span><br><span class="line"><span class="keyword">const</span> &#123; increase, reset &#125; = <span class="built_in">require</span>(<span class="string">&quot;./main.js&quot;</span>)(</span><br><span class="line">  <span class="comment">// 复合使用</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params">thisValue, <span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependencyModule1 = <span class="built_in">require</span>(<span class="string">&quot;./dependencyModule1&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> dependencyModule2 = <span class="built_in">require</span>(<span class="string">&quot;./dependencyModule2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑……</span></span><br><span class="line">  &#125;</span><br><span class="line">).<span class="title function_">call</span>(thisValue, <span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些开源项目为何要把全局、指针以及框架本身引用作为参数</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="variable language_">window</span>, $, <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _show = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&quot;#app&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;hi test&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">webShow</span> = _show;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, jQuery);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻断思路</span></span><br><span class="line"><span class="comment">// window - 1. 全局作用域转化成局部作用域，提升执行效率 2. 编译时优化</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">c</span>) &#123;&#125;)(<span class="variable language_">window</span>); <span class="comment">// window会被优化成c</span></span><br><span class="line"><span class="comment">// jquery - 1. 独立定制复写和挂载 2.防止全局串扰</span></span><br><span class="line"><span class="comment">// undefined - 防止重写</span></span><br></pre></td></tr></table></figure><div class="tip success"><p>优点: CommonJs 率先在服务端实现了，从框架层面解决了依赖、全局变量污染的问题<br>缺点: 针对了服务端的解决方案。异步拉取依赖处理不是很完美</p></div><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><blockquote><p>通过异步加载 + 允许制定回调函数<br>经典实现框架: <code>require.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define定义模块</span></span><br><span class="line"><span class="title function_">define</span>(id, [depends], callback);</span><br><span class="line"><span class="comment">// require进行加载</span></span><br><span class="line"><span class="built_in">require</span>([<span class="variable language_">module</span>], callback);</span><br><span class="line"></span><br><span class="line"><span class="title function_">define</span>(<span class="string">&quot;amdModule&quot;</span>, [<span class="string">&quot;dependencyModule1&quot;</span>, <span class="string">&quot;dependencyModule2&quot;</span>], <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  dependencyModule1,</span></span></span><br><span class="line"><span class="params"><span class="function">  dependencyModule2</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 业务逻辑……</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;amdModule&quot;</span>], <span class="function">(<span class="params">amdModule</span>) =&gt;</span> &#123;</span><br><span class="line">  amdModule.<span class="title function_">increase</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div class="tip cogs"><p>问题 2: 如何在 AMDModule 中兼容已有代码</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">&quot;amdModule&quot;</span>, [], <span class="function">(<span class="params"><span class="built_in">require</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dependencyModule1 = <span class="built_in">require</span>(<span class="string">&quot;./dependencyModule1&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> dependencyModule2 = <span class="built_in">require</span>(<span class="string">&quot;./dependencyModule2&quot;</span>);</span><br><span class="line">  <span class="comment">// 业务逻辑……</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>手写兼容 CJS &amp; AMD</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断关键step1. object还是function step2. exports？ step3. define</span></span><br><span class="line">(<span class="title function_">define</span>(<span class="string">&#x27;amdModule&#x27;</span>), [], <span class="function">(<span class="params"><span class="built_in">require</span>, <span class="keyword">export</span>, <span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dependencyModule1 = <span class="built_in">require</span>(<span class="string">&#x27;./dependencyModule1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> dependencyModule2 = <span class="built_in">require</span>(<span class="string">&#x27;./dependencyModule2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increase</span> = (<span class="params"></span>) =&gt; ++count;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span>.<span class="property">increase</span> = <span class="title function_">increase</span>();</span><br><span class="line">&#125;)(</span><br><span class="line">  <span class="comment">// 目标: 一次性区分CJS还是AMD</span></span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&quot;object&quot;</span></span><br><span class="line">  &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">  &amp;&amp; <span class="keyword">typeof</span> define !== <span class="string">&quot;function&quot;</span></span><br><span class="line">    ? <span class="comment">// 是CJS</span></span><br><span class="line">      <span class="function"><span class="params">factory</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span>)</span><br><span class="line">    : <span class="comment">// AMD</span></span><br><span class="line">      define</span><br><span class="line">)</span><br></pre></td></tr></table></figure><div class="tip success"><p>优点: 适合在浏览器中加载异步模块的方案<br>缺点: 引入成本；回调无法做到绝对的异步</p></div><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><blockquote><p>按需加载，异步运行<br>主要应用框架:  <code>sea.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">&quot;module&quot;</span>, <span class="function">(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> $ = <span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>);</span><br><span class="line">  <span class="comment">// jquery相关逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dependencyModule1 = <span class="built_in">require</span>(<span class="string">&quot;./dependencyModule1&quot;</span>);</span><br><span class="line">  <span class="comment">// dependencyModule1相关逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div class="tip success"><p>优点: 按需加载，依赖就近<br>缺点: 依赖打包，加载逻辑存在于每个模块中，扩大了模块体积，同时功能上依赖编译</p></div><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><blockquote><p>import &amp; export</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入区域</span></span><br><span class="line"><span class="keyword">import</span> dependencyModule1 <span class="keyword">from</span> <span class="string">&quot;./dependencyModule1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> dependencyModule2 <span class="keyword">from</span> <span class="string">&quot;./dependencyModule2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现业务逻辑……</span></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increase</span> = (<span class="params"></span>) =&gt; ++count;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  increase,</span><br><span class="line">  reset,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="tip cogs"><p>问题 1: 如何按需、动态加载模块:<br>es11 新特性 ==&gt; Dynamic Module Imports</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./esModule.js&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">dynamicModule</span>) =&gt;</span> &#123;</span><br><span class="line">  dynamicModule.<span class="title function_">increase</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在条件语句中动态导入</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&quot;./esModule.js&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">dynamicModule</span>) =&gt;</span> &#123;</span><br><span class="line">    dynamicModule.<span class="title function_">increase</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数内部动态导入</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable language_">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&quot;./esModule.js&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用导入的模块</span></span><br><span class="line">    dynamicModule.<span class="title function_">increase</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;模块加载失败:&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip success"><p>优点: 通过一种最终统一各端的形态，整合了 js 模块化的通用方案<br>局限性: 本质上还是运行时的依赖分析</p></div><h4 id="ES6-vs-CommonJS"><a href="#ES6-vs-CommonJS" class="headerlink" title="ES6 vs CommonJS"></a>ES6 vs CommonJS</h4><ol><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li><li>CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段</li><li>CommonJS 是对模块的浅拷贝，ES6 Module 是对模块的引入，即 ES6 Module 只存只读，不能改变其值，具体点就是指针指向不能变，类似 const 。commonjs 的 this 指向当前模块，ES6 的 this 指向 undefined</li><li>import 的接口是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错</li></ol><h2 id="新方案-前端工程化"><a href="#新方案-前端工程化" class="headerlink" title="新方案: 前端工程化"></a>新方案: 前端工程化</h2><blockquote><p>上述方案存在的根本问题: <code>运行时</code>进行依赖分析<br>对此提出的解决方案: <code>编译时</code>进行依赖分析</p></blockquote><div class="tip cogs"><p>实现一个编译时依赖处理的思路</p></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 给构建工具一个标识位</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">require</span>.<span class="title function_">config</span>(__FRAME_CONFIG__);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">require</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 业务逻辑</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">define</span>(<span class="string">&#x27;a&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> c = <span class="built_in">require</span>(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="工程化实现"><a href="#工程化实现" class="headerlink" title="工程化实现"></a>工程化实现</h3><h4 id="扫描依赖关系表"><a href="#扫描依赖关系表" class="headerlink" title="扫描依赖关系表"></a>扫描依赖关系表</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">a</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">  <span class="attr">b</span>: [<span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">  <span class="attr">e</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据依赖关系重制模板"><a href="#根据依赖关系重制模板" class="headerlink" title="根据依赖关系重制模板"></a>根据依赖关系重制模板</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 构建工具生成数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&quot;deps&quot;</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">a</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">b</span>: [<span class="string">&#x27;d&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">e</span>: []</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">require</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 业务逻辑</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">define</span>(<span class="string">&#x27;a&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> c = <span class="built_in">require</span>(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="模块化解决方案处理"><a href="#模块化解决方案处理" class="headerlink" title="模块化解决方案处理"></a>模块化解决方案处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span>.<span class="property">run</span> = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div class="tip success"><p>优点: 构建时生成配置，运行时去运行，最终转化成可执行的依赖处理，并可以拓展</p></div><h3 id="完全体"><a href="#完全体" class="headerlink" title="完全体"></a>完全体</h3><blockquote><p>webpack 为核心的前端工程化 + mvvm 框架的组件化 + 设计模式</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 简介</title>
      <link href="/articles/vue/introduce/"/>
      <url>/articles/vue/introduce/</url>
      
        <content type="html"><![CDATA[<h3 id="父子组件生命周期"><a href="#父子组件生命周期" class="headerlink" title="父子组件生命周期"></a>父子组件生命周期</h3><blockquote><p>父子组件的生命周期是一个嵌套的过程</p></blockquote><ol><li>渲染的过程</li></ol><ul><li>父 beforeCreate-&gt; 父 created-&gt; 父 beforeMount-&gt; 子 beforeCreate-&gt; 子 created-&gt; 子 beforeMount-&gt; 子 mounted-&gt; 父 mounted</li></ul><ol><li>子组件更新过程</li></ol><ul><li>父 beforeUpdate-&gt; 子 beforeUpdate-&gt; 子 updated-&gt; 父 updated</li></ul><ol><li>父组件更新过程</li></ol><ul><li>父 beforeUpdate-&gt; 父 updated</li></ul><ol><li>销毁过程</li></ol><ul><li>父 beforeDestroy-&gt; 子 beforeDestroy-&gt; 子 destroyed-&gt; 父 destroyed</li></ul><h3 id="computed-watch"><a href="#computed-watch" class="headerlink" title="computed / watch"></a>computed / watch</h3><blockquote><p>相同点</p></blockquote><ul><li>基于 vue 的依赖收集机制</li><li>都是被依赖的变化触发，进行改变进而进行处理计算</li></ul><blockquote><p>不同点</p></blockquote><ol><li>入和出</li></ol><ul><li>computed: 多入单出，多个值变化，组成一个值的变化</li><li>watch: 单入多出，单个值的变化，进而影响一系列的状态变更</li></ul><ol><li>性能</li></ol><ul><li>computed: 自动 diff 依赖，若依赖没有变化，会改从缓存中读取当前计算值</li><li>watch: 无论监听值变化与否，都会执行回调</li></ul><ol><li>写法</li></ol><ul><li>computed: 必须有 return 返回值</li><li>watch: 不一定</li></ul><ol><li>时机上</li></ol><ul><li>computed: 从首次生成赋值，就开始计算运行了</li><li>watch: 首次不会运行，除非设置 immediate: true</li></ul><h3 id="v-for-v-if"><a href="#v-for-v-if" class="headerlink" title="v-for / v-if"></a>v-for / v-if</h3><ul><li>vue2: v-for &gt; v-if 先循环 再判断</li><li>vue3: 反过来</li></ul><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><ol><li>模板编译原理: template =&gt; dom<br>template =&gt; 正则匹配语法 —— 生成 AST: 静态 + 动态 =&gt; 转换 AST 为可执行方法 =&gt; render() =&gt; dom</li><li>dom diff</li></ol><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">search</span>: &#123;</span><br><span class="line">    <span class="attr">update</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div v-search&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><blockquote><p>应用: 抽离公共逻辑 (逻辑相同，但是模板不一样)<br>合并策略</p><ul><li>data 冲突时，以组件主体为优先</li><li>生命周期钩子会先后执行，先 mixin 后主体</li><li>递归合并，递归合并优先级仍以主体优先</li></ul></blockquote><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><blockquote><p>应用: 拓展独立逻辑<br>合并策略: 与 mixin 相同</p><ul><li>合并优先级上 mixin &gt; extends</li><li>回调优先级 extends &gt; mixin</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node</title>
      <link href="/articles/engineering/node/"/>
      <url>/articles/engineering/node/</url>
      
        <content type="html"><![CDATA[<h2 id="node-简介"><a href="#node-简介" class="headerlink" title="node 简介"></a>node 简介</h2><blockquote><p>node.js 是⼀个 JS 的服务端运⾏环境，基于 V8，是在 JS 语⾔规范的基础上，封装了⼀些服务端的 runtime，能够简单实现⾮常多的业务功能。在 2009 年 (第一版 npm 被创建) 诞生之初是为了实现高性能的 web 服务器，再后来 node.js 慢慢演化为了一门服务端 “语言”<br>commonjs 是一个 规范，node.js 是 cjs 的实现</p></blockquote><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="node-作用"><a href="#node-作用" class="headerlink" title="node 作用"></a>node 作用</h4><ul><li>跨平台开发:  PC  web  H5  RN  Weex</li><li>后端开发:  API, RPC</li><li>前端开发:  前端工具链</li><li>工具开发: 脚本、脚手架、命令行。</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li>压缩: UglifyJS、JSMin</li><li>管理: npm、yarn、bower</li><li>模块系统: Commonjs, ESM</li><li>模块构建: Babel、Browserify、Webpack、Gulp、Grunt</li><li>生成器: yeoman、slush、CRA、CLI</li></ul><h4 id="node-缺陷"><a href="#node-缺陷" class="headerlink" title="node 缺陷"></a>node 缺陷</h4><ul><li>单线程很脆弱，但是可以通过 cluster / pm2 多核并发实现负载均衡</li><li>node 对 MongoDB、Mysql、redis 的支持比较好，对 neo4j、tigerGraph 的支持比较差</li><li>安全问题</li></ul><h4 id="vs-浏览器"><a href="#vs-浏览器" class="headerlink" title="vs 浏览器"></a>vs 浏览器</h4><ul><li>Node 环境中是没有 <code>DOM</code>, <code>BOM</code>, 同样的，浏览器中也没有 <code>fs</code>, <code>path</code> 这些模块。</li><li>事件循环<ul><li>node 的事件循环</li><li>浏览器:  微任务、宏任务、raf、 render、 requestIdleCallback</li></ul></li><li><code>cjs</code> 和 <code>esm</code><ul><li>Node.js 使用 CommonJS 模块系统，而在浏览器中我们开始看到正在实施的 ESM 标准。</li></ul></li></ul><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p><img src="/images/engineering/node_1.png" alt=""></p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><h4 id="npm-install-工作流程"><a href="#npm-install-工作流程" class="headerlink" title="npm install 工作流程"></a>npm install 工作流程</h4><p><img src="/images/engineering/node_2.png" alt=""></p><h4 id="npm-CI"><a href="#npm-CI" class="headerlink" title="npm CI"></a>npm CI</h4><blockquote><p>Continuous Integration (持续集成)，npm 从 5.7.0 版本开始引入的一个命令，专门为自动化的持续集成环境设计。和 install 的不同点</p><ul><li>必须要有 package-lock.json 文件</li><li>且下载完全依赖该文件</li><li>会删除 node_modules</li><li>如果和 package.json 冲突，则直接报错</li><li>只能一次性安装</li><li>永不改写 package.json 和 package-lock.json 文件</li></ul></blockquote><h4 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h4><ul><li>dependencies: 项目依赖 (lodash (debounce, deepMerge))</li><li>devDependencies: 开发依赖 (webpack, rollup, jest)</li><li>peerDependencies: 同版本依赖。比如 vue 组件库，如果说连 vue 都没，那这个项目没有意义</li><li>bundledDependencies: 捆绑依赖</li><li>optionalDependencies: 可选依赖</li></ul><h4 id="npm、cnpm、yarn、pnmp、npx"><a href="#npm、cnpm、yarn、pnmp、npx" class="headerlink" title="npm、cnpm、yarn、pnmp、npx"></a>npm、cnpm、yarn、pnmp、npx</h4><ol><li><p>npm: 包管理器，方便开发者分享和下载开源包。经历了许多重大版本的更新，各方面已经和 yarn 在同一水平</p></li><li><p>npx: npm@5.2的产物，方便运行本地命令</p></li></ol><ul><li>npx 会帮你执行依赖包里的二进制文件: 不需要在 scripts 中声明命令</li><li>npx 原理: 运行的时候，会到 node_modules/.bin 路径和环境变量$PATH里面，检查命令是否存在。由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</li><li>避免全局安装模块: npx 将 create-react-app 下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 create-react-app。</li><li>—no-install: 如果想让 npx 强制使用本地模块，不下载远程模块，可以使用—no-install 参数。如果本地不存在该模块，就会报错。</li><li>—ignore-existing: 如果忽略本地的同名模块，强制安装使用远程模块，可以使用—ignore-existing 参数。</li><li>使用不同版本的 node: $ npx node@0.12.8 -v，原理是从 npm 下载这个版本的 node，使用后再删掉。某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。</li><li>-p: 用于指定 npx 所要安装的模块。$ npx -p node@0.12.8 node -v，先指定安装node@0.12.8，然后再执行 node -v 命令。</li><li>-c: 如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。-c 参数可以将所有命令都用 npx 解释</li></ul><ol><li><p>cnpm: 方便中国开发者下载依赖包而诞生的下载器</p></li><li><p>yarn: 解决了 npm@5 之前的一些让人诟病的问题，同时拥有一些其它的优点。例如离线安装、失败自动重试安装和并行下载等</p></li><li><p>pnpm: 通过连接的方式，让多个项目的依赖公用同一个包，大大节省了磁盘空间</p></li></ol><ul><li>pnpm 运行起来非常的快，超过了 npm 和 yarn</li><li>pnpm 采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件， yarn 的最大的性能弱点之一</li><li>使用链接并不容易，会带来一堆问题需要考虑</li><li>pnpm 继承了 yarn 的所有优点，包括离线模式和确定性安装</li></ul><h2 id="node-API"><a href="#node-API" class="headerlink" title="node API"></a>node API</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote><p>Buffer 是一种计算机中数据流结构。计算机中是以二进制的方式，进行数据存取的。而 js 在一开始，没有文件读写能力的，就要借助 Buffer 来实现一些缓冲区的内容。<br>Buffer 一般用于表示固定长度的缓冲区序列。浏览器中使用 File new Blob。</p></blockquote><ol><li>Buffer 的声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">5</span>); <span class="comment">// 单位是字节 00000000</span></span><br><span class="line"><span class="comment">// string ==&gt; buffer</span></span><br><span class="line"><span class="keyword">let</span> buf2 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&quot;麓一&quot;</span>); <span class="comment">// node 中一般编码使用的是 utf-8, 所以一个汉字，是3个字节。</span></span><br><span class="line"><span class="keyword">let</span> buf3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">0xe9</span>, <span class="number">0xba</span>, <span class="number">0x93</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf1); <span class="comment">// -&gt; &lt;Buffer 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf2); <span class="comment">// -&gt; &lt;Buffer e9 ba 93 e4 b8 80&gt;</span></span><br><span class="line"><span class="comment">// buffer ==&gt; string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf3.<span class="title function_">toString</span>()); <span class="comment">// -&gt; 麓</span></span><br><span class="line"><span class="comment">// copy</span></span><br><span class="line"><span class="comment">// 第一个0, 表示从0这个位置开始拷贝</span></span><br><span class="line"><span class="comment">// 第二和第三个数字，表示拷贝从几到几的长度。</span></span><br><span class="line">buf2.<span class="title function_">copy</span>(buf1, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// concat</span></span><br><span class="line"><span class="keyword">let</span> bigBuffer = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([buf1, buf2], <span class="number">6</span>);</span><br><span class="line"><span class="comment">// slice</span></span><br><span class="line">buf1.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 类型判断</span></span><br><span class="line"><span class="title class_">Buffer</span>.<span class="title function_">isBuffer</span>(buf);</span><br></pre></td></tr></table></figure><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><blockquote><p>防止淹没可用内存: Buffer 不适合大文件的读取，适合比较小的文件，对于大文件，需要使用流</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> res = fs.<span class="title function_">createReadStream</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../package.json&quot;</span>), &#123;</span><br><span class="line">  <span class="attr">flags</span>: <span class="string">&quot;r&quot;</span>,</span><br><span class="line">  <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">highWaterMark</span>: <span class="number">5</span>, <span class="comment">// 默认是 64K</span></span><br><span class="line">  <span class="attr">autoClose</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">emitClose</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="keyword">function</span> (<span class="params">fd</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fd&quot;</span>, fd);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">  arr.<span class="title function_">push</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>, <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(arr).<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="comment">// 子进程，开子进程。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: cluster &#125; = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cpu_num = os.<span class="title function_">cpus</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.<span class="property">isMaster</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpu_num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    cluster.<span class="title function_">fork</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  http</span><br><span class="line">    .<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&quot;childPid&quot;</span>, process.<span class="property">pid</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><h3 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h3><blockquote><p>messageBump: 宏任务 -&gt; 微任务 -&gt; RAF -&gt; Layout -&gt; RequestIdleCallback</p></blockquote><h3 id="Node-的事件循环"><a href="#Node-的事件循环" class="headerlink" title="Node 的事件循环"></a>Node 的事件循环</h3><blockquote><p>基于 Libuv。Libuv 是一个高性能的、事件驱动的 I/O 库，为 Node.js 提供了跨平台的异步 I/O 能力，使之能够高效地处理大量并发请求</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">             同步的代码</span><br><span class="line">                 |</span><br><span class="line">     process.nextTick / promise...</span><br><span class="line">                 |</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │ 定时器:  setTimeout / setInterval</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|    process.nextTick / promise...</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │ 执行延迟到下一个循环迭代的I/O回调</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|    process.nextTick / promise...</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │ 系统内部使用</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">|    process.nextTick / promise...</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">|    process.nextTick / promise...</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │ setImmediate</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|    process.nextTick / promise...</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │ 关闭回调函数</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><ul><li>定时器: 本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</li><li>待定回调: 执行延迟到下一个循环迭代的 I/O 回调。</li><li>idle, prepare: 仅系统内部使用。</li><li>轮询: 检索新的 I/O 事件; 执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li><li>检测: setImmediate() 回调函数在这里执行。</li><li>关闭的回调函数: 一些关闭的回调函数，如: socket.on(‘close’, …)。</li></ul><blockquote><p>总结<br><code>Node.js: microtask 在事件循环的各个阶段之间执行</code> &gt; <code>浏览器: microtask 在事件循环的 macrotask 执行完之后执行</code></p></blockquote><ol><li>node 的初始化</li></ol><ul><li>初始化 node 环境</li><li>执行输入代码</li><li>执行 process.nextTick 回调</li><li>执行微任务队列</li></ul><ol><li>进入 event-loop</li></ol><ul><li>进入 timers 阶段(执行 setTimeout 和 SetInterval)<ul><li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerid 升序进行</li><li>检查是否有 process.nextTick 任务，如果有全部执行</li><li>检查是否有 microtask，有全部执行</li><li>退出该阶段</li></ul></li><li>进入 IO 阶段<ul><li>检查是否有 pending 的 io 回调，如果有，执行回调，如果没有，退出该阶段</li><li>检查是否有 process.nextTick()任务，如果有，全部执行</li><li>检查是否有 MicroTask，如果有全部执行</li><li>退出该阶段</li></ul></li></ul><ol><li>进入 idle，prepare 阶段</li><li>进入 poll 阶段</li></ol><ul><li>首先检查是否存在尚未完成的回调，存在，则<ol><li>如果 有可用回调，</li></ol><ul><li>那么执行</li><li>检查是否有 process.nextTick()回调，有全部执行</li><li>检查是否有 MicroTask，如果有全部执行</li><li>退出该阶段</li></ul><ol><li>如果没有可用回调</li></ol><ul><li>检查是否有 immediate 回调，如果有退出 poll 阶段，如果没有，阻塞在此阶段，等待新的事件通知</li></ul></li><li>如果不存在尚未完成的回调，退出 poll 阶段</li></ul><ol><li>进入 check 阶段</li></ol><ul><li>如果有 immediate 回调，执行所有回调</li><li>检查是否有 process.nextTick()回调，如果有，全部执行</li><li>检查是否有 MicroTask，如果有全部执行</li><li>退出该阶段</li></ul><ol><li>进入 closing 阶段</li></ol><ul><li>如果有 immediate 回调，则执行所有 immediate 回调。</li><li>检查是否有 process.nextTick 回调，如果有，全部执行。</li><li>检查是否有 microtaks，如果有，全部执行。</li><li>退出 closing 阶段</li></ul><ol><li>检查是否有活跃的 handles(定时器、io 等事件)</li></ol><ul><li>如果有，继续下一轮循环</li><li>没有则结束事件循环，退出程序</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 started&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async end&quot;</span>); <span class="comment">// m 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start.&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout0&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nextTick&quot;</span>); <span class="comment">// m 0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise.then&quot;</span>); <span class="comment">// m2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start.</span></span><br><span class="line"><span class="comment">// async1 started</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// async end</span></span><br><span class="line"><span class="comment">// promise.then</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout0</span></span><br><span class="line"><span class="comment">// setImmediate</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br></pre></td></tr></table></figure><h2 id="Node-框架"><a href="#Node-框架" class="headerlink" title="Node 框架"></a>Node 框架</h2><h3 id="express-koa"><a href="#express-koa" class="headerlink" title="express / koa"></a>express / koa</h3><blockquote><p>express 是一个基于 node.js 平台的一个灵活的 web 应用开发框架，connect 中间件，内置了视图、static 等部分<br>koa2 相对来说更新一些，也是由 express 原班人马打造的框架，通过中间件来实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./public&quot;</span>)));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server is running in 3000&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">api</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timing...&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;querying start 1&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">api</span>();</span><br><span class="line">  ctx.<span class="property">result</span> = result;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;querying end 1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;querying start 2&quot;</span>, ctx.<span class="property">result</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;querying end 2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;querying start 3&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;querying end 3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = (<span class="params">ctx</span>) =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(main);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3008</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// querying start 1</span></span><br><span class="line"><span class="comment">// timing...</span></span><br><span class="line"><span class="comment">// querying start 2 100</span></span><br><span class="line"><span class="comment">// querying start 3</span></span><br><span class="line"><span class="comment">// querying end 3</span></span><br><span class="line"><span class="comment">// querying end 2</span></span><br><span class="line"><span class="comment">// querying end 1</span></span><br></pre></td></tr></table></figure><h3 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">num</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;starting num ...&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>(ctx * <span class="number">10</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ending num ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">discount</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;starting discount ...&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>(ctx * <span class="number">0.8</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ending discount ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">express</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;starting express ...&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>(ctx + <span class="number">12</span>); <span class="comment">// 不包邮，12运费</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ending express ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compose实现.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="comment">// ctx 初始化时，是我们放进去的 150 元，我们要不断地计算这个值。</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="keyword">function</span> (<span class="params">i, ctx</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> fn;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; args.<span class="property">length</span>) fn = args[i]; <span class="comment">// fn 就是我每一个函数。</span></span><br><span class="line">      <span class="keyword">if</span> (i === args.<span class="property">length</span>) &#123;</span><br><span class="line">        result = ctx;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(ctx, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, ++i));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">dispatch</span>(i, ctx);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sell = <span class="title function_">compose</span>([num, discount, express]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sell</span>(<span class="number">150</span>)); <span class="comment">// 1212</span></span><br><span class="line"><span class="comment">// starting num ...</span></span><br><span class="line"><span class="comment">// starting discount ...</span></span><br><span class="line"><span class="comment">// starting express ...</span></span><br><span class="line"><span class="comment">// ending express ...</span></span><br><span class="line"><span class="comment">// ending discount ...</span></span><br><span class="line"><span class="comment">// ending num ...</span></span><br></pre></td></tr></table></figure><h3 id="koa-框架原理"><a href="#koa-框架原理" class="headerlink" title="koa 框架原理"></a>koa 框架原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⼊⼝⽅法</span></span><br><span class="line"><span class="title function_">listen</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="title function_">debug</span>(<span class="string">&#x27;listen&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="variable language_">this</span>.<span class="title function_">callback</span>());</span><br><span class="line">    <span class="keyword">return</span> server.<span class="title function_">listen</span>(...args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (res, req) =&gt; &#123;  &#125;</span></span><br><span class="line"><span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 处理中间件，等一下看compose和this.middleware</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="title function_">compose</span>(<span class="variable language_">this</span>.<span class="property">middleware</span>);</span><br><span class="line"><span class="comment">// 错误处理，listenerCount是EventEmitter类的函数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">listenerCount</span>(<span class="string">&#x27;error&#x27;</span>)) <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onerror</span>);</span><br><span class="line"><span class="comment">// 传递给createServer的就是下面这个函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleRequest</span> = (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="variable language_">this</span>.<span class="title function_">createContext</span>(req, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">handleRequest</span>(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.<span class="property">res</span>;</span><br><span class="line">    res.<span class="property">statusCode</span> = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onerror</span> = err =&gt; ctx.<span class="title function_">onerror</span>(err);</span><br><span class="line">    <span class="comment">// 这里等到response再看</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleResponse</span> = (<span class="params"></span>) =&gt; <span class="title function_">respond</span>(ctx);</span><br><span class="line">    <span class="comment">// 给请求结束增加一个回调，这个onerror是ctx的onerror，不是app的onerror</span></span><br><span class="line">    <span class="title function_">onFinished</span>(res, onerror);</span><br><span class="line">    <span class="comment">// 等一下看这个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fnMiddleware</span>(ctx).<span class="title function_">then</span>(handleResponse).<span class="title function_">catch</span>(onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加中间件⽅法</span></span><br><span class="line"><span class="title function_">use</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">middleware</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createContext</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line"><span class="comment">// 每次请求，ctx都是一个新的对象</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property">context</span>);</span><br><span class="line">    <span class="keyword">const</span> request = context.<span class="property">request</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property">request</span>);</span><br><span class="line">    <span class="keyword">const</span> response = context.<span class="property">response</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">    <span class="comment">// 原生的req和res</span></span><br><span class="line">    context.<span class="property">app</span> = request.<span class="property">app</span> = response.<span class="property">app</span> = <span class="variable language_">this</span>;</span><br><span class="line">    context.<span class="property">req</span> = request.<span class="property">req</span> = response.<span class="property">req</span> = req;</span><br><span class="line">    context.<span class="property">res</span> = request.<span class="property">res</span> = response.<span class="property">res</span> = res;</span><br><span class="line">    <span class="comment">// koa生成的request和response</span></span><br><span class="line">    request.<span class="property">ctx</span> = response.<span class="property">ctx</span> = context;</span><br><span class="line">    request.<span class="property">response</span> = response;</span><br><span class="line">    response.<span class="property">request</span> = request;</span><br><span class="line">    context.<span class="property">originalUrl</span> = request.<span class="property">originalUrl</span> = req.<span class="property">url</span>;</span><br><span class="line">    context.<span class="property">state</span> = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="koa-compose"><a href="#koa-compose" class="headerlink" title="koa-compose"></a>koa-compose</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expose compositor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = compose;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compose `middleware` returning</span></span><br><span class="line"><span class="comment"> * a fully valid middleware comprised</span></span><br><span class="line"><span class="comment"> * of all those which are passed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">middleware</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Function</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">middleware</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(middleware))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Middleware stack must be an array!&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Middleware must be composed of functions!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">context</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">i</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;next() called multiple times&quot;</span>));</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next;</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="koa-常用中间件"><a href="#koa-常用中间件" class="headerlink" title="koa 常用中间件"></a>koa 常用中间件</h3><ul><li>koa2-cors</li><li>koa-static</li><li>koa-bodyparser</li></ul><h2 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a>BFF</h2><blockquote><p><a href="https://samnewman.io/patterns/architectural/bff/?fileGuid=xxQTRXtVcqtHK6j8">Backends For Frontends</a></p><p>在后端普遍采用微服务的情况下，作为适配层，更好的为前端服务。<br>优势: 降低沟通成本，提升用户体验<br>问题: 资源浪费，增加架构复杂度，管理复杂</p></blockquote><h2 id="Sequelize"><a href="#Sequelize" class="headerlink" title="Sequelize"></a>Sequelize</h2><blockquote><p>Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, MariaDB, SQLite 以及 Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 预读和延迟加载,读取复制等功能</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/articles/engineering/webpack/"/>
      <url>/articles/engineering/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a>案例引入</h2><ul><li>基于 Module Federation 的一些微前端方案</li><li>基于 webpack-dev-server 的一些 热更新</li><li>基于 tree-Shaking, code spliting, terser / minify / uglify 的一些压缩方案</li><li>lazy import 的一些懒加载方案</li><li>Js, Json，二进制的解析、生成能力</li></ul><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><blockquote><p>bundle: 由 webpack 打包出来的文件<br>chunk: 指 webpack 在进行模块依赖分析的时候，代码分割出来的代码块<br>module: 开发中的单个模块</p></blockquote><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>从文件系统中读取代码</p></blockquote><ul><li>entry: 用于定义项目的入口，Webpack 会从这些入口文件中找到所有文件 (SFC 单文件组件)</li><li>context: 定义项目的执行上下文</li></ul><h3 id="模块递归处理"><a href="#模块递归处理" class="headerlink" title="模块递归处理"></a>模块递归处理</h3><blockquote><p>调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；</p><ul><li>resolve: 用于配置模块路径的解析规则，可以帮助 webpack 更精确，更高效的找到指定模块；</li><li>module: 配置模块加载规则，loaders</li><li>externals: 声明资源之间的关系。用 externals 声明的外部资源， webpack 会进行忽略。</li><li>chunk: 代码块，一个 chunk 由多个模块组合而成，用于代码合并与分割</li></ul></blockquote><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><blockquote><p>所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 chunk 集合</p><ul><li>optimization: 用于控制如何优化产物包体积，scope hoisting、code spliting、代码混淆、代码压缩</li><li>target: 用于配置编译产物的目标环境， web,、node、electron</li><li>mode: dev prod 环境下的声明</li><li>output: 输出，产出物</li></ul></blockquote><h3 id="额外的开发效率工具"><a href="#额外的开发效率工具" class="headerlink" title="额外的开发效率工具"></a>额外的开发效率工具</h3><ul><li>devtools 决定 sourcemap 的生成规则</li><li>DevServer HMR: 内置 node 服务，websocket 通知，再根据新 hash 值请求更新内容</li><li>watch 模式，用于配置持续监听文件变化</li><li>cache  webpack 5 以后，缓存编译信息</li></ul><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>请求资源时，先通过 jsonp 的方式去加载 js 模块所对应的文件，会保存在一个全局的 webpackJsonp 中</li><li>加载回来后在浏览器中执行此 JS 脚本，将请求过来的模块定义合并到 main.js 中的 modules 中去: webpackJsonp.push 的的值，两个参数分别为异步加载的文件中存放的需要安装的模块对应的 id 和异步加载的文件中存放的需要安装的模块列表。</li><li>合并完后，去加载这个模块</li><li>拿到该模块导出的内容</li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>代码分割（Code Splitting）: Webpack 允许将代码拆分为多个块（chunks），并在需要时动态加载这些块。意味着可以将应用程序划分为更小的模块，只在需要时加载，而不是一次性加载整个应用程序。这可以减少初始加载时间，提高性能。</li><li>动态导入语法: Webpack 提供了动态导入语法，例如使用 import() 函数或 require.ensure() 函数来异步加载模块。这些函数返回一个 Promise，可以使用 then 方法处理加载成功的回调，或使用 catch 方法处理加载失败的回调。</li><li>按需加载: 通过异步加载模块，可以根据需要加载特定的模块，而不是将所有模块打包到同一个文件中。这样可以减少初始加载时间，并在用户需要时动态加载额外的模块。</li><li>代码并行加载: Webpack 可以同时加载多个模块，利用浏览器的并行加载能力，从而加快加载速度。这对于大型应用程序和复杂的依赖关系特别有用。</li></ol><h2 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h2><blockquote><p>webpack 某个阶段的解析器，对不同文件进行解析<br>Webpack 选择了 compose 方式，函数组合是函数式编程中非常重要的思想。在 compose 中是采用 reduceRight，<code>从右往左执行</code></p></blockquote><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel loader"></a>babel loader</h3><h3 id="css-loaders"><a href="#css-loaders" class="headerlink" title="css loaders"></a>css loaders</h3><blockquote><p>原生 webpack 不能识别 css 语法，直接导入 .css 文件会失败，为此， 在 webpack 中，处理 css 文件，通常要使用到</p></blockquote><h4 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h4><blockquote><p>将 css 翻译成类似 module.exports = <code>$&#123;css&#125;</code> 的 JS 代码，使 CSS 文件可以和 JS 一样作为资源。同时可以提供 sourcemap、css-in-module</p></blockquote><h4 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h4><blockquote><p>在具体的产物中，注入 runtime 代码。让这些代码将 CSS 注入到页面中。</p></blockquote><h4 id="less-sass-loader"><a href="#less-sass-loader" class="headerlink" title="less/sass-loader"></a>less/sass-loader</h4><blockquote><p>通过原本的 less / sass 的解析器解析，最后生成 css.</p></blockquote><h4 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h4><blockquote><p>CSS 界的 babel.</p></blockquote><h3 id="file-loaders"><a href="#file-loaders" class="headerlink" title="file loaders"></a>file loaders</h3><h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><blockquote><p>经过 file-loader 处理后，原始图片会被重命名并复制到产物文件夹，同时在代码里插入图片 URL</p></blockquote><h4 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h4><blockquote><p>对于小于阈值的图像，直接 base 64 编码</p></blockquote><h4 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h4><blockquote><p>都不处理，直接拷贝，一般 svg 会用他。</p></blockquote><h3 id="手写-loader"><a href="#手写-loader" class="headerlink" title="手写 loader"></a>手写 loader</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// less-loader</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&quot;less&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>();</span><br><span class="line">  less.<span class="title function_">render</span>(source, &#123; <span class="attr">sourceMap</span>: &#123;&#125; &#125;, <span class="keyword">function</span> (<span class="params">err, res</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; css, map &#125; = res;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, css, map);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// style-loader</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">source, map</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> style = <span class="string">`</span></span><br><span class="line"><span class="string">    const style = document.createElement(&#x27;style&#x27;);</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(source)&#125;</span>;</span></span><br><span class="line"><span class="string">    document.head.appendChild(style);</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> style;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><blockquote><p>在打包过程中不同周期内加入一些功能</p></blockquote><h3 id="常见的-plugins"><a href="#常见的-plugins" class="headerlink" title="常见的 plugins"></a>常见的 plugins</h3><blockquote><ul><li>terser-webpack-plugin 压缩 js</li><li>pnp-webpack-plugin Yarn Plug Play 插件</li><li>html-webpack-plugin 自动生成带有入口文件的 index.html 模板注入</li><li>webpack-manifest-plugin 生产资产的显示清单</li><li>mini-css-extract-plugin</li><li>define-plugin</li><li>friendly-errors-webpack-plugin 友好的错误日志。</li></ul></blockquote><h3 id="webpack-运行原理"><a href="#webpack-运行原理" class="headerlink" title="webpack 运行原理"></a>webpack 运行原理</h3><ol><li>初始化参数: 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译: 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法，初始化一个 compilation 对象，执行 compilation 中的 build 方法开始执行编译，触发 compiler 对象的 done 钩子，完成编译</li><li>确定入口: 根据配置中的 entry 找出所有的入口文件</li><li>编译模块: 从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译: 在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>输出资源: 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成: 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol><p><img src="/images/engineering/webpack_1.png" alt=""></p><h3 id="compiler-compilation"><a href="#compiler-compilation" class="headerlink" title="compiler / compilation"></a>compiler / compilation</h3><h4 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h4><blockquote><p>该对象包含了 webpack 的所有配置信息，包括 entry、output、module、plugins 等，compiler 对象会在启动 webpack 时，一次性地初始化创建，它是全局唯一的，可以简单理解为 webpack 的实例</p></blockquote><h4 id="compilation"><a href="#compilation" class="headerlink" title="compilation"></a>compilation</h4><blockquote><p>该对象代表一次资源的构建，通过一系列 API 可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行 webpack 时，每当检测到一个文件变化，就会创建一个新的 compilation 对象，所以 compilation 对象也是一次性的，只能用于当前的编译</p><ul><li><code>compilation.modules</code>: 解析后的所有模块</li><li><code>compilation.chunks</code>: 所有的代码分块 chunk</li><li><code>compilation.assets</code>: 本次打包生成的所有文件</li><li><code>compilation.hookscompilation</code>:  所有的钩子</li></ul><p>总结: <code>compiler</code> 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束），而 <code>compilation</code> 只是代表了一次性的编译过程，如果是 watch 模式，每次监听到文件变化，都会产生一个新的 compilation，所以 compilation 代表一次资源的构建，会多次被创建，而 compiler 只会被创建一次</p></blockquote><h3 id="插件实现原理"><a href="#插件实现原理" class="headerlink" title="插件实现原理"></a>插件实现原理</h3><blockquote><p>通过 tapable 链式调用<br>通过 compiler 对象的 hooks 属性访问到 emit 钩子，再通过 tap 方法注册一个钩子函数，这个方法接收两个参数: 插件名称，callback(compilation: 上下文，其中 assets 属性为即将写入输出目录的资源文件信息， for in 去遍历 assets ，得到键名，即每个文件的名称，然后通过遍历的值对象中的 source 方法获取文件内容，处理过后暴露一个 source 方法用来返回新的内容。另外还需要再暴露一个 size 方法，用来返回内容大小)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="title class_">SyncHook</span>,</span><br><span class="line">  <span class="title class_">SyncBailHook</span>,</span><br><span class="line">  <span class="title class_">SyncWaterfallHook</span>,</span><br><span class="line">  <span class="title class_">SyncLoopHook</span>,</span><br><span class="line">  <span class="title class_">AsyncHook</span>,</span><br><span class="line">  <span class="title class_">AsyncParallelHook</span>,</span><br><span class="line">  <span class="title class_">AsyncParallelBailHook</span>,</span><br><span class="line">  <span class="title class_">AsyncSeriesBailHook</span>,</span><br><span class="line">  <span class="title class_">AsyncSeriesHook</span>,</span><br><span class="line">  <span class="title class_">AsyncSeriesLoopHook</span>,</span><br><span class="line">  <span class="title class_">AsyncSeriesWaterfallHook</span>,</span><br><span class="line">  <span class="title class_">Hook</span>,</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&quot;flag1&quot;</span>, <span class="function">(<span class="params">arg1, arg2, arg3</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flag1:::&quot;</span>, arg1, arg2, arg3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&quot;flag2&quot;</span>, <span class="function">(<span class="params">arg1, arg2, arg3</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flag2:::&quot;</span>, arg1, arg2, arg3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  hook.<span class="title function_">call</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpack = &#123;</span><br><span class="line">  <span class="attr">compiler</span>: &#123;</span><br><span class="line">    <span class="attr">hooks</span>: &#123;</span><br><span class="line">      <span class="attr">make</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(),</span><br><span class="line">      <span class="attr">seal</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(),</span><br><span class="line">      <span class="attr">compile</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(),</span><br><span class="line"></span><br><span class="line">      <span class="attr">emit</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(),</span><br><span class="line">      <span class="attr">afterEmit</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">compilation</span>: &#123;</span><br><span class="line">    <span class="attr">hooks</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&quot;flag1&quot;</span>, <span class="function">(<span class="params">stats, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flag1:::&quot;</span>, stats, callback);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&quot;APlugin&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="依赖标记阶段"><a href="#依赖标记阶段" class="headerlink" title="依赖标记阶段"></a>依赖标记阶段</h4><blockquote><p>Make 阶段: 收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中</p></blockquote><ol><li>将模块的所有 ESM 导出语句转换为 Dependency 对象，并记录到 module 对象的 dependencies 集合，转换规则:  - 具名导出转换为 HarmonyExportSpecifierDependency 对象 - default 导出转换为 HarmonyExportExpressionDependency 对象</li><li>所有模块都编译完毕后，触发 compilation.hooks.finishModules 钩⼦，开始执行 FlagDependencyExportsPlugin 插件回调</li><li>FlagDependencyExportsPlugin 插件从 entry 开始读取 ModuleGraph 中存储的模块信息，遍历所有 module 对象</li><li>遍历 module 对象的 dependencies 数组，找到所有 HarmonyExportXXXDependency 类型的依赖对象，将其转换为 ExportInfo 对象，并记录到 ModuleGraph 体系中</li></ol><blockquote><p>Seal 阶段: 遍历 ModuleGraph 标记模块导出变量有没有被使⽤</p></blockquote><ol><li>触发 compilation.hooks.optimizeDependencies 钩⼦，开始执⾏ FlagDependencyUsagePlugin 插件逻辑</li><li>在 FlagDependencyUsagePlugin 插件中，从 entry 开始逐步遍历 ModuleGraph 存储的所有 module 对象</li><li>遍历 module 对象对应的 exportInfo 数组</li><li>.为每⼀个 exportInfo 对象执⾏ compilation.getDependencyReferencedExports ⽅法，确定其对应的 dependency 对象有否被其它模块使⽤</li><li>被任意模块使⽤到的导出值，调⽤ exportInfo.setUsedConditionally ⽅法将其标记为已被使⽤</li><li>exportInfo.setUsedConditionally 内部修改 exportInfo._usedInRuntime 属性，记录该导出被如何使⽤</li><li>结束</li></ol><blockquote><p>产物生成: 若变量没有被其他模块使用时，则删除对应的导出语句</p></blockquote><ol><li>打包阶段，调⽤ HarmonyExportXXXDependency.Template.apply ⽅法⽣成代码</li><li>在 apply ⽅法内，读取 ModuleGraph 中存储的 exportsInfo 信息，判断哪些导出值被使⽤，哪些未被使⽤</li><li>对已经被使⽤及未被使⽤的导出值，分别创建对应的 HarmonyExportInitFragment 对象，保存到 initFragments 数组</li><li>遍历 initFragments 数组，⽣成最终结果 (<code>__webpack_exports__</code>对象)</li></ol><div class="tip warning"><p>标记阶段会将 import &amp; export 标记为 3 类</p></div><blockquote><ul><li>所有 import 标记为 <code>/* harmony import */</code></li><li>被使用过的 export 标记为 <code>/* harm export([type])*/</code> ，其中 [type] 和 webpack 内部相关，可能是 binding，immutable 等等</li><li>未被使用过的 import 标记为 <code>/* unused harmony export [FuncName] */</code>，其中 [FuncName] 为 export 的方法名称</li></ul></blockquote><h4 id="删除阶段"><a href="#删除阶段" class="headerlink" title="删除阶段"></a>删除阶段</h4><blockquote><p>使用 Terser 删除没有用到的导出语句 (dead code)</p></blockquote><h3 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h3><ul><li>在 FlagDependencyExportsPlugin 插件中根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 exportsInfo 中</li><li>在 FlagDependencyUsagePlugin 插件中收集模块的导出值的使用情况，并记录到 exportInfo._usedInRuntime 集合中</li><li>在 HarmonyExportXXXDependency.Template.apply 方法中根据导出值的使用情况生成不同的导出语句</li><li>使用 DCE 工具删除 Dead Code，实现完整的树摇效果</li></ul><h3 id="启用-tree-shaking"><a href="#启用-tree-shaking" class="headerlink" title="启用 tree-shaking"></a>启用 tree-shaking</h3><blockquote><p>需满足三个条件</p></blockquote><ol><li>使用 ESM 规范编写模块，在引入模块时应局部引入，才可以触发 tree shaking 机制</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入所有内容（不会触发 tree-shaking）</span></span><br><span class="line"><span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入命名导出 (会触发 tree-shaking)</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接导入项目 (会触发 tree-shaking)</span></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">&quot;lodash/lib/debounce&quot;</span>;</span><br></pre></td></tr></table></figure><ol><li><p>配置 optimization.usedExport 为 true，启用标记功能，标记代码无副作用。在 package.json 中配置 sideEffects: false，可以安全删除</p></li><li><p>启用代码优化功能，有以下途径</p></li></ol><ul><li>配置 mode = production</li><li>配置 optimization.minimize = true</li><li>提供 optimization.minimizer 数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>:<span class="literal">false</span>，</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">usedExports</span>:<span class="literal">true</span>，</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li>避免无意义的赋值: Tree Shaking 逻辑停留在代码静态分析层面，只是浅显地判断: </li></ol><ul><li>模块导出变量是否被其它模块引用</li><li>引用模块的主体代码中有没有出现这个变量</li></ul><p>无法从语义上分析模块导出值是不是真的被有效使用，导致出现一些无意义复制被保留的情况</p><ol><li>使用 #pure 标注纯函数调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(<span class="string">&quot;jack&quot;</span>); <span class="comment">// 会保留</span></span><br><span class="line"><span class="comment">/*#__pure__*/</span> <span class="title function_">fun</span>(<span class="string">&quot;lucy&quot;</span>); <span class="comment">// 不会保留</span></span><br></pre></td></tr></table></figure><ol><li>禁止 Babel 转译模块导入导出语句: 避免 ESM 语句转译成 CommonJS 语句</li><li>优化导出值的粒度: 尽量明确导出对象最小粒度</li><li>使用支持 Tree Shaking 的包</li></ol><h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><blockquote><p>Source Map 是一个信息文件，存储了代码打包转换后的位置信息，实质是一个 json ，维护了打包前后的代码映射关系</p></blockquote><h3 id="生成-source-map"><a href="#生成-source-map" class="headerlink" title="生成 source-map"></a>生成 source-map</h3><h4 id="UglifyJS"><a href="#UglifyJS" class="headerlink" title="UglifyJS"></a>UglifyJS</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uglifyjs app.<span class="property">js</span> - o app.<span class="property">min</span>.<span class="property">js</span>--source - map app.<span class="property">min</span>.<span class="property">js</span>.<span class="property">map</span></span><br></pre></td></tr></table></figure><h4 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">grunt.<span class="title function_">initConfig</span>(&#123;</span><br><span class="line">  <span class="attr">concat</span>: &#123;</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">uglify</span>: &#123;</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">sourceMapIn</span>: <span class="keyword">function</span> (<span class="params">uglifySource</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> uglifySource + <span class="string">&quot;.map&quot;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> plugin1 = <span class="built_in">require</span>(<span class="string">&quot;gulp-plugin1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> plugin2 = <span class="built_in">require</span>(<span class="string">&quot;gulp-plugin2&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sourcemaps = <span class="built_in">require</span>(<span class="string">&quot;gulp-sourcemaps&quot;</span>);</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;javascript&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .<span class="title function_">src</span>(<span class="string">&quot;src/**/*.js&quot;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(sourcemaps.<span class="title function_">init</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">plugin1</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">plugin2</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(sourcemaps.<span class="title function_">write</span>(<span class="string">&quot;../maps&quot;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="SystemJS"><a href="#SystemJS" class="headerlink" title="SystemJS"></a>SystemJS</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.<span class="title function_">bundle</span>(<span class="string">&quot;myModule.js&quot;</span>, <span class="string">&quot;outfile.js&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">minify</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">sourceMaps</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="Webpack-中的-Source-Map"><a href="#Webpack-中的-Source-Map" class="headerlink" title="Webpack 中的 Source Map"></a>Webpack 中的 Source Map</h3><blockquote><p>配置 devtool 的不同取值使用不同的 source map 策略</p><ul><li>内联: 构建速度更快</li><li>外部: 会生成 .map 文件</li></ul></blockquote><ul><li><code>source-map</code>: 外部。可以查看错误代码准确信息和源代码的错误位置</li><li><code>inline-source-map</code>: 内联。只生成一个内联 Source Map，可以查看错误代码准确信息和源代码的错误位置</li><li><code>hidden-source-map</code>: 外部。可以查看错误代码准确信息，但不能追踪源代码错误，只能提示到构建后代码的错误位置</li><li><code>eval-source-map</code>: 内联。每一个文件都生成对应的 Source Map，都在 eval 中，可以查看错误代码准确信息和源代码的错误位置</li><li><code>nosources-source-map</code>: 外部。可以查看错误代码错误原因，但不能查看错误代码准确信息，并且没有任何源代码信息</li><li><code>cheap-source-map</code>: 外部。可以查看错误代码准确信息和源代码的错误位置，只能把错误精确到整行，忽略列</li><li><code>cheap-module-source-map</code>: 外部。可以错误代码准确信息和源代码的错误位置，module 会加入 loader 的 Source Map</li></ul><h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><ol><li>开发环境: 需要考虑速度快，调试更友好。综合速度 (eval &gt; inline &gt; cheap) 和调试 (souce-map)，有两种方案</li></ol><ul><li>eval-source-map: 完整度高，内联速度快</li><li>eval-cheap-module-souce-map: 错误提示忽略列但是包含其他信息，内联速度快</li></ul><ol><li>生产环境: 需要考虑源代码要不要隐藏，调试要不要更友好 (内联会让代码体积变大，生产环境不用内联)，有两种方案</li></ol><ul><li>nosources-source-map: 全部隐藏 (打包后的代码与源代码)</li><li>hidden-source-map: 只隐藏源代码，会提示构建后代码错误信息</li></ul><blockquote><p>综合选择</p><ul><li>dev: <code>source-map</code> (最完整)</li><li>prod: <code>cheap-module-souce-map</code> (错误提示一整行忽略列)</li></ul></blockquote><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="减少打包体积"><a href="#减少打包体积" class="headerlink" title="减少打包体积"></a>减少打包体积</h3><ol><li>只打包需要的模块: 使用 tree-shaking</li><li>代码压缩: </li></ol><ul><li>使用 css-minimizer-webpack-plugin: 压缩和去重 CSS</li><li>terser-webpack-plugin: 压缩和去重 JavaScript，或其他 UglifyJS 插件</li><li>source-map: 在开发模式下生成更准确 (但更大) 的 source-map；在生产模式下生成更小 (但不那么准确) 的 source-map</li><li>webpack-bundle-analyzer: 查看打包后的体积，后续优化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;eval-cheap-module-source-map&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;nosources-source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h3><ol><li>使用缓存提高打包速度: 避免每次修改代码后重新构建和打包，可使用 cache-loader 、 hard-source-webpack-plugin 、HotModuleReplacementPlugin 等插件缓存打包结果</li><li>使用浏览器缓存加快页面速度: 避免重复访问服务器。可以通过在 Webpack 中设置 output.chunkFilename 和 output.filename 来控制静态资源的命名规则，并设置 max-age 等缓存策略</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[hash:8].js&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&#x27;[name].[hash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化图片加载"><a href="#优化图片加载" class="headerlink" title="优化图片加载"></a>优化图片加载</h3><ol><li>使用 file-loader 和 url-loader 进行图片处理: file-loader 会将图片打包后生成一个 url，url-loader (或者 webpack5 的 assets-moudle) 会根据图片大小来决定是否将图片转为 base64 编码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg|webp)$/</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">  <span class="attr">parser</span>: &#123;</span><br><span class="line">     <span class="comment">// Conditions for converting to base64</span></span><br><span class="line">     <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">        <span class="attr">maxSize</span>: <span class="number">25</span> * <span class="number">1024</span>, <span class="comment">// 25kb</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">generator</span>: &#123;</span><br><span class="line">   <span class="attr">filename</span>: <span class="string">&#x27;images/[contenthash][ext][query]&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol><li>使用图片压缩工具压缩: tinyPng、Gzip (需后端配合) 等</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// gzip</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CompressionPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">algorithm</span>: <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">    <span class="attr">threshold</span>: <span class="number">10240</span>,</span><br><span class="line">    <span class="attr">minRatio</span>: <span class="number">0.8</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="代码分割和加载"><a href="#代码分割和加载" class="headerlink" title="代码分割和加载"></a>代码分割和加载</h3><ol><li>使用 SplitChunksPlugin 插件进行代码分割: 可以将公共的依赖模块抽取成 chunk，并且将多个 chunk 之间的重复依赖提取成单独的 chunk</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>按需加载: 资源动态加载，使用 React.lazy() 函数或者 import() 语法，可以实现组件的按需加载</li></ol><h3 id="CDN-加速"><a href="#CDN-加速" class="headerlink" title="CDN 加速"></a>CDN 加速</h3><blockquote><p>CDN: 内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。 CDN 其实是通过优化物理链路层传输过程中的网速有限、丢包等问题来提升网速的，其大致原理可以如下:  因为 CDN 都有缓存，所以为了避免 CDN 缓存导致用户加载到老版本的问题，需要遵循以下规则: </p></blockquote><ul><li>针对 HTML 文件: 不开启任何缓存，不放入 CDN</li><li>针对静态 JS 、CSS 、图片等文件: 开启 CDN 和缓存，放入 CDN 服务器，并且给每一个文件名带入 Hash 值，避免文件重名导致访问到同名缓存废弃文件的问题</li><li>介于浏览器对同一时刻、同一域名的请求个数有限制的状况，请求资源过多的话，可能导致加载文件被阻塞。所以，当同一时间加载资源过多时，我们可以针对不同的文件类型放入不同的 CDN 上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CopyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 1. 在 output 中设置 publicPath</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;http://cdn.example.com/&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 配置 externals，将一些第三方库从打包文件中抽离出来，以便于在 HTML 文件中引入 CDN 资源。</span></span><br><span class="line">  <span class="comment">//    当使用 externals 时，需要在页面中手动引入对应的 CDN 资源</span></span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&#x27;https://cdn.example.com/jquery.min.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 使用插件 html-webpack-plugin，可以在打包后的 HTML 文件中自动插入对应的 CDN 资源链接</span></span><br><span class="line">  <span class="comment">// 4. 使用 copy-webpack-plugin，若存在一些与打包无关的静态资源，此插件将其从源码目录复制到</span></span><br><span class="line">  <span class="comment">//    打包后的目录中，同时修改 HTML 文件中的引用路径为 CDN 地址</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">minify</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">publicPath</span>: <span class="string">&#x27;https://cdn.example.com/&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">from</span>: <span class="string">&#x27;src/assets&#x27;</span>,</span><br><span class="line">          <span class="attr">to</span>: <span class="string">&#x27;assets&#x27;</span>,</span><br><span class="line">          <span class="title function_">transformPath</span>(<span class="params">targetPath</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;PUBLIC_PATH&#125;</span><span class="subst">$&#123;targetPath&#125;</span>`</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 设置 Cache-Control 和 Expires 响应头，可以让浏览器在第一次请求时缓存资源，</span></span><br><span class="line"><span class="comment">//    并在过期前使用本地缓存，从而减少重复请求数据</span></span><br><span class="line">location /<span class="keyword">static</span>/ &#123;</span><br><span class="line">  expires 1d;</span><br><span class="line">  add_header <span class="title class_">Cache</span>-<span class="title class_">Control</span> <span class="string">&quot;public&quot;</span>;</span><br><span class="line">  alias /www/<span class="keyword">static</span>/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化打包速度"><a href="#优化打包速度" class="headerlink" title="优化打包速度"></a>优化打包速度</h3><ol><li>使用 HappyPack : 可以将 loader 进行多线程并行处理，加快速度 (thread-loader 也可以启用多线程)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HappyPack</span> = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;happypack/loader?id=js&quot;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;js&quot;</span>, <span class="comment">// 代表唯一标识符</span></span><br><span class="line">      <span class="attr">threads</span>: <span class="number">4</span>, <span class="comment">// 代表启动的线程数</span></span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&quot;babel-loader&quot;</span>], <span class="comment">// 要处理的loader</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>使用 DLLPlugin 进行预编译: 可以将第三方库先进行打包，然后在开发时直接使用已经打包好的 dll 文件，从而减少重复打包的时间</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">vendors</span>: [<span class="string">&quot;react&quot;</span>, <span class="string">&quot;react-dom&quot;</span>, <span class="string">&quot;lodash&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].dll.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&quot;/dll&quot;</span>,</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&quot;[name]_lib&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">context</span>: __dirname,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;[name]_lib&quot;</span>,</span><br><span class="line">      <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;dist&quot;</span>, <span class="string">&quot;[name].manifest.json&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>使用 IgnorePlugin 忽略部分模块: 忽略掉不需要的模块，在打包时跳过它们，从而提升打包速度。</li></ol><blockquote><p>也可以使用 exclude 、include 来指定需要特定 loader 编译的文件，并非不编译，而是使用默认的 loader 还是指定 loader 的区别。exclude 的优先级高于 include</p><p>Webpack 配置中的 module.noParse 则是在 include/exclude 的基础上，进一步省略了使用默认 js 模块编译器进行编译的时间</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">   <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">   <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">   <span class="attr">use</span>: [</span><br><span class="line">       <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">   ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">IgnorePlugin</span>(<span class="regexp">/^\.\/locale$/</span>, <span class="regexp">/moment$/</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>设置 resolve.alias 配置: 可以将一些常用的模块路径映射为绝对路径，从而缩短 Webpack 查找模块的时间</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">      <span class="attr">react</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;node_modules/react/cjs/react.production.min.js&quot;</span></span><br><span class="line">      ),</span><br><span class="line">      <span class="string">&quot;react-dom&quot;</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;node_modules/react-dom/cjs/react-dom.production.min.js&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>TypeScript 编译优化</li></ol><ul><li>使用 ts-loader: 默认在编译前进行类型检查，因此编译时间往往比较慢，通过加上配置项 transpileOnly: true，可以在编译时忽略类型检查</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">transpileOnly</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><ul><li>使用 babel-loader: 需要单独安装 @babel/preset-typescript 来支持编译 TS,配合 ForkTsCheckerWebpackPlugin 使用类型检查功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TSCheckerPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">typescript</span>: &#123;</span><br><span class="line">        <span class="attr">diagnosticOptions</span>: &#123;</span><br><span class="line">          <span class="attr">semantic</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">syntactic</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他优化项"><a href="#其他优化项" class="headerlink" title="其他优化项"></a>其他优化项</h3><blockquote><p>结合其他插件: MiniCssExtractPlugin、Webpack Shell Plugin、Autoprefixer</p></blockquote><ol><li>Scope Hoisting (作用域提升)</li></ol><blockquote><p>普通打包只是将一个模块最终放入一个单独的函数中,如果模块很多，就意味着在输出结果中会有很多的模块函数。concatenateModules 配置的作用,尽可能将所有模块合并到一起输出到一个函数中，既提升了运行效率，又减少了代码的体积</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ... 其他配置项</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="comment">// 模块只导出被使用的成员</span></span><br><span class="line">    <span class="attr">usedExports</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 尽可能合并每一个模块到一个函数中</span></span><br><span class="line">    <span class="attr">concatenateModules</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>parallel-webpack</li></ol><blockquote><p>并发构建的第二种场景是针对与多配置构建。Webpack 的配置文件可以是一个包含多个子配置对象的数组，在执行这类多配置构建时,默认串行执行</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = [</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./pageA.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;pageA.bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./pageB.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;pageB.bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多入口并发构建</span></span><br><span class="line"><span class="string">&quot;build:parallel&quot;</span>: <span class="string">&quot;parallel-webpack --config webpack.parallel.config.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">// &#x27;production&#x27;, //&#x27;development&#x27;,</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.js&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;file-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">include</span>: &#123;</span><br><span class="line">          <span class="attr">and</span>: [path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;./src/&quot;</span>)],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// &#x27;./lib/style-loader&#x27;,</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;./lib/style-loader&quot;</span>, <span class="string">&quot;./lib/less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">inject</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">template</span>: <span class="string">&quot;./index.html&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包工具</title>
      <link href="/articles/engineering/packTools/"/>
      <url>/articles/engineering/packTools/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/engineering/pTools_1.png" alt=""></p><h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><blockquote><p>流式工程化 pipeline</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&#x27;xxx.js&#x27;</span>)  <span class="comment">// 获取流的目标</span></span><br><span class="line">  .<span class="title function_">pipe</span>(            <span class="comment">// 途径过程编排</span></span><br><span class="line">    gulp.<span class="title function_">dest</span>(<span class="string">&#x27;dist/xxx.js&#x27;</span>);  <span class="comment">// 流目的地</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="src"><a href="#src" class="headerlink" title="src()"></a>src()</h3><blockquote><p>获取到想要处理的流文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">src</span>(globs[, options]); <span class="comment">// =&gt; stream 并非原本文件流，虚拟文件对象流 =&gt; 减少IO次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. globs 文件匹配模式</span></span><br><span class="line"><span class="comment">// 使用数组的方式匹配文件种类</span></span><br><span class="line">gulp.<span class="title function_">src</span>([<span class="string">&#x27;./js/*.js&#x27;</span>, <span class="string">&#x27;./css/*.css&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. options 处理文件的配置项</span></span><br><span class="line"><span class="comment">// options.buffer - boolean 返回buffer，使用场景大文件 =&gt; false时，返回一个抽象的stream而非文件本身</span></span><br><span class="line"><span class="comment">// options.read - boolean文件内容是否返回 =&gt; 判断文件内容是否读取返回，file.content返回值</span></span><br><span class="line"><span class="comment">// options.base - 文件基础路径</span></span><br><span class="line">gulp.<span class="title function_">src</span>(<span class="string">&#x27;./main/js/*.js&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;main&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><ol><li>base 路径问题</li></ol><blockquote><ul><li>默认会以匹配模式中最左边的通配符之前的路径作为 base，并保留之前的目录结构</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// base 路径是 src，最左边的通配符 * 之前的路径是 src，所以，src/js 目录下的所有 .js 文件会被复制到 dist/js 目录中，最终产物的路径会保留 src 之后的目录结构</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;default&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&quot;src/js/*.js&quot;</span>).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// base 路径是 src/js，那么 src/js 目录下的所有 .js 文件会被直接复制到 dist 目录中，而不会保留 src/js 这一层目录结构</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;default&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&quot;src/js/*.js&quot;</span>, &#123; <span class="attr">base</span>: <span class="string">&quot;src/js&quot;</span> &#125;).<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;dist&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>通配符分类</li></ol><ul><li><code>*</code>: 匹配任意数量的任意字符，但不包括路径分隔符 <code>/</code></li><li><code>**</code>: 匹配任意数量的任意字符，包括路径分隔符 <code>/</code>，可以用于递归匹配</li><li><code>?</code>: 匹配单个任意字符</li></ul><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h3><blockquote><p>把文件流通过 pipe 形式导入到 gulp 的通路中，途径插件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br><span class="line">  .<span class="title function_">src</span>(<span class="string">&quot;./main/js/*.js&quot;</span>, &#123; <span class="attr">base</span>: <span class="string">&quot;main&quot;</span> &#125;)</span><br><span class="line">  .<span class="title function_">pipe</span>(<span class="title function_">minify</span>())</span><br><span class="line">  .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;build&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="dest"><a href="#dest" class="headerlink" title="dest()"></a>dest()</h3><blockquote><p>用于将处理后的文件写入到指定的目标路径<br>文件产出的路径是 gulp.dest(path) 指定的目录与 base 之后的目录结构的组合</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">dest</span>(path[, options])</span><br><span class="line"><span class="comment">// 1. path - 写入文件的路径</span></span><br><span class="line"><span class="comment">// 2. options可选参数</span></span><br><span class="line">  <span class="comment">// options.mode - string 0777 所在目录的权限</span></span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch()"></a>watch()</h3><blockquote><p>监视文件变化，用以触发相应编排流程的开展</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gulp.<span class="title function_">watch</span>(glob[, opts], tasks);</span><br><span class="line"><span class="comment">// glob - 监视文件的匹配模式</span></span><br><span class="line"><span class="comment">// tasks - 文件变化后要执行的任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建任务</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 任务内容</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main minify&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;uglify&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 任务内容</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main uglify&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 4.0版本</span></span><br><span class="line">gulp.<span class="title function_">watch</span>(<span class="string">&#x27;./page/**/*.js&#x27;</span>, [<span class="string">&#x27;uglify&#x27;</span>, <span class="string">&#x27;minify&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt; 4.0版本</span></span><br><span class="line">gulp.<span class="title function_">watch</span>(</span><br><span class="line">  <span class="string">&#x27;./page/**/*.js&#x27;</span></span><br><span class="line">  gulp.<span class="title function_">parallel</span>(</span><br><span class="line">    [<span class="string">&#x27;uglify&#x27;</span>, <span class="string">&#x27;minify&#x27;</span>]</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="task"><a href="#task" class="headerlink" title="task()"></a>task()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> gulp.<span class="title function_">task</span>(name[, deps], fn)</span><br><span class="line"> <span class="comment">// name - 任务名</span></span><br><span class="line"> <span class="comment">// deps - 当前任务所依赖的前置 =&gt; 当前任务会在所有依赖的指向完成后，被调用执行</span></span><br><span class="line"> <span class="comment">// fn - 执行函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量执行/打包任务</span></span><br><span class="line"> gulp.<span class="title function_">task</span>(<span class="string">&#x27;js&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;js&#x27;</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> gulp.<span class="title function_">task</span>(<span class="string">&#x27;es&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;es&#x27;</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> gulp.<span class="title function_">task</span>(<span class="string">&#x27;webpack&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> gulp.<span class="title function_">task</span>(<span class="string">&#x27;main&#x27;</span>, gulp.<span class="title function_">parallel</span>(</span><br><span class="line">   [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;es&#x27;</span>, <span class="string">&#x27;webpack&#x27;</span>]</span><br><span class="line"> ))</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 异步任务不会等待</span></span><br><span class="line"> gulp.<span class="title function_">task</span>(<span class="string">&#x27;async&#x27;</span>, <span class="title function_">funtion</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="title function_">setTimout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main async&#x27;</span>)</span><br><span class="line">   &#125;, <span class="number">1000</span>)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h2 id="webpack-gulp"><a href="#webpack-gulp" class="headerlink" title="webpack / gulp"></a>webpack / gulp</h2><ol><li>执行粒度上</li></ol><ul><li>webpack: 以功能依赖模块为粒度，区分 loaders 或 plugins</li><li>gulp: 以任务为配置粒度，配置是将依赖、工具、功能抽象组装成任务，编排成任务流</li></ul><ol><li>执行顺序上</li></ol><ul><li>webpack: 以文件类型负责区域来网状构造项目，弱化顺序项目复杂程度</li><li>gulp: 流式的方式串联每一项工具依赖，更适合作为自动化工具链来使用</li></ul><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="webpack-升级"><a href="#webpack-升级" class="headerlink" title="webpack 升级"></a>webpack 升级</h3><h4 id="v3-gt-v4"><a href="#v3-gt-v4" class="headerlink" title="v3 =&gt; v4"></a>v3 =&gt; v4</h4><ol><li>零配置</li></ol><blockquote><ul><li>不强制依赖 webpack.config.js =&gt; 默认项: entry: ‘./src/index.js &amp; output: ‘./dist/main.js’</li><li>wepack-cli 分离安装</li></ul></blockquote><ol><li>状态上</li></ol><blockquote><ul><li>提供 mode 区分 development &amp; production，提升开发编译效率，专注于编译产品</li></ul></blockquote><ol><li>scope hoisting</li></ol><blockquote><ul><li>作用域提升: 分析模块之间的依赖关系，将所有模块的代码按照顺序放在一个函数作用域中，减少函数闭包的数量，从而减小打包后的文件体积，提高代码的执行效率</li><li>开启方式: Webpack 4 开始，默认开启，但需要使用 ES6 模块语法</li></ul></blockquote><ol><li>tree shaking</li></ol><blockquote><ul><li>摇树优化: 在打包过程中静态分析模块之间的导入和导出关系，找出那些没有被引用的代码 (死代码)，并将其从打包结果中移除，从而减小打包后的文件体积</li><li>开启方式: ES6 模块语法 + production 自动开启</li></ul></blockquote><ol><li>细节配置差异</li></ol><blockquote><ul><li>commonChunkPlugin =&gt; splitChunks</li><li>loaders =&gt; rules</li><li>css loader 增加 use</li><li>css-loader =&gt; style-loader =&gt; miniCssExtract.loader</li></ul></blockquote><h4 id="v4-优化"><a href="#v4-优化" class="headerlink" title="v4 优化"></a>v4 优化</h4><blockquote><p>对产品打包以及开发编译的速度做出了优化</p></blockquote><h4 id="v4-gt-v5"><a href="#v4-gt-v5" class="headerlink" title="v4 =&gt; v5"></a>v4 =&gt; v5</h4><ol><li>持久化缓存: 阶段性编译结果存放如持久化缓存磁盘区域</li></ol><blockquote><ul><li>v4 需要使用插件，hard-source-webpack-plugin</li><li>development，cache.type 默认被设置为 ‘memory’；production，默认开启，且 cache.type 通常建议设置为 ‘filesystem’</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;fileSystem&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>资源模块: 通过规整统一处理资源文件，优化资源文件引入的方式，直接与文件目标结合处理</li></ol><blockquote><ul><li>old: raw-loader、url-loader、file-loader</li><li>new: asset/resource =&gt; file-loader、asset/inline =&gt; url-loader、asset/source =&gt; raw-loader</li></ul></blockquote><ol><li>打包优化</li></ol><blockquote><ul><li>tree-shaking: 跨模块 shaking</li><li>splitchunk: 精细化配置</li></ul></blockquote><ol><li>代码压缩<blockquote><p>自带 js 压缩功能，v4 需要下载安装 terser-webpack-plugin 插件</p></blockquote></li></ol><h4 id="v5-优化"><a href="#v5-优化" class="headerlink" title="v5 优化"></a>v5 优化</h4><blockquote><p>进一步优化配置，优化编译速度以及包大小</p></blockquote><h3 id="webpack-插件"><a href="#webpack-插件" class="headerlink" title="webpack 插件"></a>webpack 插件</h3><h4 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h4><blockquote><ul><li>cache-loader，缓存耗时的工作</li><li>terser-webpack-plugin / uglifyjs-webpack-loguin 的 cache 以及 parrallel</li></ul></blockquote><h4 id="减肥瘦身"><a href="#减肥瘦身" class="headerlink" title="减肥瘦身"></a>减肥瘦身</h4><blockquote><ul><li>imagemin-webpack-plugin 批量压缩图片</li><li>purifycss-wepack，删除未使用的 css 代码</li><li>optimize-css-assets-webpack-plugin, 压缩 css</li></ul></blockquote><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><blockquote><ul><li>cleanWebpackPlugin，打包前清理上次项目生成的 bundle 文件</li><li>happypack…</li></ul></blockquote><h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><blockquote><ul><li>冷启动 / 冷服务: 开发状态下不重新走编译打包</li><li>热更新: 更新源文件时依旧可以实时更新视图</li><li>按需更新: 不刷新所有节点，只更新改动部分</li></ul></blockquote><h3 id="vs-webpack"><a href="#vs-webpack" class="headerlink" title="vs webpack"></a>vs webpack</h3><blockquote><p>webpack - 编译支撑开发</p><ul><li>打包生成 bundle =&gt; 启动 dev-server =&gt; 建立开发环境</li><li>HMR =&gt; 改动到的模块以及相关依赖重新打包编译</li></ul><p>vite - 路由劫持 + 实时编译</p><ul><li>启动 dev-server =&gt; 直接请求所需模块并且实时编译（rollup js 模块打包器 AMD CJS =&gt; ESM）</li><li>HMR =&gt; 让浏览器重新请求当前页面所需模块 =&gt; 利用浏览器的强缓存和协商缓存优化请求（源码模块协商缓存，依赖模块用强缓存）</li></ul><p>总结</p></blockquote><ol><li>省去打包生成 bundle 过程</li><li>通过 rollup 对模块进行按需实时编译</li><li>利用缓存机制对不同模块进行缓存优化</li></ol><h3 id="dev-prod"><a href="#dev-prod" class="headerlink" title="dev / prod"></a>dev / prod</h3><blockquote><p>dev: esbuilder</p><ul><li>依赖预构建 cjs / AMD =&gt; ESM</li><li>依赖缓存到 node_modules/.vite</li><li>package.json / lockfile / vite.config.js =&gt; 三者之一触发 =&gt; 重新预构建</li><li>通过浏览器的缓存机制 =&gt; 缓存请求处理 =&gt; 提升页面性能</li></ul><p>prod: rollup</p></blockquote><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>原生的 ts 支持</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>原生的文件引入支持</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./src/assets/reset.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./src/assets/mock.json&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>新增依赖支持，vite.config.js</li></ul><h3 id="原理实践"><a href="#原理实践" class="headerlink" title="原理实践"></a>原理实践</h3><blockquote><p>vite 缓存控制依赖模块，浏览器缓存控制静态资源、业务代码、js 文件等</p></blockquote><ol><li>ESM 静态定义，编译时做加载 =&gt; 生成只读引用</li><li>路由脚本进入只引用需要被加载模块 from 只读引用 =&gt; 实时编译运行包含依赖的代码</li><li>浏览器缓存优化 =&gt; 分模块按需加载，未变化直接用缓存 / 模块变化只更新模块</li></ol><h2 id="主流构建工具"><a href="#主流构建工具" class="headerlink" title="主流构建工具"></a>主流构建工具</h2><h3 id="底层-JS-TS-转译器"><a href="#底层-JS-TS-转译器" class="headerlink" title="底层 JS/TS 转译器"></a>底层 JS/TS 转译器</h3><blockquote><p>纯粹用于将 TypeScript/JavaScript/JSX 编译到某种特定运行环境下的底层转译器，代表有 BabelO(Js)、TSC(Ts)、esbuild(Go) 和 SWC(Rust) 等。虽然我将它们归类为转译器，但是它们大都也支持打包的能力，比如 esbuild 就把自己定位为打包器。</p></blockquote><h3 id="上层打包器"><a href="#上层打包器" class="headerlink" title="上层打包器"></a>上层打包器</h3><blockquote><p>通常不会具备转译能力，而是借助上面提到的这些转译器来实现转移能力。它们更专注于完成一些范围更广、更加具体的打包任务。代表有 Webpack、Rollup、Parcel、esbuild、Snowpack、Vite、wmr、microbundle、tsup、tsdx、tsup 等。</p></blockquote><h4 id="dev-环境"><a href="#dev-环境" class="headerlink" title="dev 环境"></a>dev 环境</h4><ol><li>通过监听源代码变化然后重新构建项目将打包后的代码推送到浏览器的传统模式</li></ol><ul><li>Webpack+Babel</li><li>Rollup: 通常打包第三方库</li><li>Parcel: 和 Webpack 的功能类似，但是它简化了配置，号称零配置、开箱即用。Parcel 2 的 JS 转译器部分基于 SWC 进行开发，性能有很大提升。</li></ul><ol><li>通过浏览器的原生 module 来实现动态打包的 bundleless 模式</li></ol><ul><li>Snowpack: 最大的特点就是闪电般的速度。最终部署它会使用 Webpack/Parcel 插件。不过已经不再积极维护了</li><li>Vite: 也是以速度著称，打包部分使用 Rollup，所以最终部署时打包体积相比 Snowpack 会更小。</li><li>wmr: 非常轻量级的打包工具，它没有任何 npm 依赖。所以它没有 Snowpack 和 Vite 成熟，但是 wmr 更适合用在 Preact 或者一些简单的项目上</li></ul><h4 id="ts-打包器"><a href="#ts-打包器" class="headerlink" title="ts 打包器"></a>ts 打包器</h4><ul><li>TSDX: 对自身的定位不是一个打包器那么简单，而是覆盖了一个 TypeScript 项目开发时所需的所有东西的零配置 CLI: Rollup、Jest、tsc、yarn、TSLint、VSCode……，有点 All in One 的感觉。</li><li>tsup: 优势也是零配置，并且底层是使用 esbuild 作为支持的。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点:"></a>优缺点:</h3><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><ul><li>热更新方面: webpack 支持 HMR，但是 webpack 需要全部重新编译并更新，效率较低</li><li>tree-shaking: webpack2 开始支持且消除效果不好，但是 webpack5 有更好的 tree-shaking（去除未使用代码）</li><li>分包方面: webpack 支持代码切割。（分包）</li><li>ESM 打包: 现在 webpack 支持 es6module 输出</li></ul><h4 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h4><blockquote><p>优点</p></blockquote><ul><li>Rollup 是一款 ES Modules 打包器，从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多，打包生成的文件更小。（识别 commonJs 需要插件）</li><li>热更新: Rollup 不支持 HMR，在对 js 以外的模块的支持上不如 webpack，但是如果是打包纯 js 库例如 react，前期的 vue 的话，使用 rollup 是很合适的，打包的产物比较干净，没有 webpack 那么多工具函数</li><li>Rollup 的插件机制设计得相对更干净简洁，单个模块的 resolve / load / transform 跟打包环节完全解耦，所以 Vite 才能在开发时模拟 Rollup 的插件机制，并且兼容大部分 Rollup 插件</li><li>rollup 原生支持 tree-shaking</li></ul><blockquote><p>缺点</p></blockquote><ul><li>加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup 需要使用插件去完成</li><li>rollup 并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用 CommonJs 方式导出成员，并且 rollup 不支持 HMR，使开发效率降低</li></ul><h4 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h4><blockquote><p>组成: </p><ul><li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度很快的 【模块热更新 HMR】</li><li>一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li></ul><p>特点: </p><ul><li>快速的冷启动: vite 会直接启动开发服务器，不需要进行打包操作，所以不需要分析模块的依赖、不需要编译，因此启动速度非常快</li><li>即时的模块热更新</li><li>真正的按需编译: 利用现代浏览器支持 ES Module 的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</li></ul><p>优点</p></blockquote><ol><li>vite 热更新，实现按需编译，按模块更新。（快）</li></ol><ul><li>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失效，使 HMR 更新始终快速，无论应用的大小。</li><li>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）: 源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</li><li>热更新原理: 在热模块 HMR 方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像 webpack 那样需要把该模块的相关依赖模块全部编译一次，效率更高</li></ul><ol><li>vite 在生产环境通过 Rollup 进行打包（特点: 打包体积小），生成 esm 模块包。（特点: 快）</li></ol><ul><li>vite 在开发环境时，基于浏览器支持 esm，让浏览器解析模块，然后服务器按需编译返回。同时基于 esbuild（go）进行预构建打包不常变动的第三包，并用进行缓存。（缓存+快）</li><li>Vite 使用 esbuild 预构建依赖。Esbuild 使用 Go 编写，并且比以 Node.js 编写的打包器预构建依赖快 10-100 倍。</li></ul><blockquote><p>缺点</p></blockquote><ul><li>生态: 生态不如 webpack，wepback 在于 loader 和 plugin 非常丰富</li><li>prod 环境的构建: 目前用的 Rollup，原因在于 esbuild 对于 css 和代码分割不是很友好</li><li>还没有被大规模使用,很多问题或者诉求没有真正暴露出来</li></ul><h2 id="前端测试"><a href="#前端测试" class="headerlink" title="前端测试"></a>前端测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ol><li>覆盖率: 测试案例覆盖的场景</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">top10</span>(<span class="params">number, sum</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (sum += number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">top10</span>(<span class="number">8</span>);</span><br><span class="line"><span class="title function_">top10</span>(<span class="number">9</span>);</span><br><span class="line"><span class="comment">// 覆盖率 =&gt; 50%</span></span><br></pre></td></tr></table></figure><ol><li>单元拆分</li></ol><ul><li>逻辑闭环的最小模块</li><li>最小实现的视图组件</li></ul><ol><li>环境准备</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 依赖安装</span></span><br><span class="line">npm i --save-dev jest</span><br><span class="line">npm i @type/jest babel-jest @vue/test-utlis@next @testing-library/jest-dom ts-jest vue-jest @babel/preset-env --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置babel</span></span><br><span class="line"><span class="comment">// jest文件支持es6语法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 配置jest</span></span><br></pre></td></tr></table></figure><h3 id="E2E-测试"><a href="#E2E-测试" class="headerlink" title="E2E 测试"></a>E2E 测试</h3><blockquote><p>业务功能触发，不关注具体实现，只验证是否实现业务功能 =&gt; 开发 or 测试，例如 cypress 库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器性能优化</title>
      <link href="/articles/engineering/browser/"/>
      <url>/articles/engineering/browser/</url>
      
        <content type="html"><![CDATA[<h2 id="Navigation-Timing"><a href="#Navigation-Timing" class="headerlink" title="Navigation Timing"></a>Navigation Timing</h2><p><img src="/images/engineering/browser_1.png" alt=""></p><p><img src="/images/engineering/browser_2.png" alt=""></p><ol><li>navigationStart</li></ol><blockquote><p>前一个文档卸载时间戳 =&gt; 无上一层页面时，从 fetchStart 开始</p></blockquote><ol><li>unloadEventStart / unloadEventEnd</li></ol><blockquote><p>与前一个网页 unload 时的时间戳 =&gt; 无上一个网页，默认 0<br>执行完毕的时间戳</p></blockquote><ol><li>redirectStart / redirectEnd</li></ol><blockquote><p>通常用来计算 redirect 完成的时间</p></blockquote><ol><li>worker</li></ol><blockquote><p>worker 初始化时间</p></blockquote><ol><li>fetchStart</li></ol><blockquote><p>整个全新开始页面的 start<br>浏览器网络层 ready 的时间</p></blockquote><ol><li>domainInLookupStart / domainInLookupEnd</li></ol><blockquote><p>DNS 连接的开始结束</p></blockquote><ol><li>connectStart / connectEnd</li></ol><blockquote><p>TCP 连接的开始结束</p><ul><li><code>connectEnd</code> - <code>domainInLookupStart</code> 为网络的建立连接过程</li><li><code>secureConnectionStart</code>: 若使用 https 会有此过程，建立安全链接</li></ul></blockquote><ol><li>requestStart / responseEnd</li></ol><blockquote><p>整个请求的发起开始到完成接收耗时</p></blockquote><h2 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h2><blockquote><p>纯前端可做的性能优化，主要集中在 dom 渲染过程中</p></blockquote><ol><li>domLoading</li></ol><blockquote><p>开始解析渲染 dom 树的事件 =&gt; readyStateChange</p></blockquote><ol><li>domInterActive</li></ol><blockquote><p>完成了 dom 树的解析 =&gt; readyStateChange =&gt; 只是完成了 dom 树的解析，并没有开始加载网页资源 (async/defer)</p><ul><li><code>domInterActive</code> - <code>domLoading</code> 为解析 dom 树的时间</li></ul></blockquote><ol><li>domContentLoaddedEventStart / domContentLoaddedEventEnd</li></ol><blockquote><p>Dom 树解析完成后，资源的加载</p></blockquote><ol><li>domComplete</li></ol><blockquote><p>Dom 树 ready</p><ul><li><code>domComplete</code> - <code>domLoading</code> 为整个 dom 树初始化所需要的时间</li></ul></blockquote><ol><li>loadEventStart / loadEventEnd</li></ol><blockquote><p>执行脚本开始与结束</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="attr">javascript</span>:(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> performance = <span class="variable language_">window</span>.<span class="property">performance</span>.<span class="property">timing</span>;</span><br><span class="line">  <span class="keyword">const</span> pageLoadTime = performance.<span class="property">loadEventEnd</span> - performance.<span class="property">navigationStart</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印、上报、存储</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前页面加载耗时: &#x27;</span>, pageLoadTime, <span class="string">&#x27;ms&#x27;</span>);</span><br><span class="line">  &#125;)()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="W3C-Paint-Timing"><a href="#W3C-Paint-Timing" class="headerlink" title="W3C Paint Timing"></a>W3C Paint Timing</h2><blockquote><p>新时代下的指标</p></blockquote><ol><li>DCL(DOMContentLoad): HTML 加载完成时间</li><li>L(onLoad): 页面所有资源加载完成时间</li></ol><blockquote><p>performance.getEntriesByType(‘paint’) 获取以下两个时间点的值</p></blockquote><ol><li>FP(First Paint): 页面在导航后首次呈现出不同于导航前内容的时间点</li><li>FCP(Fisrt Contentful Paint): 首次绘制任何文本、图像、非空白 canvas 或 svg 的时间点</li><li>FMP(First Meaningful Paint): 首次绘制页面“主要内容”的时间点</li><li>LCP(Largest Contentful Paint): 可视区域“内容”最大的可见元素开始出现在页面上的时间点</li><li>CLS(Cumulative Layout Shift): 表示用户经历的意外 layout 的频率</li><li>TBT(Total Blocking Time): 表示从 FCP 到 TTI(可交互时间 Time to Interactive) 之间所有 long task 的阻塞时间之和</li></ol><h2 id="Core-Web-Vitals"><a href="#Core-Web-Vitals" class="headerlink" title="Core Web Vitals"></a>Core Web Vitals</h2><blockquote><p>CWV 网页核心性能指标<br>加载、交互、视觉稳定 —— 代表不同方向的衡量标准 + 可衡量且接近真是体验的数据化参数</p></blockquote><h3 id="Largest-Contentful-Paint-LCP"><a href="#Largest-Contentful-Paint-LCP" class="headerlink" title="Largest Contentful Paint(LCP)"></a>Largest Contentful Paint(LCP)</h3><blockquote><p>衡量装载的性能<br>页面加载前 2.5s 内，必须要进行最大内容的渲染</p></blockquote><ol><li>什么是最大内容</li></ol><ul><li>图片 <code>&lt;image&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;svg&gt;</code></li><li>视频 <code>&lt;video&gt;</code></li><li>通过 url 加载内容的模块 (例如 background 为 url)</li><li>主要文本模块以及其内联模块</li></ul><ol><li>LCP 值低下的原因及解决方案</li></ol><ul><li>资源慢: 使用缓存 =&gt; 强缓存 + 协商缓存</li><li>渲染被阻断: 简化结构与逻辑 + 内联、合并方式简化整体解析逻辑</li><li>资源交互: 图片分类 =&gt; 1. 图片上传 2. 云资源管理</li><li>静态资源: CDN</li></ul><h3 id="First-Input-Delay-FID"><a href="#First-Input-Delay-FID" class="headerlink" title="First Input Delay(FID)"></a>First Input Delay(FID)</h3><blockquote><p>衡量交互体验<br>页面首次输入延迟小于 100ms</p></blockquote><ol><li>减少 JS 的执行时间</li></ol><ul><li>优化算法</li><li>尽量减少 JS 的占用:  空间 + 时间</li><li>首屏加载:  1. 服务端渲染 2. 预加载、懒加载</li></ul><ol><li>解决长任务问题</li></ol><ul><li>阻塞渲染 50ms 以上:  尽量拆分，或者交互弥补</li></ul><ol><li>提升性能来帮助提速</li></ol><ul><li>JS workers: Web worker | service worker | worklet</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.js */</span></span><br><span class="line"><span class="comment">// 新增一个worker</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main thread 通信</span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&quot;Come on &amp; work~&quot;</span>);</span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* worker.js */</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">  <span class="comment">// 回调主人喊话 =&gt; 业务逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成后发给main</span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(<span class="comment">/* 业务逻辑 */</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service worker - 网络 + 内存</span></span><br><span class="line"> <span class="comment">/* main.js */</span></span><br><span class="line"> navigator.<span class="property">seviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;service-worker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* service-worker.js */</span></span><br><span class="line"> self.<span class="title function_">addEventLister</span>(<span class="string">&quot;install&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br><span class="line"> self.<span class="title function_">addEventLister</span>(<span class="string">&quot;activate&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br><span class="line"> self.<span class="title function_">addEventLister</span>(<span class="string">&quot;fetch&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">     e.<span class="title function_">respondwith</span>(</span><br><span class="line">         caches.<span class="title function_">match</span>(event.<span class="property">request</span>);</span><br><span class="line">     )</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器概念流程:  JS =&gt; style =&gt; layout =&gt; paint =&gt; composite</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* main.js */</span></span><br><span class="line"><span class="variable constant_">CSS</span>.<span class="property">paintWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;worklet.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* worklet.js */</span></span><br><span class="line"><span class="title function_">registerPaint</span>(<span class="string">&#x27;myGradient&#x27;</span>, <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="title function_">paint</span>(<span class="params">ctx, size, prop</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> gradient = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, size.<span class="property">height</span> - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line">        gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ctx.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">        ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, size.<span class="property">width</span>, size.<span class="property">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* app */</span></span><br><span class="line">.<span class="property">content</span> &#123;</span><br><span class="line">    background-<span class="attr">image</span>: <span class="title function_">paint</span>(myGradient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cumulative-Layout-Shift-CLS"><a href="#Cumulative-Layout-Shift-CLS" class="headerlink" title="Cumulative Layout Shift(CLS)"></a>Cumulative Layout Shift(CLS)</h3><blockquote><p>衡量视觉稳定性<br>页面要保持 CLS 小于 0.1: 可见元素从前一帧到后一帧改变位置的动作</p></blockquote><ol><li>不使用无尺寸元素</li></ol><blockquote><p>srcset &amp; sizes: 根据屏幕自适应，多用于移动端，效果如 web 端的 media</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">&quot;width-320w.jpg 320w, width-480w.jpg 480w, width-800w.jpg 800w&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 320px) 300px, (max-width: 480px) 440px, 800px&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><ol><li>减少内容内部的插入</li></ol><blockquote><p>影响到整体的布局</p></blockquote><ol><li>字体控制</li></ol><h3 id="CWV-工具"><a href="#CWV-工具" class="headerlink" title="CWV 工具"></a>CWV 工具</h3><blockquote><p>Core Web Vitals Annotations</p></blockquote><h2 id="性能评估指标-performance"><a href="#性能评估指标-performance" class="headerlink" title="性能评估指标 - performance"></a>性能评估指标 - performance</h2><h3 id="页面性能评估参考指标"><a href="#页面性能评估参考指标" class="headerlink" title="页面性能评估参考指标:"></a>页面性能评估参考指标:</h3><ol><li>FPS、CPU、网络请求</li><li>网络任务队列</li><li>JS 消耗时间、性能占用</li><li>浏览器绘制页面的帧布局</li></ol><h3 id="工程化监控体系"><a href="#工程化监控体系" class="headerlink" title="工程化监控体系"></a>工程化监控体系</h3><ol><li>上报 =&gt; 信息采集 =&gt; 数据回收 =&gt; 获取场景数据</li><li>数据分析 =&gt; timing 节点计算 =&gt; 阈值设置 + 数据分类 + 数据重组</li><li>可视化展示<blockquote><p>一些埋点工具流程参考: growing.io (采集上报) =&gt; fineBi / powerBi (数据分析) =&gt; grafana (数据展示看板) =&gt; 钉钉、企业微信、飞书 webhook (监控信息告警)</p></blockquote></li></ol><h3 id="性能优化的另一种可能-bigpipe-——-页面分解成若干的-pagelet"><a href="#性能优化的另一种可能-bigpipe-——-页面分解成若干的-pagelet" class="headerlink" title="性能优化的另一种可能:  bigpipe —— 页面分解成若干的 pagelet"></a>性能优化的另一种可能:  bigpipe —— 页面分解成若干的 pagelet</h3><ol><li>服务前端接收客户端请求</li><li>node 生成 HTML * n =&gt; 若干个 pagelet</li><li>浏览器获取到 pagelet 后开始加载资源做 layout paint</li><li>客户端整合形成页面</li></ol><h3 id="MVVM-优化"><a href="#MVVM-优化" class="headerlink" title="MVVM 优化"></a>MVVM 优化</h3><ol><li>自身特性优化<br>vue - template<br>react - dom diff</li><li>技巧上的优化</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setNewState = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setSate</span>(&#123;</span><br><span class="line">        <span class="comment">/* */</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 每点击一次新生成一个方法示例</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> &#123; this.setState(/* ^ */) &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 优化</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.setNewState&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// computed代替watch</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">      <span class="title function_">preData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span> + data;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">preData</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="title function_">preData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">preData</span> = <span class="string">&#x27;123&#x27;</span> + data;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="首屏方案选择"><a href="#首屏方案选择" class="headerlink" title="首屏方案选择"></a>首屏方案选择</h3><blockquote><p>几个方案的实现都依赖于 MutationObserver API 用于监听 DOM 变动</p><ul><li>在页面加载中 初始化 MutationObserver, 当每一次页面发生变化时，会去判断页面是不是一次有意义的变化，例如变化的标签是不是一些有意义需要统计的标签，例如 meta link script 这类标签就认为这一次变动是无意义的，无需后面的步骤</li><li>然后会记录下发生变化的时间，以及通过 setTag 给此次变化的 DOM 打上标记</li><li>一个简单的递归 DOM 树，为每一个在屏幕范围内具有大小的可见元素进行标记，一旦发现父级不满足要求就不会向下递归</li></ul></blockquote><p><img src="/images/engineering/browser_3.png" alt=""></p><ol><li>首屏内加载最慢的图片: 监听首屏内所有图片的 onload 事件，获取图片 onload 时间的最大值，即可获得近似的首屏时间。</li><li>页面的 DOM 树第一次稳定: 这个方案想要比较好的实现比较有难度，并且精确度值得商榷。</li><li>不够规范</li><li>最大变化: 在之前只通过大小一个维度来描述首屏的基础上，又衍生出了，计算最大的一次变化，通过层级、标签权重、元素面积等因素，通过计分的方式，记录下最大的一次变化。</li></ol><h2 id="首屏优化手段"><a href="#首屏优化手段" class="headerlink" title="首屏优化手段"></a>首屏优化手段</h2><ol><li>路由懒加载</li><li>非首屏使用异步组件</li><li>首屏不要使用组件延迟加载</li><li>静态资源 CDN</li><li>避免不必要的重定向</li><li>减少页面唯一域名，从而减少 DNS 查询次数/使用 dns prefetch 做预解析</li><li>减小首屏上 JS、CSS 等资源文件大小</li><li>服务端渲染</li><li>减少 DOM 的数量和层级</li><li>精灵图请求</li><li>loading 效果</li><li>gzip</li><li>图片懒加载</li><li>组件按帧率来分别加载: 结合 requestAnimationFrame 使用</li></ol><h2 id="requestAnimationFrame、setTimeout、setInterval"><a href="#requestAnimationFrame、setTimeout、setInterval" class="headerlink" title="requestAnimationFrame、setTimeout、setInterval"></a>requestAnimationFrame、setTimeout、setInterval</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>setTimeout: 这个函数会将要执行的代码或函数放入事件循环队列中，等待当前代码执行完毕后，再等待指定的时间后执行一次。如果设置了定时器，那么每隔一定时间就会执行一次代码，直到 clearTimeout 被调用或窗口被关闭。</li><li>setInterval: 与 setTimeout 类似，setInterval 也会将要执行的代码或函数放入事件循环队列中，但它在指定的时间间隔后会一直重复执行，直到 clearInterval 被调用或窗口被关闭。也就是说，setInterval 会不断地调用函数，直到被取消。</li><li>requestAnimationFrame: 这个函数的工作原理与 setInterval 和 setTimeout 略有不同。它会将回调函数加入到浏览器下一次重绘之前要执行的队列中。这样做的目的是为了确保动画的流畅度，因为浏览器会自动优化这个 API，只在浏览器处于激活状态并且页面处于可见状态时才会执行回调函数。此外，requestAnimationFrame 会根据系统的刷新率来自动匹配时间间隔，从而确保每帧动画的间隔时间尽可能地准确。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>执行时机: requestAnimationFrame 是由浏览器提供的 API，它会在浏览器下一次重绘之前执行回调函数。这意味着它能够确保动画的流畅度，并且能够自动匹配系统的刷新率。相比之下，setInterval 和 setTimeout 会在指定的时间间隔后执行回调函数，无论浏览器是否处于激活状态或正在进行其他操作。</li><li>性能优化: requestAnimationFrame 由浏览器自动优化，只在浏览器处于激活状态并且页面处于可见状态时才会执行回调函数。这可以节省 CPU、GPU 和内存的使用，特别是在移动设备上。相比之下，setInterval 和 setTimeout 不会自动优化，如果页面处于隐藏或不可见状态，它们会继续执行回调函数，这可能会导致资源的浪费。</li><li>回调函数执行时间: requestAnimationFrame 的回调函数会在浏览器下一次重绘之前执行，因此它能够确保回调函数的执行时间相对准确。相比之下，setInterval 和 setTimeout 的回调函数执行时间取决于浏览器事件循环中的队列和执行时间，因此可能会有一定的延迟</li><li>停止操作: requestAnimationFrame 的回调函数只会在浏览器下一次重绘之前执行一次，因此可以通过清除队列中的回调函数来停止操作。相比之下，setInterval 和 setTimeout 会不断地执行回调函数，直到 clearInterval 或 clearTimeout 被调用或关闭页面为止</li><li>函数节流: 在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 requestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>setTimeout: 可用于在网页加载后延迟执行某些操作，例如加载页面内容、初始化组件等。也可用于定时触发某些操作，例如定时发送数据、定时检查任务等。</li><li>setInterval: 常用于需要周期性执行的操作，例如定时更新数据、定时触发事件等。在 web 端，如果列表需要定时更新，可以使用 setInterval 来定时获取列表的请求。另外，如果需要在某一特定情况下清除定时任务，可以使用 clearInterval 来停止定时器。</li><li>requestAnimationFrame: 主要用于实现流畅的动画效果。它会在浏览器下一次重绘之前执行指定的函数，避免了频繁的重绘导致的性能问题。requestAnimationFrame 会自动匹配系统的刷新率，从而确保每帧动画的间隔时间尽可能地准确。在需要反复触发的情况下，使用 requestAnimationFrame 可以避免连续调用导致的相互干扰。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/articles/engineering/cdn/"/>
      <url>/articles/engineering/cdn/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ol><li>CDN 的全称是 (Content Delivery Network)，即内容分发网络。</li><li>组成: 分布式存储 + 负载均衡 + 网络请求的重定向 + 内容管理 + 全局的网络流量管理，后两项为核心。内容服务基于缓存服务器，也称作代理缓存。</li><li>将源站的资源缓存到位于全球各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都从源站获取。</li><li>解决由于网络带宽小、用户访问量大、网点分布不均等原因，避免网络拥塞、缓解源站压力，提高用户访问网站的响应速度。</li></ol><h3 id="CDN-回源"><a href="#CDN-回源" class="headerlink" title="CDN 回源"></a>CDN 回源</h3><ol><li>回源是 CDN 领域的专用词，指的是 CDN 缓存服务器从源站获取所需要分发的资源。</li><li>CDN 缓存服务器一般是不会主动回源的，只有在缓存服务器缺少用户请求的资源时（可能是该资源 CDN 缓存服务器没有缓存，也可能是缓存过期），CDN 缓存服务器才会向源站发起请求，获取所需要分发的资源。</li><li>通常有三种情况: <ul><li>CDN 节点没有对应资源时主动到源站获取资源</li><li>缓存失效后，CDN 节点到源站获取资源</li><li>CDN 管理后台或者使用开放接口主动刷新</li></ul></li></ol><h2 id="CDN-工作原理"><a href="#CDN-工作原理" class="headerlink" title="CDN 工作原理"></a>CDN 工作原理</h2><h3 id="调度原理"><a href="#调度原理" class="headerlink" title="调度原理"></a>调度原理</h3><h4 id="传统网络访问过程"><a href="#传统网络访问过程" class="headerlink" title="传统网络访问过程"></a>传统网络访问过程</h4><ol><li>用户输入访问的域名,操作系统向 LocalDns 查询域名的 ip 地址</li><li>LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)</li><li>ROOT DNS 将域名授权 dns 记录回应给 LocalDns</li><li>LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址</li><li>域名授权 dns 查询域名记录后，回应给 LocalDns</li><li>LocalDns 将得到的域名 ip 地址，回应给用户端</li><li>用户得到域名 ip 地址后，访问站点服务器</li><li>站点服务器应答请求，将内容返回给客户端</li></ol><h4 id="CDN-访问过程"><a href="#CDN-访问过程" class="headerlink" title="CDN 访问过程"></a>CDN 访问过程</h4><blockquote><p>用户-本地 DNS-根 DNS-授权 DNS-智能调度 DNS-CDN 节点 IP</p></blockquote><ol><li>用户输入访问的域名,操作系统向 LocalDns 查询域名的 ip 地址</li><li>LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)</li><li>ROOT DNS 将域名授权 dns 记录回应给 LocalDns</li><li>LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址</li><li>域名授权 dns 查询域名记录后(一般是 CNAME)，回应给 LocalDns</li><li>LocalDns 得到域名记录后,向智能调度 DNS 查询域名的 ip 地址</li><li>智能调度 DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的 CDN 节点 ip 地址回应给 LocalDns</li><li>LocalDns 将得到的域名 ip 地址，回应给用户端</li><li>用户得到域名 ip 地址后，访问站点服务器</li><li>CDN 节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)</li></ol><h3 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h3><blockquote><p>如果用户首次访问个数据，数据会从源服务器缓存到 CDN 服务器上，当有其他用户在再次访问这些数据的时候，数据会从 CDN 服务器反馈给用户</p></blockquote><ol><li>用户输入 URL，浏览器将解析过后的域名发给 DNS 服务器</li><li>CDN 返回该域名对应的 CNAME，此时浏览器需要再次对获得的 CNAME 进行解析，才能得到 CDN 缓存服务器的 IP 地址。在此过程中全局负载均衡 DNS 解析服务器会将用户的访问请求定位到离用户最近、负载最轻的 CDN 缓存服务器上。这种技术也被称为“DNS 重定向”。DNS 服务器不是为每个请求返回相同的 IP 地址，计算出距离这个用户最近的 CDN 服务器，于是返回一个悉尼 CDN 节点的 IP 地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。</li><li>再次解析后，浏览器得到 CDN 缓存服务器的实际 IP 地址，向缓存服务器发起请求。</li><li>缓存服务器根据浏览器提供的域名，通过内部 DNS 解析得到此域名源服务器的真实 IP 地址，再由缓存服务器向该服务器发起访问请求。</li><li>缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从 CDN 缓存服务器中被返回。CDN 不会永久保存数据，可以设置 CDN 的刷新频率，来达到数据的更新。</li><li>浏览器得到由缓存服务器发回的数据，并将其显示出来。</li></ol><h3 id="技术手段"><a href="#技术手段" class="headerlink" title="技术手段"></a>技术手段</h3><ol><li>高速缓存: 适用于静态内容</li><li>镜像站点服务器: 让内容直截了当地进行分布，适用于静态和准动态的数据同步。</li></ol><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><blockquote><p>当用户访问加入 CDN 服务的网站时，域名解析请求将最终交给全局负载均衡 DNS 进行处理。全局负载均衡 DNS 通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。同时，它还与分布在世界各地的所有 CDN 节点保持通信，搜集各节点的通信状态，确保不将用户的请求分配到不可用的 CDN 节点上，实际上是通过 DNS 做全局负载均衡。</p><p>CDN 节点组成: </p><ol><li>负载均衡设备: 负责每个节点中各个 Cache 的负载均衡，保证节点的工作效率；同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载 DNS 的通信，实现整个系统的负载均衡。</li><li>高速缓存服务器: 负责存储客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。</li></ol></blockquote><ol><li>中心: 指 CDN 网管中心和 DNS 重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房。</li><li>边缘: 指异地节点，CDN 分发的载体，主要由 Cache 和负载均衡器等组成。</li></ol><h2 id="动态-CDN-特点"><a href="#动态-CDN-特点" class="headerlink" title="动态 CDN 特点"></a>动态 CDN 特点</h2><blockquote><p>通过智能路由、多线回源、协议优化、数据压缩等技术，达到加速目的</p><ul><li>首页加载速度更快</li><li>更可靠的连接（只要负责连接边缘服务器，如果直接走回源线路的话，线路会很长，不可靠）</li></ul></blockquote><p><img src="/images/engineering/cdn_1.png" alt=""></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="CDN-能缓存接口吗"><a href="#CDN-能缓存接口吗" class="headerlink" title="CDN 能缓存接口吗"></a>CDN 能缓存接口吗</h3><ol><li>在一般情况下，CDN 只会对 HTTP GET 请求的 URL 进行缓存，而 HTTP POST 请求的数据是不进行缓存的。因为 HTTP POST 请求中的数据有可能是用户的个人信息或者其他重要数据，一旦被缓存下来就会存在安全问题。</li><li>在一些特殊情况下，CDN 也可以缓存服务接口。比如，当 CDN 作为反向代理服务器（Reverse Proxy）时，CDN 会缓存后端服务的响应内容并且将响应结果返回给用户，这时候 CDN 就会缓存服务接口。</li></ol><h3 id="图片各格式的区别"><a href="#图片各格式的区别" class="headerlink" title="图片各格式的区别"></a>图片各格式的区别</h3><ol><li>PNG: PNG 是一种无损压缩格式，支持透明度和高品质图像，最适合用于对精度和细节要求较高的图像，但文件体积较大。</li><li>JPG/JPEG: JPG 是一种有损压缩格式，可以压缩图像文件尺寸而不影响图像质量，适用于对文件大小有限制的情况，但对于较大的文件，它可能会导致失真。不支持透明度</li><li>BMP: BMP 是一种无压缩的图像格式，可以保持完美的图像质量，但是文件体积很大，适合用于处理要求高质量的文件。</li><li>SVG: SVG 是一种矢量图形语言，可无限缩放而不失真，支持亚像素级渲染，适合用于网页与移动设备。</li><li>TIFF: TIFF 是一种无损压缩格式，支持多种色彩模式，可用于高品质打印和艺术品的制作，但文件体积较大。</li><li>WebP: 由谷歌开发的 WebP 格式是一种无损压缩图像格式，与 JPG 相比，可大幅减少文件体积，但在一些老旧的浏览器中可能不受支持。<ul><li>有损 WebP 压缩使用预测编码对图像进行编码，相同 VP8 视频编解码器用于压缩视频中的关键帧的方法。预测编码使用相邻像素块中的值来预测值在一个块中，然后只编码差异。</li><li>无损 WebP 压缩使用已经看到的图像片段，以便精确重建新像素。如果没有，它也可以使用本地调色板 找到有趣的匹配。</li></ul></li><li>GIF: GIF 是一种支持动画和透明度的图像格式，对于一些小的简单动画效果，它是最好的选择，但对于大多数图像类型，它可能会有限制和色彩限制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/articles/engineering/nginx/"/>
      <url>/articles/engineering/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote><p>Nginx 是一个轻量级/高性能的反向代理 Web 服务器，由 C 语言写的，速度快、性能优秀。主要功能有反向代理、负载均衡、配置 SSL 证书、防盗链、解决跨域问题、缓存、限流、动静资源分离等等</p></blockquote><h3 id="nginx-作用体现"><a href="#nginx-作用体现" class="headerlink" title="nginx 作用体现"></a>nginx 作用体现</h3><blockquote><p>提升系统整体性能</p></blockquote><h4 id="动静资源分离"><a href="#动静资源分离" class="headerlink" title="动静资源分离"></a>动静资源分离</h4><blockquote><p>一般静态资源文件都放在 Nginx 服务器中，当 Nginx 接收到了获取静态资源文件的请求，就直接在 Nginx 服务器中把放进去的静态资源返回，而不用真正到达后端接口，效率非常高</p></blockquote><h4 id="请求转发分配"><a href="#请求转发分配" class="headerlink" title="请求转发分配"></a>请求转发分配</h4><blockquote><p>所有的请求都经过 Nginx，由 Nginx 决定分发到哪个端口程序上，这样即使后端有很多个 Java 程序，但对于前端来说，是无感知的，好比后台只有一个项目在跑</p></blockquote><h4 id="Keepalive-保活"><a href="#Keepalive-保活" class="headerlink" title="Keepalive 保活"></a>Keepalive 保活</h4><blockquote><p>Nginx 会不断监听后端程序的接口 (健康检查)，看该服务是不是在正常运行，万一有一个程序挂了，那么 Nginx 就不会把前端发来的请求转发给这个接口，确保后端服务的高可用性和稳定性</p></blockquote><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><blockquote><p>匹配用户请求中的 URI，优先级为: <code>=</code> &gt; <code>完整路径</code> &gt; <code>^~</code> &gt; <code>~</code>、<code>~*</code> &gt; <code>部分起始路径</code> &gt; <code>/</code></p><ul><li><code>=</code>: 精确匹配，优先级最高。如果找到了这个精确匹配，则停止查找</li><li><code>^~</code>: URI 以某个常规字符串开头，不是正则匹配</li><li><code>~</code>: 区分大小写的正则匹配</li><li><code>~*</code>: 不区分大小写的正则匹配</li><li><code>/</code>: 通用匹配, 优先级最低。任何请求都会匹配到这个规则</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location 前缀字符串  URL &#123;</span><br><span class="line">    [ 配置 ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-break"><a href="#if-break" class="headerlink" title="if/break"></a>if/break</h3><blockquote><p>判断语句，if 的上下文为 server、location；break 的上下文为 server、location、if</p><ul><li><code>=</code>、<code>!=</code>: 变量跟字符串的比较</li><li><code>~</code>、<code>~*</code>: 变量与正则表达式匹配，区分/不区分 大小写</li><li><code>-f</code>、<code>!-f</code>: 检查文件是否存在</li><li><code>-d</code>、<code>!-d</code>: 检查目录是否存在</li><li><code>-e</code>、<code>!-e</code>: 检查文件、目录或符号链接的存在性</li><li><code>-x</code>、<code>!-x</code>: 检查可执行文件</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用户代理 User-Agent 包含&quot;MSIE&quot;，rewrite 请求到 /msie/ 目录下。通过正则匹配的捕获可以用 $1 $2 等使用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 cookie 匹配正则，设置变量 $id 等于匹配到的正则部分</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$http_cookie</span> ~* <span class="string">&quot;id=([^;]+)(?:;|$)&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$id</span> <span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果请求的文件存在，则开启缓存，并通过 break 停止后面的检查</span></span><br><span class="line"><span class="keyword">if</span> (-f <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">    expires max;</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果请求的文件、目录或符号链接都不存在，则用 rewrite 在 URI 头部添加 /index.php</span></span><br><span class="line"><span class="keyword">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">    rewrite ^/(.*)$ /index.php/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><blockquote><ul><li>重写的 URL 适用于每个匹配的 server 或 location 的请求</li><li>使用标准的 nginx 变量构建重写的 URL</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    <span class="comment"># 同时用于 HTTP 和 HTTPS 流量</span></span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.old-name.com;</span><br><span class="line">    <span class="comment"># 停止处理请求，直接返回 301 (Moved Permanently) 代码和指定的重写过的 URL 到客户端</span></span><br><span class="line">    <span class="built_in">return</span> 301 <span class="variable">$scheme</span>://www.new-name.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3><blockquote><p>改变部分或整个用户请求中的 URL</p><ul><li>通知客户端，请求的资源已经换地方了。例如网站改版后添加了 www 前缀，通过 rewrite 规则可以将所有请求导向新站点</li><li><p>控制 Nginx 中的处理流程。例如当需要动态生成内容时，将请求转发到应用程序服务器。try_files 指令经常用于这个目的</p></li><li><p>rewrite 指令只能返回代码 301 或 302。要返回其他代码，需要在 rewrite 指令后面包含 return 指令</p></li><li>rewrite 指令不一定会暂停 nginx 对请求的处理，因为它不一定会发送重定向到客户端。除非明确指出 (使用 flag 或 URL 的语法) 你希望 nginx 停止处理或发送重定向，否则它将在整个配置中运行，查找在重写模块中定义的指令 (break、if、return、rewrite 和 set)，并按顺序处理。如果重写的 URL 与 rewrite 模块中的后续指令匹配，nginx 会对重写的 URL 执行指定的操作 (通常会重新写入)</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    rewrite ^(/download/.*)/media/(\w+)\.?.*$ <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3 last;</span><br><span class="line">    rewrite ^(/download/.*)/audio/(\w+)\.?.*$ <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.ra  last;</span><br><span class="line">    <span class="built_in">return</span>  403;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它匹配以字符串 /download 开头的 URL，然后用 /mp3/ 替换在路径稍后的某个位置包含的 /media/ 或 /audio/ 目录，并添加适当的文件扩展名 .mp3 或 .ra。$1 和 $2 变量捕获不变的路径元素。例如，/download/cdn-west/media/file1 变为 /download/cdn-west/mp3/file1.mp3。如果文件名上有扩展名（例如.flv），表达式会将其剥离并用.mp3 替换</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex URL [flag];</span><br></pre></td></tr></table></figure><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><blockquote><ul><li>last: 停止处理当前的 ngx_http_rewrite_module 指令集，并开始对匹配更改后的 URI 的新 location 进行搜索 (再从 server 走一遍匹配流程)。此时对于当前 server 或 location 上下文，不再处理 ngx_http_rewrite_module 重写模块的指令</li><li>break: 停止处理当前的 ngx_http_rewrite_module 指令集</li><li>redirect: 返回包含 302 代码的临时重定向，在替换字符串不以 “<a href="http://”，“https://”">http://”，“https://”</a> 或 “$scheme” 开头时使用</li><li>permanent: 返回包含 301 代码的永久重定向</li></ul></blockquote><h3 id="try-files"><a href="#try-files" class="headerlink" title="try_files"></a>try_files</h3><blockquote><p>参数是一个或多个文件或目录的列表，以及最后面的 URI 参数</p><ul><li>Nginx 会按顺序检查文件及目录是否存在 (根据 root 和 alias 指令设置的参数构造完整的文件路径)，并用找到的第一个文件提供服务。在元素名后面添加斜杠 / 表示这个是目录。如果文件和目录都不存在，Nginx 会执行内部重定向，跳转到命令的最后一个 uri 参数定义的 URI 中</li><li>必须定义一个 location 块捕捉内部重定向。最后一个参数可以是命名过的 location，由初始符号（@）指示</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /images/default.gif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /images/default.gif &#123;</span><br><span class="line">    expires 30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果客户端请求的文件不存在，Nginx 会响应一个默认的 GIF 文件。假设客户请求 “<a href="http://www.domain.com/images/image1.gif”，Nginx">http://www.domain.com/images/image1.gif”，Nginx</a> 会首先通过用于这个 location 的 root 和 alias 指令，在本地目录中查找这个文件。如果“image1.gif”文件不存在，Nginx 会查找“image1.gif/”目录，如果都不存在，会重定向到“/images/default.gif”。这个值精确匹配后面的 location 指令，因此处理过程停止，Nginx 返回这个文件，并标注其缓存 30 秒</li></ul><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ol><li>正向代理: </li></ol><ul><li>防止服务端获取客户端的 ip 地址</li></ul><p><img src="/images/engineering/nginx_1.png" alt=""></p><ol><li>反向代理</li></ol><ul><li>防火墙: 应用不想直接暴露给客户端，通过 nginx 过滤掉没有权限或者非法的请求，来保障内部服务器的安全</li><li>负载均衡</li></ul><p><img src="/images/engineering/nginx_2.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  80;  // 本机ip下的端口</span><br><span class="line">  server_name  1.1.1.1;  // 本机ip</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://a.com:8080/;</span><br><span class="line">    root  html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><blockquote><p>当一个应用单位时间内访问量激增，服务器的带宽及性能受到影响，影响大到自身承受能力时，服务器就会宕机崩溃，可以通过 nginx 来转发请求给不同的程序应用来分担服务器压力</p></blockquote><h4 id="常见的负载均衡算法"><a href="#常见的负载均衡算法" class="headerlink" title="常见的负载均衡算法"></a>常见的负载均衡算法</h4><ol><li>轮询算法: 按顺序、平均地把每一条请求分发出去</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx.configupstream backserver &#123; server 192.168.0.1; server 192.168.0.2;&#125;</span><br></pre></td></tr></table></figure><ol><li>权重分配: 权重值高的分配请求也越多</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx.configupstream backserver &#123;server 192.168.0.1 weight=2;server 192.168.0.2 weight=8;&#125;</span><br></pre></td></tr></table></figure><ol><li>按用户端的 ip 进行 hash 运算分配</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line"> ip_hash;</span><br><span class="line"> server 192.168.0.11:88;</span><br><span class="line"> server 192.168.0.13:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    <span class="comment">#允许跨域请求的域，* 代表所有</span></span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> *;</span><br><span class="line">    <span class="comment">#允许请求的header</span></span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> *;</span><br><span class="line">    <span class="comment">#允许带上cookie请求</span></span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">    <span class="comment">#允许请求的方法，比如 GET,POST,PUT,DELETE</span></span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> *;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> 204;</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass http://192.168.1.12:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置白名单"><a href="#配置白名单" class="headerlink" title="配置白名单"></a>配置白名单</h3><blockquote><p>可以配置 nginx 的白名单，规定有哪些 ip 可以访问你的服务器，防爬虫</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    deny  192.168.0.1; // 禁止该ip访问    deny  all; // 禁止所有</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="variable">$ip_whitelist</span> = 0 )&#123;</span><br><span class="line">      <span class="built_in">return</span> 403; //不在白名单返回 403</span><br><span class="line">    &#125;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配-PC-与移动端环境"><a href="#适配-PC-与移动端环境" class="headerlink" title="适配 PC 与移动端环境"></a>适配 PC 与移动端环境</h3><blockquote><p>当用户从移动端打开 PC 端 baidu.com 的场景时，将自动跳转指移动端 m.baidu.com，本质上是 Nginx 可以通过内置变量 <code>$http_user_agent</code> ，获取到请求客户端的 userAgent，从而知道当前用户当前终端是移动端还是 PC，进而重定向到 H5 站还是 PC 站</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    //移动、pc设备agent获取</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">&#x27;(Android|webOS|iPhone)&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">set</span> <span class="variable">$mobile_request</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$mobile_request</span> = <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">      rewrite ^.+ http://m.baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-Gzip"><a href="#配置-Gzip" class="headerlink" title="配置 Gzip"></a>配置 Gzip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  gzip on; //启动</span><br><span class="line">  gzip_buffers 32 4K;</span><br><span class="line">  gzip_comp_level 6; //压缩级别，1-10，数字越大压缩的越好</span><br><span class="line">  gzip_min_length 100; //不压缩临界值，大于100的才压缩，一般不用改</span><br><span class="line">  gzip_types application/javascript text/css text/bash;</span><br><span class="line">  gzip_disable <span class="string">&quot;MSIE [1-6].&quot;</span>; // IE6对Gzip不友好</span><br><span class="line">  gzip_vary on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><blockquote><p>用户端的大量请求 (突发流量)会进入 nginx 内维护的漏桶中，漏桶会按照已定义的固定的速率给服务器分发请求，正常的请求在服务器处理完后会正常返回给用户端。如果水流过大 (突发流量过大)时，漏桶内的水会溢出，这时 nginx 就把这些溢出的水 (流量)直接丢弃，也就是给用户端返回错误信息</p></blockquote><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><blockquote><p>用户端发请求给 nginx 时，每个请求都要去 nginx 的令牌桶中取一个令牌，令牌桶的容量可设定。如果某个请求成功取到了令牌，那么 nginx 就会把这个请求转发到服务器上进行处理。如果令牌桶已空，请求在 nginx 令牌桶中取不到令牌，那么 nginx 会直接返回该请求，也就是给用户端返回错误信息</p></blockquote><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="vpn-和-服务器代理"><a href="#vpn-和-服务器代理" class="headerlink" title="vpn 和 服务器代理"></a>vpn 和 服务器代理</h3><ol><li>vpn 是怎么实现在家也能连到公司内网的</li></ol><ul><li>vpn 代理是通过隧道技术在公共网络上模拟出一条点到点的逻辑专线，在公网上建立一条专门的隧道，从而达到安全数据传输的目的。需要用户端和服务端都部署和配置专门的 vpn 设备，即 vpn 网关，例如路由器式 vpn、交换机式 vpn</li></ul><ol><li>vpn 设计与实现</li></ol><ul><li>vpn 最主要的技术就是隧道技术，用另一种协议去封装当前正在使用的协议。隧道协议分为第二、第三层隧道协议，第二层隧道协议 (如 L2TP、PPTP、L2F 等) 工作在 OSI 体系结构的第二层 (数据链路层)；第三层隧道协议 (如 IPSec、GRE 等) 工作在 OSI 体系结构的第三层 (网络层)，这两个协议会在网络层封装完 IP 头后，再封装 IPSec 或者 GRE 头，并进行信息加密，这是代理服务器不会做的。然后再交由网络接口层添加 mac 头再丢到公网中，这样公网就认得你的 ip 并且能找到你公司内网前架设的 vpn 网关</li><li>vpn 设备还会使用常用加解密技术，例如对称密钥加密和非对称密钥加密组合使用，例如用 https 的 TLS 加密技术</li><li>密钥管理技术和身份认证及访问控制技术的支持</li></ul><ol><li>代理服务器和 vpn 有什么不一样</li></ol><ul><li>匿名性不同。虽然它们都位于请求的中间，都隐藏了 IP 地址，并且都将信息转发。主要区别在于 vpn 需要隧道过程，该过程建立了到 vpn 服务器的直接且不可穿透的连接。代理只是一个开放的端口，是任何人都可以连接到的单个 IP 地址</li><li>安全性不同。vpn 会加密数据信息，代理服务器不会，因此 vpn 更加私有，连接不会被穿透，是一个开在公网上的封闭系统</li><li>运行级别不同。vpn 是运行在操作系统上，由操作系统内核封装，重定向请求流量。代理服务器是软件级别，处于用户态</li><li>速度不同。vpn 涉及加密解密，数据封装，速度较慢，但因其安全性，价格成本会更高</li></ul><h3 id="nginx-配置-https"><a href="#nginx-配置-https" class="headerlink" title="nginx 配置 https"></a>nginx 配置 https</h3><blockquote><p>Nginx 常用来配置 Https 认证，主要有两个步骤: 签署第三方可信任的 SSL 证书 和 配置 HTTPS</p></blockquote><h4 id="签署第三方-SSL"><a href="#签署第三方-SSL" class="headerlink" title="签署第三方 SSL"></a>签署第三方 SSL</h4><blockquote><p>配置 https 要用到私钥 .key 文件和 .crt 证书文件，而申请证书文件的时候要用到 .csr 文件</p></blockquote><ol><li>配置 https</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  <span class="comment">#ssl参数</span></span><br><span class="line">  listen   443 ssl; //监听443端口，443端口是https的默认端口。80为http的默认端口</span><br><span class="line">  server_name  example.com;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#证书文件</span></span><br><span class="line">  ssl_certificate     example.com.crt; // 证书的绝对路径</span><br><span class="line"></span><br><span class="line">  <span class="comment">#私钥文件</span></span><br><span class="line">  ssl_certificate_key   example.com.key;  // 密钥的绝对路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端设计模式</title>
      <link href="/articles/engineering/designMode/"/>
      <url>/articles/engineering/designMode/</url>
      
        <content type="html"><![CDATA[<blockquote><p>针对设计问题的通用解决方案<br>为什么要学设计模式</p><ul><li>利于代码复用</li><li>利于代码稳定可拓展</li><li>利于代码可读性提升</li></ul><p>什么时候需要设计模式</p><ul><li>优先考虑全局设计</li><li>合理权衡使用需求和维护成本</li></ul></blockquote><h2 id="五种设计原则"><a href="#五种设计原则" class="headerlink" title="五种设计原则"></a>五种设计原则</h2><p><img src="/images/engineering/dMode_1.png" alt=""></p><h3 id="OCP"><a href="#OCP" class="headerlink" title="OCP"></a>OCP</h3><blockquote><p>开闭原则 (Open Closed Principle)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标: 已有的场景下，对于需要拓展的功能进行开放、拒绝直接的对于系统功能进行修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sprint1 - 中秋节活动 吃鸡高亮 + LOL要弹出折扣</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="keyword">if</span> (game === <span class="string">&quot;PUBG&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 高亮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// event</span></span><br><span class="line"><span class="keyword">if</span> (game === <span class="string">&quot;LOL&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 弹出折扣框</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 付款</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sprint2 - 要对部分游戏置灰 + 付款页面要显示停止发售</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="keyword">if</span> (game === <span class="string">&quot;PUBG&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 高亮</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (game === <span class="string">&quot;AAA&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 灰色</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// event</span></span><br><span class="line"><span class="keyword">if</span> (game === <span class="string">&quot;LOL&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 弹出折扣框</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (game === <span class="string">&quot;AAA&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// break + 提示停止发售</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 付款</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构 =&gt; 核心化</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="title function_">gameManager</span>(game).<span class="title function_">setColor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// event</span></span><br><span class="line"><span class="title function_">gameManager</span>(game).<span class="title function_">openDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// game库</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gameManager</span>(<span class="params">game</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;game&#125;</span>Manager`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导引</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LOLManager</span> = &#123;</span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">openDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 折扣</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PUBGManager</span> = &#123;</span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 高亮</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">openDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 付款</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构2</span></span><br><span class="line"><span class="comment">// 默认逻辑抽离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">game</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 设置颜色</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">openDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LOL</span> <span class="keyword">extends</span> <span class="title class_ inherited__">game</span> &#123;</span><br><span class="line">  <span class="title function_">openDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 折扣</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PUBG</span> <span class="keyword">extends</span> <span class="title class_ inherited__">game</span> &#123;</span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 高亮</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; yunying@2000@cn@zw =&gt; 中国 爪哇 2000年 云隐</span></span><br><span class="line"><span class="comment">// function = 拆分 + 排序 + 翻译 =&gt; formatter() + spliter() + sorter() + tranlater()</span></span><br><span class="line"><span class="comment">// =&gt; 函数式编程</span></span><br></pre></td></tr></table></figure><h3 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h3><blockquote><p>单一职责 (Single Responsibility Principle)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SRP - 通过解耦让每一个职责更加的独立</span></span><br><span class="line"><span class="comment">// 目标: 一个功能模块只做一件事情</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// game store</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PUBGManager</span> &#123;</span><br><span class="line">  <span class="title function_">openDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 弹框</span></span><br><span class="line">    <span class="comment">// 计算金额</span></span><br><span class="line">    <span class="title function_">setPrice</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = <span class="keyword">new</span> <span class="title class_">PUBGManager</span>();</span><br><span class="line">game.<span class="title function_">openDialog</span>(); <span class="comment">// 弹框 &lt;=&gt; 计算金额 两个模块存在功能上的耦合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构</span></span><br><span class="line"><span class="comment">// gameManager.js - 业务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PUBGManager</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">command</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">command</span> = command;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">openDialog</span>(<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">command</span>.<span class="title function_">setPrice</span>(price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optManager.js - 底层库</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriceManager</span> &#123;</span><br><span class="line">  <span class="title function_">setPrice</span>(<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算金额</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> exe = <span class="keyword">new</span> <span class="title class_">PriceManager</span>();</span><br><span class="line"><span class="keyword">const</span> game1 = <span class="keyword">new</span> <span class="title class_">PUBGManager</span>(exe);</span><br><span class="line"></span><br><span class="line">game1.<span class="title function_">openDialog</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dialog弹框 =&gt; slots(HOC) / decorator / wrapper</span></span><br></pre></td></tr></table></figure><h3 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a>DIP</h3><blockquote><p>依赖倒置 (Dependency Inversion Principle)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标: 上层应用面向抽象进行coding，而不是面相实现 =&gt; 降低需求与实现的耦合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求 - 分享功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">share</span> = <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">  <span class="title function_">shareTo</span>(<span class="params">platform</span>) &#123;</span><br><span class="line">    <span class="comment">// 分享</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line">store.<span class="property">share</span>.<span class="title function_">shareTo</span>(<span class="string">&quot;wx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 评分功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">share</span> = <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rate</span> = <span class="keyword">new</span> <span class="title class_">Rate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">  <span class="title function_">shareTo</span>(<span class="params">platform</span>) &#123;</span><br><span class="line">    <span class="comment">// 分享</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rate</span> &#123;</span><br><span class="line">  <span class="title function_">star</span>(<span class="params">stars</span>) &#123;</span><br><span class="line">    <span class="comment">// 评分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="property">rate</span>.<span class="title function_">star</span>(<span class="string">&quot;wx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标: 底层不改变 + 动态挂载</span></span><br><span class="line"><span class="comment">// 重构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rate</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化动作</span></span><br><span class="line">  <span class="title function_">init</span>(<span class="params">store</span>) &#123;</span><br><span class="line">    store.<span class="property">rate</span> = <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">store</span>(<span class="params">stars</span>) &#123;</span><br><span class="line">    <span class="comment">// 评分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化动作</span></span><br><span class="line">  <span class="title function_">init</span>(<span class="params">store</span>) &#123;</span><br><span class="line">    store.<span class="property">share</span> = <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shareTo</span>(<span class="params">platform</span>) &#123;</span><br><span class="line">    <span class="comment">// 分享</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">  <span class="comment">// 维护模块名单</span></span><br><span class="line">  <span class="keyword">static</span> modules = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历名单 + 做初始化挂载</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable language_">module</span> <span class="keyword">of</span> <span class="title class_">Store</span>.<span class="property">module</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">      <span class="variable language_">module</span>.<span class="title function_">init</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供注入功能模块</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">inject</span>(<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="title class_">Store</span>.<span class="property">modules</span>.<span class="title function_">set</span>(<span class="variable language_">module</span>.<span class="property">constructor</span>.<span class="property">name</span>, <span class="variable language_">module</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次注册所有模块</span></span><br><span class="line"><span class="keyword">const</span> rate = <span class="keyword">new</span> <span class="title class_">Rate</span>();</span><br><span class="line"><span class="title class_">Store</span>.<span class="title function_">inject</span>(rate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化商城</span></span><br><span class="line"><span class="comment">// const store = new Store();</span></span><br><span class="line">store.<span class="property">rate</span>.<span class="title function_">start</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集</span></span><br></pre></td></tr></table></figure><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><blockquote><p>接口隔离 (Interface Segregation Principle)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标: 多个专业接口比单个胖接口好用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏中台 - 快速生产游戏</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 跑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shot</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 射击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">mega</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 大招</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PUBG、LOL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PUBG</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// pubg contructor</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LOL</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// lol contructor</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pubg = <span class="keyword">new</span> <span class="title function_">PUBG</span>(<span class="string">&quot;pubg&quot;</span>);</span><br><span class="line">pubg.<span class="title function_">run</span>();</span><br><span class="line">pubg.<span class="title function_">shot</span>();</span><br><span class="line">pubg.<span class="title function_">mega</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构 - 用多个接口替代，每个接口服务于一个子模块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 跑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPS</span> &#123;</span><br><span class="line">  <span class="title function_">aim</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MOBA</span> &#123;</span><br><span class="line">  <span class="title function_">TP</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PUBG</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line">  <span class="title function_">shot</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 层级深度 + 划分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构组件划分 + 状态机 / 命名空间</span></span><br></pre></td></tr></table></figure><h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><blockquote><p>里氏替换(Liskov Substitution Principle)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类可以覆盖父类 =&gt; 父类能出现的地方，子类一定能出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sprint1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 开机</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shutdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 关机</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 开始游戏</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">game.<span class="title function_">play</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sprint2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobileGame</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line">  <span class="title function_">tombStore</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 移动端游戏</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mobile = <span class="keyword">new</span> <span class="title class_">MobileGame</span>();</span><br><span class="line">mobile.<span class="title function_">play</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 开机</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shutdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 关机</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobileGame</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line">  <span class="title function_">tombStore</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 移动端游戏</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCGame</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line">  <span class="title function_">speed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 加速器</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// PC游戏</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护核心 =&gt; 抽离妥协 增加分层</span></span><br></pre></td></tr></table></figure><h2 id="三类设计模式"><a href="#三类设计模式" class="headerlink" title="三类设计模式"></a>三类设计模式</h2><p><img src="/images/engineering/dMode_2.png" alt=""></p><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><blockquote><p>全局只有一个实例，和状态相关</p></blockquote><ol><li>工厂模式: 批量生产同类型应用来满足频繁使用同一类型素材时</li><li>建造者模式: 需要将元功能模块化解耦，并且需要频繁编排时</li><li>单例模式: 当全局只有一个实例，注重的是一体化和状态统一。<code>可使用代理来实现</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">singleton</span>(<span class="params">className</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ins;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(className, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ins) &#123;</span><br><span class="line">        ins = <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>业务场景</p></blockquote><ul><li>工厂: 生产不同类型的按钮</li><li>建造者: Header 组件，包含 title、button、breadcum，生产多种不同元素的组合</li><li>单例: router、store</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能: 创建元素</span></span><br><span class="line"><span class="comment">// 目的:  规范创建步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="comment">// 隐藏创建过程、暴露共同接口</span></span><br><span class="line"><span class="comment">// 需求: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">  <span class="title function_">create</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Game</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shop = <span class="keyword">new</span> <span class="title class_">Shop</span>();</span><br><span class="line"><span class="keyword">const</span> pubg = <span class="keyword">new</span> <span class="title class_">Game</span>(<span class="string">&quot;pubg&quot;</span>);</span><br><span class="line"></span><br><span class="line">pubg.<span class="title function_">init</span>();</span><br><span class="line">pubg.<span class="title function_">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建造者</span></span><br><span class="line"><span class="comment">// 拆分简单模块、独立运行 =&gt; 注重过程与搭配</span></span><br><span class="line"><span class="comment">// 需求: </span></span><br><span class="line"><span class="comment">// 优惠套餐，商品 + 皮肤 进行打折售卖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;game: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skin</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;skin: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">package</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">create</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">package</span> = <span class="keyword">new</span> <span class="title class_">PackageBuilder</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getGamePackage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">package</span>.<span class="title function_">getPackage</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PackageBuilder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">game</span> = <span class="keyword">new</span> <span class="title class_">Product</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">skin</span> = <span class="keyword">new</span> <span class="title class_">Skin</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getPackage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">game</span>.<span class="title function_">init</span>() + <span class="variable language_">this</span>.<span class="property">skin</span>.<span class="title function_">init</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式</span></span><br><span class="line"><span class="comment">// 全局只有一个实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayStation</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shutdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;off&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="title class_">PlayStation</span>.<span class="property">instance</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="title class_">PlayStation</span>.<span class="property">getInstance</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">PlayStation</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="title class_">PlayStation</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">PlayStation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">PlayStation</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ps = <span class="title class_">PlayStation</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">ps.<span class="title function_">play</span>();</span><br><span class="line">ps.<span class="title function_">shutdown</span>();</span><br></pre></td></tr></table></figure><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><blockquote><p>不影响用户体验</p></blockquote><ol><li>适配器模式: 中间参数转换，兼容\适配已有方案时</li><li>装饰器模式: 在已有方案中批量提供\提升相应功能时</li><li>代理模式: 把调用方和被调用方分离，不直接产生调用关系时</li></ol><blockquote><p>业务场景</p></blockquote><ul><li>适配器: 需求中添加适配器做数据结构的转换</li><li>装饰器: title、button、breadcum 三个组件同时都具有发生改变触发页面刷新的功能</li><li>代理: ul 标签监听 li 标签，代理到 ul 上监听</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能:  优化结构实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器模式</span></span><br><span class="line"><span class="comment">// 适配独立模块，保证模块间的独立解耦以及连接兼容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HKDevice</span> &#123;</span><br><span class="line">  <span class="title function_">getPlug</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;港行插头&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">plug</span> = <span class="keyword">new</span> <span class="title class_">HKDevice</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getPlug</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">plug</span>.<span class="title function_">getPlug</span>() + <span class="string">&quot;+ 插头转接器&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">target.<span class="title function_">getPlug</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器模式</span></span><br><span class="line"><span class="comment">// 动态将责任附加在对象上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;</span><br><span class="line">  <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;PlayStation4&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">  <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;iphone13&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">device</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">device</span> = device;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">device</span>.<span class="title function_">create</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>(<span class="variable language_">this</span>.<span class="property">device</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params">device</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(device + <span class="string">&quot;pro&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> device = <span class="keyword">new</span> <span class="title class_">Device</span>();</span><br><span class="line">device.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newDevice = <span class="keyword">new</span> <span class="title class_">Decorator</span>(device);</span><br><span class="line">newDevice.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理模式</span></span><br><span class="line"><span class="comment">// 使用代理人来替代原始对象</span></span><br><span class="line"><span class="comment">// 游戏防沉迷</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;playing&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameProxy</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">player</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span> = player;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">player</span>.<span class="property">age</span> &lt; <span class="number">16</span> ? <span class="string">&quot;too young to play&quot;</span> : <span class="keyword">new</span> <span class="title class_">Game</span>().<span class="title function_">play</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><blockquote><p>节点互斥、前后链式相连</p></blockquote><ol><li>命令模式: 具有发出方 + 媒介 + 接收方 的完整流程时</li><li>模板模式: 对于基础说明书，进行的一次实际业务结合操作时</li><li>观察者模式: 通过观察者，可以让被观察者实时接收消息，平且触发一定的业务操作时</li><li>职责链模式: 独立指责单元链式执行，逐步操作流程时</li></ol><blockquote><p>业务场景</p></blockquote><ul><li>命令: 组件 A 通知组件 B，媒介抽象为数据处理中间层</li><li>模板: echarts、canvas、config…</li><li>观察者: 输入框变化，下拉框实时更新选项</li><li>职责链: 提交表单，链式调用 validate，依次执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同对象之间行为逻辑的抽象化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令模式</span></span><br><span class="line"><span class="comment">// 请求以命令的形式包裹在对象中，并传给调用对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 角色命令接受者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">  <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始奔跑&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">command</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">command</span> = command;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">command</span>.<span class="title function_">execute</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span> = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="title function_">execute</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> soldier = <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> <span class="title class_">Command</span>(soldier);</span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> <span class="title class_">Operator</span>(order);</span><br><span class="line">player.<span class="title function_">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板模式</span></span><br><span class="line"><span class="comment">// 模板中，定义好个方法的步骤，方法本身更关注自己的事情</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executePipeLine</span>) &#123;</span><br><span class="line">    <span class="comment">// executePipeLine</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">powerOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">login</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;登录账号&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clickStart</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始游戏&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enterGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;进入战场&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">powerOn</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">login</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clickStart</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">enterGame</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="comment">// 当一个属性发生改变时，观察者会连续引发所有的相关类型的状态改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MediaCenter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">attach</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifyAllobservers</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notifyAllobservers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ob</span>) =&gt;</span> &#123;</span><br><span class="line">      ob.<span class="title function_">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, center</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">center</span> = center;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">center</span>.<span class="title function_">attach</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">state</span>: <span class="variable language_">this</span>.<span class="property">center</span>.<span class="title function_">getState</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> center = <span class="keyword">new</span> <span class="title class_">MediaCenter</span>();</span><br><span class="line"><span class="keyword">const</span> ps = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;ps&quot;</span>, center);</span><br><span class="line"></span><br><span class="line">center.<span class="title function_">setState</span>(<span class="string">&quot;on&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 职责链</span></span><br><span class="line"><span class="comment">// 1. 链式调用 2. 职责独立 3. 顺序执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nextAction</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setNextAction</span>(<span class="params">action</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nextAction</span> = action;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;请审批&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nextAction</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">nextAction</span>.<span class="title function_">handle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dad = <span class="keyword">new</span> <span class="title class_">Action</span>(<span class="string">&quot;爸&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> mom = <span class="keyword">new</span> <span class="title class_">Action</span>(<span class="string">&quot;妈&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> wife = <span class="keyword">new</span> <span class="title class_">Action</span>(<span class="string">&quot;夫人&quot;</span>);</span><br><span class="line"></span><br><span class="line">dad.<span class="title function_">setNextAction</span>(mom);</span><br><span class="line">mom.<span class="title function_">setNextAction</span>(wife);</span><br><span class="line"></span><br><span class="line">dad.<span class="title function_">handle</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// generator()</span></span><br><span class="line"><span class="comment">// .next()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 19 新特性</title>
      <link href="/articles/react/v19/"/>
      <url>/articles/react/v19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考 React 19 <a href="https://zh-hans.react.dev/blog/2024/12/05/react-19">官网</a></p></blockquote><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><blockquote><p>支持异步函数</p></blockquote><ul><li>待定状态: 提供一个待定状态，该状态在请求开始时启动，并在最终状态更新提交时自动重置</li><li>乐观更新: 支持新的 useOptimistic Hook，可以在请求提交时向用户显示即时反馈</li><li>错误处理: 当请求失败时，可以显示错误边界，并自动将乐观更新恢复到其原始值</li><li>表单: <form> 元素支持将函数传递给 action 和 formAction 属性。将函数传递给 action 属性默认使用 Actions，并在提交后自动重置表单</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用表单的 Actions 和 useActionState</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChangeName</span>(<span class="params">&#123; name, setName &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [error, submitAction, isPending] = <span class="title function_">useActionState</span>(</span><br><span class="line">    <span class="title function_">async</span> (previousState, formData) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> error = <span class="keyword">await</span> <span class="title function_">updateName</span>(formData.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 你可以返回操作的任何结果。</span></span><br><span class="line">        <span class="comment">// 这里，我们只返回错误。</span></span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理成功的情况。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&#123;submitAction&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">disabled</span>=<span class="string">&#123;isPending&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Update</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;error &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;error&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useActionState"><a href="#useActionState" class="headerlink" title="useActionState"></a>useActionState</h3><blockquote><p>接受一个函数 (Action)，并返回一个被包装的用于调用的 Action。这是因为 Actions 是可以组合的。当调用被包装的 Action 时，useActionState 将返回 Action 的最后结果作为 data，以及 Action 的待定状态作为 pending</p></blockquote><h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><blockquote><p>新 <code>&lt;form&gt;</code> 功能集成在 react-dom 中。我们已经添加了对将函数作为 <code>&lt;form&gt;</code>、<code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素的 action 和 formAction 属性的支持，以便使用 Actions 自动提交表单<br>当 <code>&lt;form&gt;</code> Action 成功时，React 将自动为非受控组件重置表单。如果需要手动重置 <code>&lt;form&gt;</code>，你可以调用新的 requestFormReset React DOM API</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&#123;actionFunction&#125;&gt;</span><br></pre></td></tr></table></figure><h3 id="useFormStatus"><a href="#useFormStatus" class="headerlink" title="useFormStatus"></a>useFormStatus</h3><blockquote><p>在设计系统中，常常需要编写设计一类能够访问其所在的 <code>&lt;form&gt;</code> 的信息而无需将属性传递到组件内的组件。这可以通过 Context 来实现，但为了使这类常见情况更简单，我们添加了一个新的 Hook useFormStatus</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useFormStatus &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DesignButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pending &#125; = <span class="title function_">useFormStatus</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">disabled</span>=<span class="string">&#123;pending&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useOptimistic"><a href="#useOptimistic" class="headerlink" title="useOptimistic"></a>useOptimistic</h3><blockquote><p>执行数据变更时的另一个常见 UI 模式是在异步请求进行时乐观地显示最终状态<br>useOptimistic 会在 updateName 请求进行时立即渲染 optimisticName。当更新完成或出错时，React 将自动切换回 currentName 值</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ChangeName</span>(<span class="params">&#123; currentName, onUpdateName &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [optimisticName, setOptimisticName] = <span class="title function_">useOptimistic</span>(currentName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">submitAction</span> = <span class="keyword">async</span> (<span class="params">formData</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> newName = formData.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="title function_">setOptimisticName</span>(newName);</span><br><span class="line">    <span class="keyword">const</span> updatedName = <span class="keyword">await</span> <span class="title function_">updateName</span>(newName);</span><br><span class="line">    <span class="title function_">onUpdateName</span>(updatedName);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&#123;submitAction&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your name is: &#123;optimisticName&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Change Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">name</span>=<span class="string">&quot;name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">disabled</span>=<span class="string">&#123;currentName</span> !== <span class="string">optimisticName&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><blockquote><p>在渲染中读取资源。例如，可以使用 use 读取一个 promise，React 将挂起，直到 promise 解析完成</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Comments</span>(<span class="params">&#123; commentsPromise &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// `use` 将被暂停直到 promise 被解决.</span></span><br><span class="line">  <span class="keyword">const</span> comments = <span class="title function_">use</span>(commentsPromise);</span><br><span class="line">  <span class="keyword">return</span> comments.<span class="title function_">map</span>(<span class="function">(<span class="params">comment</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;comment.id&#125;</span>&gt;</span>&#123;comment&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">&#123; commentsPromise &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 当“use”在注释中暂停时,</span></span><br><span class="line">  <span class="comment">// 将显示此悬念边界。</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Comments</span> <span class="attr">commentsPromise</span>=<span class="string">&#123;commentsPromise&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以在循环和条件语句（如 if）中调用 use。但需要注意的是，调用 use 的函数仍然必须是一个组件或 Hook</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ThemeContext</span> <span class="keyword">from</span> <span class="string">&quot;./ThemeContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Heading</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为过早的返回</span></span><br><span class="line">  <span class="comment">// 这里 useContext 无法正常工作。</span></span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">use</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">theme.color</span> &#125;&#125;&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取-context"><a href="#读取-context" class="headerlink" title="读取 context"></a>读取 context</h3><blockquote><p>当 context 被传递给 use 时，它的工作方式类似于 useContext。而 useContext 必须在组件的顶层调用，use 可以在条件语句如 if 和循环如 for 内调用。相比之下，use 比 useContext 更加灵活</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">use</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><blockquote><p>数据可以通过将 Promise 作为 prop 从 服务器组件 传递到 客户端组件，以从服务器流式传输到客户端</p></blockquote><div class="tip warning"><p>将来自服务器组件的 Promise 传递至客户端组件时，其解析值必须可序列化以在服务器和客户端之间传递。像函数这样的数据类型不可序列化，不能成为这种 Promise 的解析值</p></div><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchMessage &#125; <span class="keyword">from</span> <span class="string">&quot;./lib.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./message.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> messagePromise = <span class="title function_">fetchMessage</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">p</span>&gt;</span>waiting for message...<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Message</span> <span class="attr">messagePromise</span>=<span class="string">&#123;messagePromise&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>客户端组件将 从 prop 中接收到的 Promise 传递给 use API。这允许客户端组件从最初由服务器组件创建的 Promise 中读取值</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; use &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params">&#123; messagePromise &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> messageContent = <span class="title function_">use</span>(messagePromise);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is the message: &#123;messageContent&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rejected-Promise"><a href="#rejected-Promise" class="headerlink" title="rejected Promise"></a>rejected Promise</h3><blockquote><p>传递给 use 的 Promise 可能会被拒绝（rejected）。可以通过以下方式处理 rejected Promise</p></blockquote><div class="tip warning"><p>不能在 try-catch 块中调用 use</p></div><h4 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; use, <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ErrorBoundary</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-error-boundary&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">MessageContainer</span>(<span class="params">&#123; messagePromise &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">p</span>&gt;</span>⚠️Something went wrong<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">p</span>&gt;</span>⌛Downloading message...<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Message</span> <span class="attr">messagePromise</span>=<span class="string">&#123;messagePromise&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params">&#123; messagePromise &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> content = <span class="title function_">use</span>(messagePromise);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is the message: &#123;content&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise.catch"></a>Promise.catch</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./message.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> messagePromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>();</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;no new message found.&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">p</span>&gt;</span>waiting for message...<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Message</span> <span class="attr">messagePromise</span>=<span class="string">&#123;messagePromise&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-DOM-Static-APIs"><a href="#React-DOM-Static-APIs" class="headerlink" title="React DOM Static APIs"></a>React DOM Static APIs</h2><h3 id="prerender"><a href="#prerender" class="headerlink" title="prerender"></a>prerender</h3><blockquote><p>使用 Web 流将 React 树渲染为静态 HTML 字符串</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;prelude&#125; = <span class="keyword">await</span> <span class="title function_">prerender</span>(reactNode, options?)</span><br></pre></td></tr></table></figure><h3 id="prerenderToNodeStream"><a href="#prerenderToNodeStream" class="headerlink" title="prerenderToNodeStream"></a>prerenderToNodeStream</h3><blockquote><p>使用 Node.js 流将 React 树渲染为静态 HTML 字符串</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;prelude&#125; = <span class="keyword">await</span> <span class="title function_">prerenderToNodeStream</span>(reactNode, options?)</span><br></pre></td></tr></table></figure><h2 id="Server-Components"><a href="#Server-Components" class="headerlink" title="Server Components"></a>Server Components</h2><blockquote><p>一种全新的组件渲染模式，允许在打包前提前渲染组件，与客户端应用程序或 SSR 服务器在不同的环境中。这个独立的环境就是 React 服务器组件中的 “服务器”。服务器组件可以在你的 CI 服务器上在构建时运行一次，或者可以在每次请求时使用 web 服务器运行</p><ul><li>支持在构建时或请求时生成组件</li><li>无需引入额外的工具链，即可与现有 React 项目集成</li></ul></blockquote><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p>现在可以在函数组件中将 ref 作为 prop 进行访问，新的函数组件将不再需要 forwardRef。在未来的版本中，我们将弃用并移除 forwardRef<br>在类组件中，ref 不作为 props 传递，因为它们引用的是组件实例。这意味着，如果你在类组件中需要访问 ref，你需要使用 React.forwardRef 或者 React.createRef</p></blockquote><h3 id="函数清理"><a href="#函数清理" class="headerlink" title="函数清理"></a>函数清理</h3><blockquote><p>使得在 ref 改变时执行清理操作变得更加容易，当组件卸载时，React 将调用从 ref 回调返回的清理函数。例如，你可以在 ref 改变时取消订阅事件</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  ref=&#123;<span class="function">(<span class="params">ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ref 创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新特性: 当元素从 DOM 中被移除时</span></span><br><span class="line">    <span class="comment">// 返回一个清理函数来重置 ref</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ref cleanup</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h2 id="Document-Metadata"><a href="#Document-Metadata" class="headerlink" title="Document Metadata"></a>Document Metadata</h2><blockquote><p>支持 <code>&lt;title&gt;</code>、<code>&lt;meta&gt;</code> 和 <code>&lt;link&gt;</code> 等文档元数据标签。这些标签可直接在组件中声明，React 会自动将它们提升至 <code>&lt;head&gt;</code>，并确保与服务端渲染和客户端渲染兼容，简化 SEO 和元数据管理逻辑</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BlogPost</span>(<span class="params">&#123; post &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Josh&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;author&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://twitter.com/joshcstory/&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&#123;post.keywords&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Eee equals em-see-squared...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><blockquote><p>增强了样式表的加载管理，通过指定 precedence 属性，React 可以动态调整样式表的插入顺序，确保正确的样式覆盖</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&quot;loading...&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">precedence</span>=<span class="string">&quot;default&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">precedence</span>=<span class="string">&quot;high&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;foo-class bar-class&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;...&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentTwo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;...&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123; /* will be inserted between foo &amp; bar */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;baz&quot;</span> <span class="attr">precedence</span>=<span class="string">&quot;default&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Async-脚本"><a href="#Async-脚本" class="headerlink" title="Async 脚本"></a>Async 脚本</h2><blockquote><p>在 HTML 中，普通脚本 <code>(&lt;script src=&quot;...&quot;&gt;)</code> 和延迟脚本 <code>(&lt;script defer=&quot;&quot; src=&quot;...&quot;&gt;)</code> 按照文档顺序加载，这使得在组件树深处渲染这些类型的脚本变得具有挑战性。然而，异步脚本 <code>(&lt;script async=&quot;&quot; src=&quot;...&quot;&gt;)</code> 将去重并以任意顺序加载</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>=<span class="string">&#123;true&#125;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> /&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      Hello World</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><blockquote><p>preload 和 preinit 指定浏览器提前加载的资源</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; prefetchDNS, preconnect, preload, preinit &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// loads and executes this script eagerly</span></span><br><span class="line">  <span class="title function_">preinit</span>(<span class="string">&quot;https://.../path/to/some/script.js&quot;</span>, &#123; <span class="attr">as</span>: <span class="string">&quot;script&quot;</span> &#125;);</span><br><span class="line">  <span class="comment">// preloads this font</span></span><br><span class="line">  <span class="title function_">preload</span>(<span class="string">&quot;https://.../path/to/font.woff&quot;</span>, &#123; <span class="attr">as</span>: <span class="string">&quot;font&quot;</span> &#125;);</span><br><span class="line">  <span class="comment">// preloads this stylesheet</span></span><br><span class="line">  <span class="title function_">preload</span>(<span class="string">&quot;https://.../path/to/stylesheet.css&quot;</span>, &#123; <span class="attr">as</span>: <span class="string">&quot;style&quot;</span> &#125;);</span><br><span class="line">  <span class="comment">// when you may not actually request anything from this host</span></span><br><span class="line">  <span class="title function_">prefetchDNS</span>(<span class="string">&quot;https://...&quot;</span>);</span><br><span class="line">  <span class="comment">// when you will request something but aren&#x27;t sure what</span></span><br><span class="line">  <span class="title function_">preconnect</span>(<span class="string">&quot;https://...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a>错误报告</h2><blockquote><p>改进了错误日志系统，减少了重复日志，并添加了更详细的调试信息。例如，对于 SSR 和客户端渲染不匹配的问题，提供了差异化日志</p><ul><li><code>onCaughtError</code>: 当 React 在错误边界中捕获错误时调用</li><li><code>onUncaughtError</code>: 当抛出错误并且未被错误边界捕获时调用</li><li><code>onRecoverableError</code>: 当抛出错误并自动恢复时调用</li></ul></blockquote><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote><p>可以将 <code>&lt;Context&gt;</code> 渲染为提供者，无需再使用 <code>&lt;Context.Provider&gt;</code></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title function_">createContext</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">ThemeContext</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Immutable与Immer</title>
      <link href="/articles/react/immutable/"/>
      <url>/articles/react/immutable/</url>
      
        <content type="html"><![CDATA[<h2 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h2><blockquote><p>Javascript 中不可变的集合 <a href="https://immutable-js.com/">官网</a></p></blockquote><h3 id="immutable-引入"><a href="#immutable-引入" class="headerlink" title="immutable 引入"></a>immutable 引入</h3><blockquote><p>在 JavaScript 中有引用类型和基本类型。</p><ul><li>如果变量 a 是基本类型，将 a 赋值给变量 b，再修改 b 的值，则变量 a 不受影响</li><li>如果变量 a 是引用类型，将 a 赋值给变量 b， 则 b 与 a 是同一个对象的引用，若修改 b 对象的属性，a 对象的该属性也会跟着变化。</li></ul><p>解决方案就是深拷贝，比如最简单的方式<code>JSON.parse(JSON.stringify(obj))</code>。</p><p>但是深拷贝这种方式比较耗费性能（空间和时间），有没有折中的方案呢？即修改 b 的同时不影响 a，且比深拷贝节省性能。</p><p>所以有了 immutable.js，简单说就是按需深拷贝。</p><p>此外还有一个重要原因，开发中经常遇到函数带有副作用，副作用的函数修改了一个引用类型某个属性的值或者浅 copy 的问题，immutable 为此类问题提供了一种优雅的解决方案。</p></blockquote><h3 id="immutable-简介"><a href="#immutable-简介" class="headerlink" title="immutable 简介"></a>immutable 简介</h3><ul><li>Immutable Data 就是一旦创建，就不能再被更改的数据</li><li>对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象；</li><li>Immutable 实现的原理是 Persistent Data Structure（<strong>持久化数据结构</strong>）: <strong>也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变</strong>。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（<strong>结构共享</strong>），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</li></ul><p><img src="/images/react/immutable_1.gif" alt=""></p><h4 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h4><blockquote><p>Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的 map、filter、groupBy、reduce、find 函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> bar = foo;</span><br><span class="line">bar.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">a</span>.<span class="property">b</span>); <span class="comment">// 打印 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo === bar); <span class="comment">//  打印 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 immutable.js 后</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Immutable</span> <span class="keyword">from</span> <span class="string">&quot;immutable&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="title class_">Immutable</span>.<span class="title function_">fromJS</span>(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">setIn</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], <span class="number">2</span>); <span class="comment">// 使用 setIn 赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">getIn</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])); <span class="comment">// 使用 getIn 取值，打印 1</span></span><br><span class="line"><span class="comment">// 等价于 foo.getIn([&#x27;a&#x27;]).getIn([&#x27;b&#x27;])</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo === bar); <span class="comment">//  打印 false</span></span><br></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="Map-类型"><a href="#Map-类型" class="headerlink" title="Map 类型"></a>Map 类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是对象类型，在immutable中使用 Map</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Map</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;immutable&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="title class_">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;);</span><br><span class="line"><span class="comment">// 修改原对象的属性会产生一个新对象， 原对象保持不变</span></span><br><span class="line"><span class="keyword">const</span> map2 = map1.<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 .equals 方法比较</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1.<span class="title function_">equals</span>(map2)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 取值 .get</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1.<span class="title function_">get</span>(<span class="string">&quot;b&quot;</span>), map2.<span class="title function_">get</span>(<span class="string">&quot;b&quot;</span>)); <span class="comment">// 2, 50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1.<span class="title function_">get</span>(<span class="string">&quot;c&quot;</span>) === map2.<span class="title function_">get</span>(<span class="string">&quot;c&quot;</span>)); <span class="comment">// true， c 没有改变</span></span><br></pre></td></tr></table></figure><h4 id="不可变类型比较"><a href="#不可变类型比较" class="headerlink" title="不可变类型比较"></a>不可变类型比较</h4><p>引用类型的比较是基于引用地址，而不可变对象的比较是基于集合的值是否一一相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Map</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;immutable&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="title class_">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> map2 = <span class="title class_">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;);</span><br><span class="line">map1.<span class="title function_">equals</span>(map2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Immutable.is(map1, map2); // true</span></span><br><span class="line">map1 === map2; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map3 = map2.<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map3 === map2; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个对象是不可变的，</span></span><br><span class="line"><span class="comment">// 则可以简单地通过对它进行另一个引用而不是复制整个对象来“复制”它。</span></span><br><span class="line"><span class="comment">// 因为这可以节省内存并潜在地提高依赖副本的程序的执行速度（例如撤消堆栈）。</span></span><br></pre></td></tr></table></figure><p>补充:  不可变对象的比较是基于值，算法复杂度 O(N), 而引用类型比较算法复杂度 O(1), 因此使用时要考虑性能权衡。</p><h4 id="JavaScript-优先的-API"><a href="#JavaScript-优先的-API" class="headerlink" title="JavaScript 优先的 API"></a>JavaScript 优先的 API</h4><div class="table-container"><table><thead><tr><th>JavaScript</th><th>immutable</th></tr></thead><tbody><tr><td>Map</td><td>Map</td></tr><tr><td>Set</td><td>Set</td></tr><tr><td>Array</td><td>List</td></tr><tr><td>Object</td><td>fromJS or Map</td></tr></tbody></table></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Map</span>, <span class="title class_">List</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;immutable&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="title class_">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> map2 = <span class="title class_">Map</span>(&#123; <span class="attr">c</span>: <span class="number">10</span>, <span class="attr">a</span>: <span class="number">20</span>, <span class="attr">t</span>: <span class="number">30</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">d</span>: <span class="number">100</span>, <span class="attr">o</span>: <span class="number">200</span>, <span class="attr">g</span>: <span class="number">300</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> map3 = map1.<span class="title function_">merge</span>(map2, obj);</span><br><span class="line"><span class="comment">// Map &#123; a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 &#125;</span></span><br><span class="line"><span class="keyword">const</span> list1 = <span class="title class_">List</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> list2 = <span class="title class_">List</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">const</span> list3 = list1.<span class="title function_">concat</span>(list2, array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的示例可以看出</span></span><br><span class="line"><span class="comment">// 1. 与JS API靠拢 如 Array.prototype.concat</span></span><br><span class="line"><span class="comment">// 2. api可以与JS对象互相操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 Immutable.js 集合都是可迭代的</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">List</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;immutable&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> aList = <span class="title class_">List</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> anArray = [<span class="number">0</span>, ...aList, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure><h4 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套结构</span></span><br><span class="line"><span class="keyword">const</span> &#123; fromJS &#125; = <span class="built_in">require</span>(<span class="string">&quot;immutable&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> nested = <span class="title function_">fromJS</span>(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] &#125; &#125; &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> nested.<span class="title function_">toJS</span>()); <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nested2 = nested.<span class="title function_">mergeDeep</span>(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">d</span>: <span class="number">6</span> &#125; &#125; &#125;);</span><br><span class="line"><span class="comment">// nested2 &#123; a: &#123; b: &#123; c: [3, 4, 5] &#125;, d: 6 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nested2.<span class="title function_">getIn</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;d&quot;</span>])); <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nested2.<span class="title function_">getIn</span>([<span class="string">&quot;a&quot;</span>]).<span class="title function_">getIn</span>([<span class="string">&quot;b&quot;</span>, <span class="string">&quot;d&quot;</span>])); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nested3 = nested2.<span class="title function_">updateIn</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;d&quot;</span>], <span class="function">(<span class="params">value</span>) =&gt;</span> value + <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nested3);</span><br><span class="line"><span class="comment">// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 7 &#125; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nested4 = nested3.<span class="title function_">updateIn</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>], <span class="function">(<span class="params">list</span>) =&gt;</span> list.<span class="title function_">push</span>(<span class="number">6</span>));</span><br><span class="line"><span class="comment">// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5, 6 ], d: 7 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="批处理突变"><a href="#批处理突变" class="headerlink" title="批处理突变"></a>批处理突变</h4><p>默认情况下 immutable.js 中的 api 每执行一次就会返回一个新的 immutable 对象<br>那么如果我只需要最后生成的 immutable 对象，中间的对象都不要，可不可以只返回新一个新对象呢？<br>这就用到了 <code>withMutations</code> ，批量处理节省开销，目前只有少数方法 set push pop  可直接应用于持久化数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">List</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;immutable&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&quot;assert&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> list1 = <span class="title class_">List</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> list2 = list1.<span class="title function_">withMutations</span>(<span class="keyword">function</span> (<span class="params">list</span>) &#123;</span><br><span class="line">  list.<span class="title function_">push</span>(<span class="number">4</span>).<span class="title function_">push</span>(<span class="number">5</span>).<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list1.<span class="property">size</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list2.<span class="property">size</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="惰性序列"><a href="#惰性序列" class="headerlink" title="惰性序列"></a>惰性序列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Seq</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;immutable&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> oddSquares = <span class="title class_">Seq</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;filter&#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 因为oddSquares是一个immutable对象，是惰性执行的，上述代码不会做任何操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当把 immutable 对象转换成 JavaScript 对象是 才会执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oddSquares.<span class="title function_">toJS</span>()); <span class="comment">// 控制台打印了 ‘filter’</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Range 是一种特殊的 Lazy 序列。</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Range</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;immutable&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Range</span>(<span class="number">990</span>, <span class="number">1010</span>)</span><br><span class="line"><span class="comment">// .skip(100)</span></span><br><span class="line">.<span class="title function_">map</span>(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line"><span class="keyword">return</span> -n;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">reduce</span>(<span class="function">(<span class="params">r, n</span>) =&gt;</span> r \* n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---&#x27;</span>, a) <span class="comment">// --- 9.897178826145609e+59</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h4><p>由于 Immutable 数据一般嵌套非常深，为了便于访问深层数据，Cursor 提供了可以直接访问这个深层数据的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Immutable</span> <span class="keyword">from</span> <span class="string">&quot;immutable&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Cursor</span> <span class="keyword">from</span> <span class="string">&quot;immutable/contrib/cursor&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="title class_">Immutable</span>.<span class="title function_">fromJS</span>(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125; &#125;);</span><br><span class="line"><span class="comment">// 让 cursor 指向 &#123; c: 1 &#125;</span></span><br><span class="line"><span class="keyword">let</span> cursor = <span class="title class_">Cursor</span>.<span class="title function_">from</span>(data, [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], <span class="function">(<span class="params">newData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当 cursor 或其子 cursor 执行 update 时调用</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newData);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cursor.<span class="title function_">get</span>(<span class="string">&quot;c&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">cursor = cursor.<span class="title function_">update</span>(<span class="string">&quot;c&quot;</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span>);</span><br><span class="line">cursor.<span class="title function_">get</span>(<span class="string">&quot;c&quot;</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>降低了 mutable 带来的复杂性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">touchAndLog</span>(<span class="params">touchFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = &#123; <span class="attr">key</span>: <span class="string">&quot;value&quot;</span> &#125;;</span><br><span class="line">  <span class="title function_">touchFn</span>(data);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">key</span>);</span><br><span class="line">  <span class="comment">// 因为不知道touchFn进行了什么操作，所以无法预料，但使用immutable，肯定是value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>节省内存</li></ol><p>会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Map</span> &#125; <span class="keyword">from</span> <span class="string">&quot;immutable&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Map</span>(&#123;</span><br><span class="line">  <span class="attr">select</span>: <span class="string">&quot;users&quot;</span>,</span><br><span class="line">  <span class="attr">filter</span>: <span class="title class_">Map</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Cam&quot;</span> &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">set</span>(<span class="string">&quot;select&quot;</span>, <span class="string">&quot;people&quot;</span>);</span><br><span class="line"></span><br><span class="line">a === b; <span class="comment">// false</span></span><br><span class="line">a.<span class="title function_">get</span>(<span class="string">&quot;filter&quot;</span>) === b.<span class="title function_">get</span>(<span class="string">&quot;filter&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol><li>Undo/Redo，Copy/Paste<br>因为每次数据都是不一样的，所有可以存储在数组里，想回退到哪里就拿出对应数据即可</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>需要学习新的 API</li><li>容易与原生对象混淆<ul><li>虽然 Immutable.js 尽量尝试把 API 设计的原生对象类似，有的时候还是很难区别到底是 Immutable 对象还是原生对象，容易混淆操作。</li><li>Immutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get(‘key’) 而不是 map.key，array.get(0) 而不是 array[0]。另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值；</li><li>当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。</li></ul></li></ol><p>下面给出一些办法来避免类似问题发生: </p><ol><li>使用 TypeScript 这类有静态类型检查的工具；</li><li>约定变量命名规则: 如所有 Immutable 类型对象以 $$ 开头；</li><li>使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用；</li></ol><h3 id="使用-immutable-js-优化-react"><a href="#使用-immutable-js-优化-react" class="headerlink" title="使用 immutable.js 优化 react"></a>使用 immutable.js 优化 react</h3><ol><li>React 可以使用 shouldComponentUpdate()进行性能优化，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新；</li><li>可以在 shouldComponentUpdate 周期里执行 deepCopy 和 deepCompare 避免无意义的 render，但 deepFn 也很耗时；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; is &#125; <span class="keyword">from</span> <span class="string">&quot;immutable&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="attr">shouldComponentUpdate</span>: <span class="function">(<span class="params">nextProps = &#123;&#125;, nextState = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> thisProps = <span class="variable language_">this</span>.<span class="property">props</span> || &#123;&#125;,</span><br><span class="line">    thisState = <span class="variable language_">this</span>.<span class="property">state</span> || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(thisProps).<span class="property">length</span> !== <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextProps).<span class="property">length</span> ||</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(thisState).<span class="property">length</span> !== <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextState).<span class="property">length</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is</span>(thisProps[key], nextProps[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      thisState[key] !== nextState[key] &amp;&amp;</span><br><span class="line">      !<span class="title function_">is</span>(thisState[key], nextState[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="immer"><a href="#immer" class="headerlink" title="immer"></a>immer</h2><blockquote><p><a href="https://immerjs.github.io/immer/zh-CN/">官方地址</a></p><p>对于处理修改引用类型副作用问题，ImmutableJS 有两个较大的不足: </p><ul><li>需要使用者学习它的数据结构操作方式，没有 Immer 提供的使用原生对象的操作方式简单、易用；</li><li>它的操作结果需要通过toJS方法才能得到原生对象，这使得在操作一个对象的时候，时刻要知道操作的是原生对象还是 ImmutableJS 的返回结果，稍不注意，就会产生问题；</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentState = &#123;</span><br><span class="line">  <span class="attr">x</span>: [<span class="number">2</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o1 = currentState;</span><br><span class="line">o1.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">  ...currentState,</span><br><span class="line">&#125;;</span><br><span class="line">o2.<span class="property">x</span>.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(currentState); <span class="comment">// &#123; x: [ 2, 3 ], a: 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用immer解决上述问题 */</span></span><br><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">&quot;immer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  <span class="attr">x</span>: [<span class="number">2</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="title function_">produce</span>(state, <span class="function">(<span class="params">draft</span>) =&gt;</span> &#123;</span><br><span class="line">  draft.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">produce</span>(state, <span class="function">(<span class="params">draft</span>) =&gt;</span> &#123;</span><br><span class="line">  draft.<span class="property">x</span>.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &#123; x: [ 2 ] &#125;     &#123; x: [ 2 ], a: 1 &#125;      &#123; x: [ 2, 3 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state, obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// produce方法做了哪些事情？</span></span><br><span class="line"><span class="comment">// 遍历原始对象，依次冻结个属性。</span></span><br></pre></td></tr></table></figure><h3 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h3><p><code>produce(currentState, recipe: (draftState) =&gt; void | draftState, ?PatchListener): nextState</code></p><ul><li>currentState: 被操作对象的最初状态</li><li>draftState: 根据 currentState 生成的草稿状态，它是 currentState 的代理，对 draftState 所做的任何修改都将被记录并用于生成 nextState 。在此过程中，currentState 将不受影响</li><li>nextState: 根据 draftState 生成的最终状态</li><li>produce: 用来生成 nextState 或 producer 的函数</li><li>producer: 通过 produce 生成，用来生产 nextState ，每次执行相同的操作</li><li>recipe: 用来操作 draftState 的函数</li></ul><h3 id="使用-immer-优化-react"><a href="#使用-immer-优化-react" class="headerlink" title="使用 immer 优化 react"></a>使用 immer 优化 react</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原写法 setState</span></span><br><span class="line"><span class="keyword">const</span> &#123; members &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">members</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...members[<span class="number">0</span>],</span><br><span class="line">      <span class="attr">age</span>: members[<span class="number">0</span>].<span class="property">age</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...members.<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在写法</span></span><br><span class="line"><span class="keyword">const</span> &#123; members &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">    <span class="title function_">produce</span>(members, <span class="function">(<span class="params">draft</span>) =&gt;</span> &#123;</span><br><span class="line">      draft.<span class="property">members</span>[<span class="number">0</span>].<span class="property">age</span>++;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="reduce-中使用-immer"><a href="#reduce-中使用-immer" class="headerlink" title="reduce 中使用 immer"></a>reduce 中使用 immer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// produce 内的 recipe 回调函数的第2个参数与obj对象是指向同一块内存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state = &#123; name: <span class="string">&quot;章三&quot;</span>, age: <span class="number">12</span> &#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> immer.<span class="title function_">produce</span>(state, <span class="function">(<span class="params">draft</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ADD&quot;</span>:</span><br><span class="line">        draft.<span class="property">age</span>++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(reducer);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = store.<span class="title function_">getState</span>();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;state.name&#125;今年&#123;state.age&#125;周岁</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> store.dispatch(&#123; type: &quot;ADD&quot; &#125;)&#125;&gt;过生日<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> immutable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React fiber 篇</title>
      <link href="/articles/react/fiber/"/>
      <url>/articles/react/fiber/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="react-架构局限性"><a href="#react-架构局限性" class="headerlink" title="react 架构局限性"></a>react 架构局限性</h3><blockquote><p>v16 采用 Stack Reconciliation，即递归的方式处理组件树更新，从根节点开始遍历整棵树，伴随着同步、阻塞，会出现一些问题</p><ul><li>渲染时间过长: 复杂度过高的任务导致主线程阻塞，Native GUI 线程中断，无法响应用户指令，影响体验</li><li>优先级管理: 无优先级概念，导致关键任务可能被低优先级任务阻塞</li><li>中断恢复机制: 一旦开始就无法中断和恢复</li></ul></blockquote><h3 id="fiber-解决方案"><a href="#fiber-解决方案" class="headerlink" title="fiber 解决方案"></a>fiber 解决方案</h3><ol><li>性能提升: </li></ol><ul><li>增量渲染: 将整个渲染过程分成多个可中断的、执行时间短的小任务，并使用任务调度器（Scheduler）来动态地调度这些任务，避免长时间的阻塞，提升了渲染的灵活性和效率</li><li>任务分片: Time Slicing，fiber 可在空闲时间内执行渲染任务，从而最大限度地利用浏览器的空闲时间<blockquote><ul><li>任务队列 (Task Queue): 将所有的更新操作封装成任务，并放入一个任务队列中</li><li>执行任务: 执行队列任务，记录当前任务执行时间</li><li>时间检查: 若任务执行时间超过阈值 (默认 5 毫秒)，则中断执行</li><li>让出线程: 使用 <code>MessageChannel</code> 和 <code>postMessage</code> 让出线程，浏览器执行其他任务</li><li>通知执行: 浏览器执行完成后，通过 <code>onmessage</code> 事件继续执行之前中断的任务</li><li>循环执行: 重复此过程直到任务队列清空</li></ul></blockquote></li></ul><ol><li>用户体验: </li></ol><ul><li>分配优先级: 确保高优先级的任务尽快处理<blockquote><ul><li>同步任务: 最高优先级的任务，通常用于处理用户交互事件和页面加载过程中的同步操作</li><li>异步任务: 中等优先级的任务，包括普通的更新任务和网络请求等异步操作</li><li>空闲任务: 最低优先级的任务，通常用于执行一些不紧急的任务，如日志记录或统计信息收集等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoPriority</span> = <span class="number">0</span>; <span class="comment">// 无优先级任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ImmediatePriority</span> = <span class="number">1</span>; <span class="comment">// 立即执行任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UserBlockingPriority</span> = <span class="number">2</span>; <span class="comment">// 用户阻塞任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NormalPriority</span> = <span class="number">3</span>; <span class="comment">// 正常任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LowPriority</span> = <span class="number">4</span>; <span class="comment">// 低优先级任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IdlePriority</span> = <span class="number">5</span>; <span class="comment">// 空闲执行任务</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><ol><li>灵活和扩展: </li></ol><ul><li>为未来特性提供基础，例如 Concurrent Mode 和 Suspense</li></ul><ol><li>维护和调试: </li></ol><ul><li>改进 React 内部的代码结构，便于调试和维护</li></ul><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="浏览器帧"><a href="#浏览器帧" class="headerlink" title="浏览器帧"></a>浏览器帧</h3><ol><li>浏览器对每一帧的执行和渲染的流程分为 7 个阶段<br><img src="/images/react/fiber_1.png" alt=""></li></ol><ul><li>第 1-3 阶段: js 执行阶段，分别为用户事件回调、定时器回调、窗口变更事件回调</li><li>第 4 阶段: rAF 阶段，即 window.requestAnimationFrame 回调执行阶段</li><li>第 5-6 阶段: 页面渲染阶段，前 3 阶段 js 执行时间过长将阻塞渲染，导致页面卡顿</li><li>第 7 阶段: 帧空闲阶段，即 window.requestIdleCallback 回调执行阶段。若前 6 阶段运行时间超过 16.6ms，则该回调不会执行</li></ul><ol><li><p>requestIdleCallback: 回调会传入一个期限，表示浏览器有多少时间供事件执行, 为了不耽误事，最好在这个时间范围内执行完毕。requestAnimationFrame 的回调会在每一帧确认执行, 属于高优先级任务，而 requestIdleCallback 的回调不一定, 属于低优先级任务</p></li><li><p>任务优先级</p></li></ol><ul><li>Immediate(-1): 任务会同步执行，或者说要马上执行且不能中断</li><li>UserBlocking(250ms): 任务一般是用户交互的结果，需要即时得到反馈</li><li>Normal(5s): 不需要立即完成的任务，例如网络请求</li><li>Low(10s): 任务可以放后，但是最终应该得到执行，例如分析通知</li><li>Idle(没有超时时间): 一些没有必要做的任务</li></ul><h3 id="fiber-结构"><a href="#fiber-结构" class="headerlink" title="fiber 结构"></a>fiber 结构</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">this</span>: $<span class="title class_">FlowFixMe</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">tag</span>: <span class="title class_">WorkTag</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">pendingProps</span>: mixed,</span></span><br><span class="line"><span class="params">  <span class="attr">key</span>: <span class="literal">null</span> | <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">mode</span>: <span class="title class_">TypeOfMode</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 基本属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag; <span class="comment">// 描述此Fiber的启动模式的值（LegacyRoot = 0; ConcurrentRoot = 1）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key; <span class="comment">// React key</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>; <span class="comment">// 描述React元素的类型。例如，对于JSX&lt;App /&gt;，elementType是App</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>; <span class="comment">// 组件类型</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>; <span class="comment">// 对于类组件，这是类的实例；对于DOM元素，它是对应的DOM节点。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fiber链接</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>; <span class="comment">// 指向父Fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>; <span class="comment">// 指向第一个子Fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>; <span class="comment">// 指向其兄弟Fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>; <span class="comment">// 子Fiber中的索引位置</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>; <span class="comment">// 如果组件上有ref属性，则该属性指向它</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">refCleanup</span> = <span class="literal">null</span>; <span class="comment">// 如果组件上的ref属性在更新中被删除或更改，此字段会用于追踪需要清理的旧ref</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Props &amp; State</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps; <span class="comment">// 正在等待处理的新props</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>; <span class="comment">// 上一次渲染时的props</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>; <span class="comment">// 一个队列，包含了该Fiber上的状态更新和副作用</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>; <span class="comment">// 上一次渲染时的state</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>; <span class="comment">// 该Fiber订阅的上下文或其他资源的描述</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工作模式</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode; <span class="comment">// 描述Fiber工作模式的标志（例如Concurrent模式、Blocking模式等）。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">flags</span> = <span class="title class_">NoFlags</span>; <span class="comment">// 描述该Fiber发生的副作用的标志（十六进制的标识）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subtreeFlags</span> = <span class="title class_">NoFlags</span>; <span class="comment">// 描述该Fiber子树中发生的副作用的标志（十六进制的标识）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deletions</span> = <span class="literal">null</span>; <span class="comment">// 在commit阶段要删除的子Fiber数组</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>; <span class="comment">// 与React的并发模式有关的调度概念。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childLanes</span> = <span class="title class_">NoLanes</span>; <span class="comment">// 与React的并发模式有关的调度概念。</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>; <span class="comment">// Current Tree和Work-in-progress (WIP) Tree的互相指向对方 tree里的对应单元</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果启用了性能分析</span></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发模式中</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h3><blockquote><p>渲染模式，提高性能和体验，利用了 fiber 架构的增量渲染和时间切片技术，能够在多个优先级任务之间动态地调度执行，使得高优先级任务能够优先得到处理。具体有以下实现</p></blockquote><h4 id="batchedUpdates"><a href="#batchedUpdates" class="headerlink" title="batchedUpdates"></a>batchedUpdates</h4><blockquote><p>连续触发多次状态更新会被更智能地合并为单一的更新操作，以避免不必要的渲染</p><ul><li>早期版本的 batchedUpdates 无法合并一些脱离当前上下文环境的更新</li><li>在 Concurrent Mode 模式下，状态更新的合并不再局限于当前上下文，而是根据更新的优先级来决定是否合并</li></ul></blockquote><h4 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h4><blockquote><p>用于在组件树中等待异步加载内容的机制，能够在数据加载完成之前显示占位符或 loading 界面，提高用户体验</p></blockquote><h4 id="Lazy-Loading"><a href="#Lazy-Loading" class="headerlink" title="Lazy Loading"></a>Lazy Loading</h4><blockquote><p>延迟加载组件或资源，能够提高页面的加载速度和响应速度，减少初次加载时的资源占用和等待时间</p></blockquote><h4 id="useDeferredValue"><a href="#useDeferredValue" class="headerlink" title="useDeferredValue"></a>useDeferredValue</h4><blockquote><p>内部会调用 useState 并触发一次更新，但优先级很低，当前如果有正在进行中的更新，不会受 useDeferredValue 产生的更新影响，能够返回一个延后更新的值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deferredValue = <span class="title function_">useDeferredValue</span>(value);</span><br></pre></td></tr></table></figure></blockquote><h4 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h4><blockquote><p>用于处理低优先级任务无法立即执行的情况。在任务无法立即执行时，Concurrent Mode 能够自动调整任务的优先级，保证高优先级任务能够得到及时处理，避免页面加载和渲染的阻塞</p></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol><li><p>工作单元: 每个 fiber 节点代表一个单元，所有 fiber 节点共同组成一个 fiber 链表树，精确定位控制节点行为</p></li><li><p>链表属性: child、sibling 和 return 字段形成节点关系网</p></li><li><p>双缓冲: </p><blockquote><ul><li>两棵树，当前树 (currentFiber)，基于此创建的临时树 (workInProgressFiber)，WIP 包含了当前更新受影响的顶层节点直至其所有后代节点</li><li>WIP 在后台进行比较更新，完成后复制添加其他未更新节点，最终替换 currentFiber，成为新的 currentFiber</li><li>两棵树可随时进行比较、中断、恢复等操作，提升渲染性能及 UI 稳定</li></ul></blockquote></li><li><p>更新判断: 通过 memoizedProps、pendingProps 和 memoizedState 字段计算该节点上一个状态和即将应用的状态。从而判断是否需要更新，避免不必要的渲染</p></li><li><p>副作用收集: flags、subtreeFlags 字段标识 fiber 及其子树中需要执行的副作用，React 会收集并在 commit 阶段一次性执行</p></li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h3><blockquote><p>构建工作数，并通过协调算法比较新旧 props 确定更新的节点</p><ul><li>旧的协调算法: 深度优先遍历 VDOM 树，一旦开始便无法中断</li><li>新的协调算法: 增量渲染、时间切片</li><li>协调阶段可能被中断、恢复，甚至重做，协调阶段的生命周期钩子可能会被调用多次,例如 componentWillMount 可能会被调用两次，所以 v17 后一些生命周期废除了</li></ul></blockquote><h4 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h4><blockquote><p>第一阶段: 创建与标记更新节点 (ReactFiberBeginWork.js)</p></blockquote><ol><li>判断 Fiber 节点是否要更新</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">current</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">workInProgress</span>: <span class="title class_">Fiber</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">renderLanes</span>: <span class="title class_">Lanes</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这是旧节点，需要检查props和context是否有变化再确认是否需要更新节点</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = current.<span class="property">memoizedProps</span>;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps || <span class="title function_">hasLegacyContextChanged</span>()) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>; <span class="comment">// props和context有变化，说明节点有更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其它特殊情况的判断</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>; <span class="comment">// 这是新节点，要创建，而不是更新</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>; <span class="comment">// 进入beginWork表示开始新的工作阶段，所以要把旧的workInProgress优先级清除掉</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过workInProgress的tag属性来确定如何处理当前的Fiber节点</span></span><br><span class="line">    <span class="comment">// 每一种tag对应一种不同的Fiber类型，进入不同的调和过程（reconcileChildren()）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>: <span class="comment">// 尚未确定其类型的组件</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LazyComponent</span>: <span class="comment">// 懒加载组件</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: <span class="comment">// 函数组件</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: <span class="comment">// 类组件</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它多种Fiber类型</span></span><br><span class="line">    <span class="comment">// case ……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断 Fiber 子节点是更新还是复用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">current</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">workInProgress</span>: <span class="title class_">Fiber</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">nextChildren</span>: <span class="built_in">any</span>, <span class="comment">// 要调和的新的子元素</span></span></span><br><span class="line"><span class="params">  <span class="attr">renderLanes</span>: <span class="title class_">Lanes</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果current为空，说明这个Fiber是首次渲染，React会为nextChildren生成一组新的Fiber节点</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当current非空时，React会利用现有的Fiber节点（current.child）和新的子元素（nextChildren）进行调和</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.<span class="property">child</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react/packages/react-reconciler/src/ReactChildFiber.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">reconcileChildFibers</span>: <span class="title class_">ChildReconciler</span> =</span><br><span class="line">  <span class="title function_">createChildReconciler</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mountChildFibers</span>: <span class="title class_">ChildReconciler</span> = <span class="title function_">createChildReconciler</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="completeUnitOfWork"><a href="#completeUnitOfWork" class="headerlink" title="completeUnitOfWork"></a>completeUnitOfWork</h4><blockquote><p>第二阶段: 遍历 Fiber 节点，记录有副作用节点的关系，收集副作用列表 (ReactFiberWorkLoop.js)</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberWorkLoop.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">completeUnitOfWork</span>(<span class="params"><span class="attr">unitOfWork</span>: <span class="title class_">Fiber</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">completedWork</span>: <span class="title class_">Fiber</span> = unitOfWork; <span class="comment">// 当前正在完成的工作单元</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = completedWork.<span class="property">alternate</span>; <span class="comment">// 当前Fiber节点在另一棵树上的版本</span></span><br><span class="line">    <span class="keyword">const</span> returnFiber = completedWork.<span class="property">return</span>; <span class="comment">// 当前Fiber节点的父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    next = <span class="title function_">completeWork</span>(current, completedWork, renderLanes); <span class="comment">// 调用completeWork函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前Fiber还有工作要完成</span></span><br><span class="line">      workInProgress = next;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> siblingFiber = completedWork.<span class="property">sibling</span>;</span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有兄弟节点，则进入兄弟节点的工作</span></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有兄弟节点，回到父节点继续</span></span><br><span class="line">    completedWork = returnFiber;</span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果处理了整个Fiber树，更新workInProgressRootExitStatus为RootCompleted，表示调和已完成</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === <span class="title class_">RootInProgress</span>) &#123;</span><br><span class="line">    workInProgressRootExitStatus = <span class="title class_">RootCompleted</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h4><blockquote><p>第三阶段: 据 tag 进行不同的处理 (ReactFiberCompleteWork.js)<br>bubbleProperties: 记录 Fiber 的副作用标志，并为子 Fiber 创建链表</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberCompleteWork.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">completeWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">current</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">workInProgress</span>: <span class="title class_">Fiber</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">renderLanes</span>: <span class="title class_">Lanes</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="comment">// 多种tag</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">      <span class="title function_">bubbleProperties</span>(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:</span><br><span class="line">      <span class="comment">// 省略逻辑</span></span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">      <span class="title function_">bubbleProperties</span>(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">      <span class="comment">// 省略逻辑</span></span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 多种tag</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleProperties</span>(<span class="params"><span class="attr">completedWork</span>: <span class="title class_">Fiber</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> didBailout =</span><br><span class="line">    completedWork.<span class="property">alternate</span> !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    completedWork.<span class="property">alternate</span>.<span class="property">child</span> === completedWork.<span class="property">child</span>; <span class="comment">// 当前的Fiber与其alternate（备用/上一次的Fiber）有相同的子节点，则跳过更新</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChildLanes = <span class="title class_">NoLanes</span>; <span class="comment">// 合并后的子Fiber的lanes</span></span><br><span class="line">  <span class="keyword">let</span> subtreeFlags = <span class="title class_">NoFlags</span>; <span class="comment">// 子树的flags。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!didBailout) &#123;</span><br><span class="line">    <span class="comment">// 没有bailout，需要冒泡子Fiber的属性到父Fiber</span></span><br><span class="line">    <span class="keyword">let</span> child = completedWork.<span class="property">child</span>;</span><br><span class="line">    <span class="comment">// 遍历子Fiber，并合并它们的lanes和flags</span></span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      newChildLanes = <span class="title function_">mergeLanes</span>(</span><br><span class="line">        newChildLanes,</span><br><span class="line">        <span class="title function_">mergeLanes</span>(child.<span class="property">lanes</span>, child.<span class="property">childLanes</span>)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      subtreeFlags |= child.<span class="property">subtreeFlags</span>;</span><br><span class="line">      subtreeFlags |= child.<span class="property">flags</span>;</span><br><span class="line"></span><br><span class="line">      child.<span class="property">return</span> = completedWork; <span class="comment">// Fiber的return指向父Fiber，确保整个Fiber树的一致性</span></span><br><span class="line">      child = child.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    completedWork.<span class="property">subtreeFlags</span> |= subtreeFlags; <span class="comment">// 合并所有flags（副作用）</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有bailout，只冒泡那些具有“静态”生命周期的flags</span></span><br><span class="line">    <span class="keyword">let</span> child = completedWork.<span class="property">child</span>;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      newChildLanes = <span class="title function_">mergeLanes</span>(</span><br><span class="line">        newChildLanes,</span><br><span class="line">        <span class="title function_">mergeLanes</span>(child.<span class="property">lanes</span>, child.<span class="property">childLanes</span>)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      subtreeFlags |= child.<span class="property">subtreeFlags</span> &amp; <span class="title class_">StaticMask</span>; <span class="comment">// 不同</span></span><br><span class="line">      subtreeFlags |= child.<span class="property">flags</span> &amp; <span class="title class_">StaticMask</span>; <span class="comment">// 不同</span></span><br><span class="line"></span><br><span class="line">      child.<span class="property">return</span> = completedWork;</span><br><span class="line">      child = child.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    completedWork.<span class="property">subtreeFlags</span> |= subtreeFlags;</span><br><span class="line">  &#125;</span><br><span class="line">  completedWork.<span class="property">childLanes</span> = newChildLanes; <span class="comment">// 获取所有子Fiber的lanes。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> didBailout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>Fiber 架构计算速度加快</p><blockquote><p>flags 或 subtreeFlags 是 16 进制的标识，进行按位或(|)运算后，可以记录当前节点本身和子树的副作用类型，通过运算结果可以减少节点的遍历</p></blockquote></li><li><p>调和过程可中断</p><blockquote><p>Concurrent Mode 的能力使得 React 可以优先处理高优先级的更新</p></blockquote></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberWorkLoop.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderRootConcurrent</span>(<span class="params"><span class="attr">root</span>: <span class="title class_">FiberRoot</span>, <span class="attr">lanes</span>: <span class="title class_">Lanes</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 保存当前的执行上下文和 dispatcher</span></span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= <span class="title class_">RenderContext</span>;</span><br><span class="line">  <span class="keyword">const</span> prevDispatcher = <span class="title function_">pushDispatcher</span>(root.<span class="property">containerInfo</span>);</span><br><span class="line">  <span class="keyword">const</span> prevCacheDispatcher = <span class="title function_">pushCacheDispatcher</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) &#123;</span><br><span class="line">    <span class="comment">// 如果当前的工作进度树与传入的 root 或 lanes 不匹配，我们需要为新的渲染任务准备一个新的堆栈。</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 持续的工作循环，除非中断发生，否则会一直尝试完成渲染工作</span></span><br><span class="line">  <span class="attr">outer</span>: <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        workInProgressSuspendedReason !== <span class="title class_">NotSuspended</span> &amp;&amp;</span><br><span class="line">        workInProgress !== <span class="literal">null</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的工作进度是由于某种原因而被挂起的，并且仍然有工作待处理，那么会处理它</span></span><br><span class="line">        <span class="keyword">const</span> unitOfWork = workInProgress;</span><br><span class="line">        <span class="keyword">const</span> thrownValue = workInProgressThrownValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据不同挂起原因，进行中断、恢复等计算</span></span><br><span class="line">        <span class="attr">resumeOrUnwind</span>: <span class="keyword">switch</span> (workInProgressSuspendedReason) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">SuspendedOnError</span>: &#123;</span><br><span class="line">            <span class="comment">// 如果工作因错误被挂起，那么工作会被中断，并从最后一个已知的稳定点继续</span></span><br><span class="line">            <span class="comment">// ……省略逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">SuspendedOnData</span>: &#123;</span><br><span class="line">            <span class="comment">// 工作因等待数据（通常是一个异步请求的结果）而被挂起，</span></span><br><span class="line">            <span class="comment">// ……省略逻辑</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">SuspendedOnInstance</span>: &#123;</span><br><span class="line">            <span class="comment">// 将挂起的原因更新为SuspendedOnInstanceAndReadyToContinue并中断工作循环，标记为稍后准备好继续执行</span></span><br><span class="line">            workInProgressSuspendedReason =</span><br><span class="line">              <span class="title class_">SuspendedOnInstanceAndReadyToContinue</span>;</span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">SuspendedAndReadyToContinue</span>: &#123;</span><br><span class="line">            <span class="comment">// 表示之前的挂起工作现在已经准备好继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isThenableResolved</span>(thenable)) &#123;</span><br><span class="line">              <span class="comment">// 如果已解析，这意味着需要的数据现在已经可用</span></span><br><span class="line">              workInProgressSuspendedReason = <span class="title class_">NotSuspended</span>;</span><br><span class="line">              workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">              <span class="title function_">replaySuspendedUnitOfWork</span>(unitOfWork); <span class="comment">// 恢复执行被挂起的工作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              workInProgressSuspendedReason = <span class="title class_">NotSuspended</span>;</span><br><span class="line">              workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">              <span class="title function_">throwAndUnwindWorkLoop</span>(unitOfWork, thrownValue); <span class="comment">// 继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">SuspendedOnInstanceAndReadyToContinue</span>: &#123;</span><br><span class="line">            <span class="comment">// ……省略部分逻辑</span></span><br><span class="line">            <span class="keyword">const</span> isReady = <span class="title function_">preloadInstance</span>(<span class="keyword">type</span>, props);</span><br><span class="line">            <span class="keyword">if</span> (isReady) &#123;</span><br><span class="line">              <span class="comment">// 实例已经准备好</span></span><br><span class="line">              workInProgressSuspendedReason = <span class="title class_">NotSuspended</span>; <span class="comment">// 该fiber已完成，不需要再挂起</span></span><br><span class="line">              workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">              <span class="keyword">const</span> sibling = hostFiber.<span class="property">sibling</span>;</span><br><span class="line">              <span class="keyword">if</span> (sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">                workInProgress = sibling; <span class="comment">// 有兄弟节点，开始处理兄弟节点</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有兄弟节点，回到父节点</span></span><br><span class="line">                <span class="keyword">const</span> returnFiber = hostFiber.<span class="property">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">                  workInProgress = returnFiber;</span><br><span class="line">                  <span class="title function_">completeUnitOfWork</span>(returnFiber); <span class="comment">// 收集副作用，前面有详细介绍</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  workInProgress = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span> resumeOrUnwind;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 还有其它case</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">workLoopConcurrent</span>(); <span class="comment">// 如果没有任何工作被挂起，那么就会继续处理工作循环。</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      <span class="title function_">handleThrow</span>(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置了之前保存的执行上下文和dispatcher，确保后续的代码不会受到这个函数的影响</span></span><br><span class="line">  <span class="title function_">resetContextDependencies</span>();</span><br><span class="line">  <span class="title function_">popDispatcher</span>(prevDispatcher);</span><br><span class="line">  <span class="title function_">popCacheDispatcher</span>(prevCacheDispatcher);</span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查调和是否已完成</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 未完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">RootInProgress</span>; <span class="comment">// 返回一个状态值，表示还有未完成</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 已完成</span></span><br><span class="line">    workInProgressRoot = <span class="literal">null</span>; <span class="comment">// 重置root</span></span><br><span class="line">    workInProgressRootRenderLanes = <span class="title class_">NoLanes</span>; <span class="comment">// 重置Lane</span></span><br><span class="line">    <span class="title function_">finishQueueingConcurrentUpdates</span>(); <span class="comment">// 处理队列中的并发更新</span></span><br><span class="line">    <span class="keyword">return</span> workInProgressRootExitStatus; <span class="comment">// 返回当前渲染root的最终退出状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><blockquote><p>通过 commitRoot 和 commitRootImpl 方法，遍历在 Reconciliation 阶段创建的副作用列表进行更新，更新 DOM 并执行副作用。一旦进入提交阶段，需要正确地处理各种副作用，无法中断</p></blockquote><h4 id="BeforeMutation"><a href="#BeforeMutation" class="headerlink" title="BeforeMutation"></a>BeforeMutation</h4><blockquote><p>第一阶段: 遍历副作用列表 (ReactFiberCommitWork.js)</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberCommitWork.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">root</span>: <span class="title class_">FiberRoot</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">firstChild</span>: <span class="title class_">Fiber</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  nextEffect = firstChild; <span class="comment">// nextEffect是遍历此链表时的当前fiber</span></span><br><span class="line">  <span class="title function_">commitBeforeMutationEffects_begin</span>(); <span class="comment">// 遍历fiber，处理节点删除和确认节点在before mutation阶段是否有要处理的副作用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> shouldFire = shouldFireAfterActiveInstanceBlur; <span class="comment">// 当一个焦点元素被删除或隐藏时，它会被设置为 true</span></span><br><span class="line">  shouldFireAfterActiveInstanceBlur = <span class="literal">false</span>;</span><br><span class="line">  focusedInstanceHandle = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shouldFire;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CommitMutation"><a href="#CommitMutation" class="headerlink" title="CommitMutation"></a>CommitMutation</h4><blockquote><p>第二阶段: 提交更新 (ReactFiberCommitWork.js)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberCommitWork.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  root: FiberRoot,</span></span><br><span class="line"><span class="params">  finishedWork: Fiber,</span></span><br><span class="line"><span class="params">  committedLanes: Lanes</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// lanes和root被设置为&quot;in progress&quot;状态，表示它们正在被处理</span></span><br><span class="line">  inProgressLanes = committedLanes;</span><br><span class="line">  inProgressRoot = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归遍历Fiber，更新副作用节点</span></span><br><span class="line">  <span class="title function_">commitMutationEffectsOnFiber</span>(finishedWork, root, committedLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置进行中的lanes和root</span></span><br><span class="line">  inProgressLanes = <span class="literal">null</span>;</span><br><span class="line">  inProgressRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commitLayout"><a href="#commitLayout" class="headerlink" title="commitLayout"></a>commitLayout</h4><blockquote><p>第二阶段: 处理 layout effects (ReactFiberCommitWork.js)</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberCommitWork.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">commitLayoutEffects</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">finishedWork</span>: <span class="title class_">Fiber</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">root</span>: <span class="title class_">FiberRoot</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">committedLanes</span>: <span class="title class_">Lanes</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  inProgressLanes = committedLanes;</span><br><span class="line">  inProgressRoot = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个current指向就Fiber树的alternate</span></span><br><span class="line">  <span class="keyword">const</span> current = finishedWork.<span class="property">alternate</span>;</span><br><span class="line">  <span class="comment">// 处理那些由useLayoutEffect创建的layout effects</span></span><br><span class="line">  <span class="title function_">commitLayoutEffectOnFiber</span>(root, current, finishedWork, committedLanes);</span><br><span class="line"></span><br><span class="line">  inProgressLanes = <span class="literal">null</span>;</span><br><span class="line">  inProgressRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fiber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React router 篇</title>
      <link href="/articles/react/router/"/>
      <url>/articles/react/router/</url>
      
        <content type="html"><![CDATA[<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><blockquote><p>hash</p><ul><li>url 中的 hash 部分不会引起页面的刷新</li><li>hashchange 监听 url 变化，浏览器导航栏的前进后退，a 标签，window.location 等方式触发事件</li></ul><p>history</p><ul><li>pushState 和 replaceState 改变 url 的 path 部分不会引起页面刷新</li><li>popchange 监听 url 变化，只有在浏览器导航栏的前进后退改变 url 时会触发事件，pushState/replaceState 不会触发 popstate 方法，需要进行拦截或重写 pushState/replaceState 来监听</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _wr = <span class="keyword">function</span> (<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> orig = history[type];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">Event</span>(type);</span><br><span class="line">    e.<span class="property">arguments</span> = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">const</span> rv = orig.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">dispatchEvent</span>(e);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">history.<span class="property">pushState</span> = <span class="title function_">_wr</span>(<span class="string">&quot;pushstate&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="react-router-架构"><a href="#react-router-架构" class="headerlink" title="react-router 架构"></a>react-router 架构</h2><p><img src="/images/react/router_1.png" alt=""></p><h3 id="BrowserHistory"><a href="#BrowserHistory" class="headerlink" title="BrowserHistory"></a>BrowserHistory</h3><blockquote><ul><li>监听路由变化的 listen 方法以及对应的清理监听 unlisten 方法</li><li>重写路由的 push 方法，自动触发 popstate 方法</li><li>window.location 获取参数</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和管理listeners的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">EventEmitter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> events = [];</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">      events.<span class="title function_">push</span>(fn);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        events = events.<span class="title function_">filter</span>(<span class="function">(<span class="params">handler</span>) =&gt;</span> handler !== fn);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">      events.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn &amp;&amp; <span class="title function_">fn</span>(arg));</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createBrowserHistory</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="title class_">EventEmitter</span>();</span><br><span class="line">  <span class="keyword">let</span> location = &#123; <span class="attr">pathname</span>: <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">  <span class="comment">// 路由变化时的回调</span></span><br><span class="line">  <span class="keyword">const</span> handlePop = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentLocation = &#123; <span class="attr">pathname</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span> &#125;;</span><br><span class="line">    <span class="title class_">EventBus</span>.<span class="title function_">emit</span>(currentLocation);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 定义history.push方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">push</span> = (<span class="params">path</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="variable language_">window</span>.<span class="property">history</span>;</span><br><span class="line">    history.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="string">&quot;&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于push并不触发popstate，手动调用回调函数</span></span><br><span class="line">    location = &#123; <span class="attr">pathname</span>: path &#125;;</span><br><span class="line">    <span class="title class_">EventBus</span>.<span class="title function_">emit</span>(location);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">listen</span> = (<span class="params">listener</span>) =&gt; <span class="title class_">EventBus</span>.<span class="title function_">subscribe</span>(listener);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理浏览器的前进后退</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, handlePop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> history = &#123;</span><br><span class="line">    location,</span><br><span class="line">    listen,</span><br><span class="line">    push,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> history;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="HashHistory"><a href="#HashHistory" class="headerlink" title="HashHistory"></a>HashHistory</h3><blockquote><ul><li>监听 hashchange</li><li>解析 hash 获取参数，比如 hash 部分是 #/a/b?c=1#/d，解析出 { hash: ‘#/d’, search: ‘?c=1’, pathname: ‘/a/b’ }</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createHashHistory</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="title class_">EventEmitter</span>();</span><br><span class="line">  <span class="keyword">let</span> location = &#123; <span class="attr">pathname</span>: <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handlePop = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentLocation = &#123; <span class="attr">pathname</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>) &#125;;</span><br><span class="line">    <span class="title class_">EventBus</span>.<span class="title function_">emit</span>(currentLocation);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">push</span> = (<span class="params">path</span>) =&gt; (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> = path);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">listen</span> = (<span class="params">listener: <span class="built_in">Function</span></span>) =&gt; <span class="title class_">EventBus</span>.<span class="title function_">subscribe</span>(listener);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, handlePop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> history = &#123;</span><br><span class="line">    location,</span><br><span class="line">    listen,</span><br><span class="line">    push,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> history;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="react-router-6"><a href="#react-router-6" class="headerlink" title="react-router@6"></a>react-router@6</h2><p><img src="/images/react/router_2.png" alt=""></p><blockquote><ul><li>v6 版本中移出了先前的 <code>&lt;Switch&gt;</code>，引入了新的替代者: <code>&lt;Routes&gt;</code></li><li><code>&lt;Routes&gt;</code> 和 <code>&lt;Route&gt;</code> 配合使用，用 <code>&lt;Routes&gt;</code> 包裹 <code>&lt;Route&gt;</code></li><li><code>&lt;Routes&gt;</code> 本质上调用 useRoutes 返回的对象， <code>&lt;Route&gt;</code> 相当于一个 case 语句，当 url 发生变化时，<code>&lt;Routes&gt;</code> 都会查看其所有子 <code>&lt;Route&gt;</code> 元素以找到最佳匹配并呈现组件</li><li><code>withRouter</code>: HOC ，非路由组件通过 withRouter 包裹来获取 history、location、match 信息</li></ul></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>App.jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 设置路由链接 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* className 接收一个函数，可以改变激活的类名 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">className</span>=<span class="string">&quot;menu-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        About</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">className</span>=<span class="string">&quot;menu-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Home</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 用 Routes 组件进行包裹*/&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* Route 组件的 element 属性值为对应的组件*/&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* caseSensitive 严格区分大小写*/&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 调用 useRoutes()，嵌入路由映射表 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">caseSensitive</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* Navigate 组件，页面渲染就显示对应组件，实现重定向效果 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/about &quot;</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;useRoutes(routes)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Home.jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 传递 params 参数，在路径后面用 / 进行拼接，useParams */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`<span class="attr">detail</span>/$&#123;<span class="attr">id</span>&#125;/$&#123;<span class="attr">title</span>&#125;/$&#123;<span class="attr">content</span>&#125;`&#125;&gt;</span>&#123;m.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 传递 search 参数，在路径后面用 ? 进行拼接，useSearchParams */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`<span class="attr">detail</span>?<span class="attr">id</span>=<span class="string">$&#123;id&#125;&amp;title</span>=<span class="string">$&#123;title&#125;&amp;content</span>=<span class="string">$&#123;content&#125;</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;title&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 传递 state 参数，添加 state 属性，值为一个对象，useLocation */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;detail&quot;</span> <span class="attr">state</span>=<span class="string">&#123;&#123;</span> <span class="attr">id</span>, <span class="attr">title</span>, <span class="attr">content</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;title&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* Outlet 路由占位符，表示&quot;路由映射表&quot;中匹配的组件将在此处展示 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Routes-标签"><a href="#Routes-标签" class="headerlink" title="Routes 标签"></a>Routes 标签</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">RoutesProps</span> &#123;</span><br><span class="line">  <span class="attr">children</span>?: <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">  <span class="comment">// 用户传入的 location 对象，一般不传，默认用当前浏览器的 location</span></span><br><span class="line">  <span class="attr">location</span>?: <span class="title class_">Partial</span>&lt;<span class="title class_">Location</span>&gt; | <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Routes</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  children,</span></span><br><span class="line"><span class="params">  location,</span></span><br><span class="line"><span class="params">&#125;: <span class="title class_">RoutesProps</span></span>): <span class="title class_">React</span>.<span class="property">ReactElement</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 此处调用了 useRoutes 这个 hook，并且使用了 createRoutesFromChildren 将 children 转换成了 useRoutes 所需要配置的参数格式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useRoutes</span>(<span class="title function_">createRoutesFromChildren</span>(children), location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部通过 React.Children.forEach 把 Route 组件给结构化，并且内部调用递归，深度递归 children 结构</span></span><br><span class="line"><span class="comment">// 把 &lt;Route&gt; 类型的 react element 对象，变成了普通的 route 对象结构。Route 本质是一个空函数，并没有实际挂载，是通过 createRoutesFromChildren 处理转化了</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRoutesFromChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">children</span>: <span class="title class_">React</span>.<span class="title class_">ReactNode</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">RouteObject</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">routes</span>: <span class="title class_">RouteObject</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 就是递归遍历 children 然后格式化后推入 routes 数组中</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(children, <span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Ignore non-elements.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(element)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果类型为 React.Fragment 继续递归遍历</span></span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">type</span> === <span class="title class_">React</span>.<span class="property">Fragment</span>) &#123;</span><br><span class="line">      <span class="comment">// 相当于 routes.push(...createRoutesFromChildren(element.props.children))</span></span><br><span class="line">      routes.<span class="property">push</span>.<span class="title function_">apply</span>(</span><br><span class="line">        routes,</span><br><span class="line">        <span class="title function_">createRoutesFromChildren</span>(element.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">route</span>: <span class="title class_">RouteObject</span> = &#123;</span><br><span class="line">      <span class="attr">caseSensitive</span>: element.<span class="property">props</span>.<span class="property">caseSensitive</span>,</span><br><span class="line">      <span class="attr">element</span>: element.<span class="property">props</span>.<span class="property">element</span>,</span><br><span class="line">      <span class="attr">index</span>: element.<span class="property">props</span>.<span class="property">index</span>,</span><br><span class="line">      <span class="attr">path</span>: element.<span class="property">props</span>.<span class="property">path</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">props</span>.<span class="property">children</span>) &#123;</span><br><span class="line">      route.<span class="property">children</span> = <span class="title function_">createRoutesFromChildren</span>(element.<span class="property">props</span>.<span class="property">children</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    routes.<span class="title function_">push</span>(route);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> routes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useRoutes"><a href="#useRoutes" class="headerlink" title="useRoutes"></a>useRoutes</h3><blockquote><p>三个步骤: 路由上下文解析（父子路由）、路由匹配、路由渲染</p><ul><li>解析上下文: 调用 useRoutes 的地方，如果是子路由调用，合并父路由的匹配信息，生成对应的 pathname</li><li>路由匹配: 调用 matchRoutes 返回 matches 数组，找到匹配的路由分支</li><li>路由渲染: 调用 _renderMatches 方法，通过 reduceRight 来形成 react 结构 elmenet</li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useRoutes</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">routes</span>: <span class="title class_">RouteObject</span>[],</span></span><br><span class="line"><span class="params">  <span class="attr">locationArg</span>?: <span class="title class_">Partial</span>&lt;<span class="title class_">Location</span>&gt; | <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">React</span>.<span class="property">ReactElement</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="title function_">invariant</span>(</span><br><span class="line">    <span class="comment">// 外层需要 router 包裹，否则报错</span></span><br><span class="line">    <span class="title function_">useInRouterContext</span>(),</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This error is probably because they somehow have 2 versions of the</span></span><br><span class="line">    <span class="comment">// router loaded. We can help them understand how to avoid that.</span></span><br><span class="line">    <span class="string">`useRoutes() may be used only in the context of a &lt;Router&gt; component.`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="attr">matches</span>: parentMatches &#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">RouteContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> routeMatch = parentMatches[parentMatches.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 最后的一个 route 将作为父路由，后续的 routes 都是其子路由</span></span><br><span class="line">  <span class="keyword">let</span> parentParams = routeMatch ? routeMatch.<span class="property">params</span> : &#123;&#125;; <span class="comment">// 父路由参数</span></span><br><span class="line">  <span class="comment">// 父路由完整 pathname，如果路由设置 /article/*，当前导航 /article/1，那么值为 /article/1</span></span><br><span class="line">  <span class="keyword">let</span> parentPathname = routeMatch ? routeMatch.<span class="property">pathname</span> : <span class="string">&quot;/&quot;</span>;</span><br><span class="line">  <span class="comment">// 同上类比，看 base 命名可以看出值为 /article</span></span><br><span class="line">  <span class="keyword">let</span> parentPathnameBase = routeMatch ? routeMatch.<span class="property">pathnameBase</span> : <span class="string">&quot;/&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> parentRoute = routeMatch &amp;&amp; routeMatch.<span class="property">route</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> locationFromContext = <span class="title function_">useLocation</span>(); <span class="comment">// 获取当前的 location 状态</span></span><br><span class="line">  <span class="keyword">let</span> location;</span><br><span class="line">  <span class="comment">// 判断是否传入 locationArg 参数，没有的话使用当前的 location</span></span><br><span class="line">  <span class="keyword">if</span> (locationArg) &#123;</span><br><span class="line">    <span class="comment">// 格式化为 Path 对象</span></span><br><span class="line">    <span class="keyword">let</span> parsedLocationArg =</span><br><span class="line">      <span class="keyword">typeof</span> locationArg === <span class="string">&quot;string&quot;</span> ? <span class="title function_">parsePath</span>(locationArg) : locationArg;</span><br><span class="line">    <span class="comment">// 如果传入了 location，判断是否与父级路由匹配（作为子路由存在）</span></span><br><span class="line">    <span class="title function_">invariant</span>(</span><br><span class="line">      parentPathnameBase === <span class="string">&quot;/&quot;</span> ||</span><br><span class="line">        parsedLocationArg.<span class="property">pathname</span>?.<span class="title function_">startsWith</span>(parentPathnameBase),</span><br><span class="line">      <span class="string">`When overriding the location using \`&lt;Routes location&gt;\` or \`useRoutes(routes, location)\`, `</span> +</span><br><span class="line">        <span class="string">`the location pathname must begin with the portion of the URL pathname that was `</span> +</span><br><span class="line">        <span class="string">`matched by all parent routes. The current pathname base is &quot;<span class="subst">$&#123;parentPathnameBase&#125;</span>&quot; `</span> +</span><br><span class="line">        <span class="string">`but pathname &quot;<span class="subst">$&#123;parsedLocationArg.pathname&#125;</span>&quot; was given in the \`location\` prop.`</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    location = parsedLocationArg;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    location = locationFromContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pathname = location.<span class="property">pathname</span> || <span class="string">&quot;/&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> remainingPathname =</span><br><span class="line">    parentPathnameBase === <span class="string">&quot;/&quot;</span></span><br><span class="line">      ? pathname</span><br><span class="line">      : pathname.<span class="title function_">slice</span>(parentPathnameBase.<span class="property">length</span>) || <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过传入的 routes 配置项与当前的路径，匹配对应渲染的路由</span></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="title function_">matchRoutes</span>(routes, &#123; <span class="attr">pathname</span>: remainingPathname &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用_renderMatches方法，返回的是 React.Element，渲染所有的 matches 对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__renderMatches</span>(</span><br><span class="line">    matches &amp;&amp;</span><br><span class="line">      <span class="comment">// 合并外层调用 useRoutes 得到的参数，内部的 Route 会有外层 Route（其实这也叫父 Route） 的所有匹配属性。</span></span><br><span class="line">      matches.<span class="title function_">map</span>(<span class="function">(<span class="params">match</span>) =&gt;</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, match, &#123;</span><br><span class="line">          <span class="attr">params</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, parentParams, match.<span class="property">params</span>),</span><br><span class="line">          <span class="comment">// joinPaths 函数用于合并字符串</span></span><br><span class="line">          <span class="attr">pathname</span>: <span class="title function_">joinPaths</span>([parentPathnameBase, match.<span class="property">pathname</span>]),</span><br><span class="line">          <span class="attr">pathnameBase</span>:</span><br><span class="line">            match.<span class="property">pathnameBase</span> === <span class="string">&quot;/&quot;</span></span><br><span class="line">              ? parentPathnameBase</span><br><span class="line">              : <span class="title function_">joinPaths</span>([parentPathnameBase, match.<span class="property">pathnameBase</span>]),</span><br><span class="line">        &#125;)</span><br><span class="line">      ),</span><br><span class="line">    <span class="comment">// 外层 parentMatches 部分，最后会一起加入最终 matches 参数中</span></span><br><span class="line">    parentMatches</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">matchRoutes</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">routes</span>: <span class="title class_">RouteObject</span>[],</span></span><br><span class="line"><span class="params">  <span class="attr">locationArg</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">Location</span>&gt; | <span class="built_in">string</span>, <span class="comment">// 当前匹配到的 location</span></span></span><br><span class="line"><span class="params">  basename = <span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">RouteMatch</span>[] | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 转为 path 对象</span></span><br><span class="line">  <span class="keyword">let</span> location =</span><br><span class="line">    <span class="keyword">typeof</span> locationArg === <span class="string">&quot;string&quot;</span> ? <span class="title function_">parsePath</span>(locationArg) : locationArg; <span class="comment">// 转为 path 对象</span></span><br><span class="line">  <span class="keyword">let</span> pathname = <span class="title function_">stripBasename</span>(location.<span class="property">pathname</span> || <span class="string">&quot;/&quot;</span>, basename);</span><br><span class="line">  <span class="keyword">if</span> (pathname == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> branches = <span class="title function_">flattenRoutes</span>(routes); <span class="comment">// 扁平化 routes 为一维数组，包含当前路由的权重</span></span><br><span class="line">  <span class="title function_">rankRouteBranches</span>(branches); <span class="comment">// 根据权重排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> matches = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 这边遍历，判断条件如果没有匹配到就继续，匹配到就结束，知道所有的全部遍历完</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; matches == <span class="literal">null</span> &amp;&amp; i &lt; branches.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 遍历扁平化的 routes，查看每个 branch 的路径匹配规则是否能匹配到 pathname</span></span><br><span class="line">    matches = <span class="title function_">matchRouteBranch</span>(branches[i], pathname);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_renderMatches</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">matches</span>: <span class="title class_">RouteMatch</span>[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  <span class="comment">// 如果在已有 match 的 route 内部调用，会合并父 context 的 match</span></span></span><br><span class="line"><span class="params">  <span class="attr">parentMatches</span>: <span class="title class_">RouteMatch</span>[] = []</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">React</span>.<span class="property">ReactElement</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (matches == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 生成 outlet 组件，这边就是渲染 RouteContext.Provider 组件（嵌套关系）</span></span><br><span class="line">  <span class="keyword">return</span> matches.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">outlet, match, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 有 element 就渲染 element，如果没有则默认是 &lt;Outlet /&gt;，继续渲染内嵌的 &lt;Route /&gt;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">RouteContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">children</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">match.route.element</span> !== <span class="string">undefined</span> ? <span class="attr">match.route.element</span> <span class="attr">:</span> &lt;<span class="attr">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        value=&#123;&#123;</span></span><br><span class="line"><span class="language-xml">          outlet,</span></span><br><span class="line"><span class="language-xml">          matches: parentMatches.concat(matches.slice(0, index + 1)),</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 最内层的 outlet 为 null，也就是最后的子路由</span></span><br><span class="line">  &#125;, <span class="literal">null</span> <span class="keyword">as</span> <span class="title class_">React</span>.<span class="property">ReactElement</span> | <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Params</span>&lt;<span class="title class_">Key</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [key <span class="keyword">in</span> <span class="title class_">Key</span>]: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">RouteMatch</span>&lt;<span class="title class_">ParamKey</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// params 参数，比如 :id 等</span></span><br><span class="line">  <span class="attr">params</span>: <span class="title class_">Params</span>&lt;<span class="title class_">ParamKey</span>&gt;;</span><br><span class="line">  <span class="attr">pathname</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 子路由匹配之前的路径 url，这里可以把它看做是只要以 /* 结尾路径（这是父路由的路径）中 /* 之前的部分</span></span><br><span class="line">  <span class="attr">pathnameBase</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">route</span>: <span class="title class_">RouteObject</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RouteContextObject</span> &#123;</span><br><span class="line">  <span class="comment">// 一个 ReactElement，内部包含有所有子路由组成的聚合组件，其实 Outlet 组件内部就是它</span></span><br><span class="line">  <span class="attr">outlet</span>: <span class="title class_">React</span>.<span class="property">ReactElement</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 一个成功匹配到的路由数组，索引从小到大层级依次变深</span></span><br><span class="line">  <span class="attr">matches</span>: <span class="title class_">RouteMatch</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含全部匹配到的路由，官方不推荐在外直接使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RouteContext</span> = <span class="title class_">React</span>.<span class="property">createContext</span>&lt;<span class="title class_">RouteContextObject</span>&gt;(&#123;</span><br><span class="line">  <span class="attr">outlet</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">matches</span>: [],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">RouteContext</span> <span class="keyword">as</span> UNSAFE_RouteContext &#125;;</span><br></pre></td></tr></table></figure><h3 id="Outlet"><a href="#Outlet" class="headerlink" title="Outlet"></a>Outlet</h3><blockquote><p>内部渲染 RouteContext 的 outlet 属性，本质就是用了 useOutlet</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 outlet 中传入的上下文信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OutletContext</span> = <span class="title class_">React</span>.<span class="property">createContext</span> &lt; <span class="built_in">unknown</span> &gt; <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在嵌套的 routes 中使用，这里的上下文信息是用户在使用 &lt;Outlet /&gt; 或者 useOutlet 时传入的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> useOutletContext&lt;<span class="title class_">Context</span> = <span class="built_in">unknown</span>&gt;(): <span class="title class_">Context</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">OutletContext</span>) <span class="keyword">as</span> <span class="title class_">Context</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useOutlet</span>(<span class="params"><span class="attr">context</span>?: <span class="built_in">unknown</span></span>): <span class="title class_">React</span>.<span class="property">ReactElement</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> outlet = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">RouteContext</span>).<span class="property">outlet</span>;</span><br><span class="line">  <span class="comment">// 可以看到，当 context 有值时才使用 OutletContext.Provider，如果没有值会继续沿用父路由的 OutletContext.Provider 中的值</span></span><br><span class="line">  <span class="keyword">if</span> (outlet) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">OutletContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;context&#125;</span>&gt;</span>&#123;outlet&#125;<span class="tag">&lt;/<span class="name">OutletContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> outlet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">OutletProps</span> &#123;</span><br><span class="line">  <span class="comment">// 可以传入要提供给 outlet 内部元素的上下文信息</span></span><br><span class="line">  <span class="attr">context</span>?: <span class="built_in">unknown</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Outlet</span>(<span class="params"><span class="attr">props</span>: <span class="title class_">OutletProps</span></span>): <span class="title class_">React</span>.<span class="property">ReactElement</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useOutlet</span>(props.<span class="property">context</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h3><blockquote><p>替代 history 的方案</p><ul><li>navigate 默认是 history.push</li><li>naviaget(to, { replace: true }) 等同于 history.replace\</li><li>naviaget(number) 等同于 history.go</li></ul></blockquote><h3 id="组件渲染过程总结"><a href="#组件渲染过程总结" class="headerlink" title="组件渲染过程总结"></a>组件渲染过程总结</h3><blockquote><p>BrowserRouter 举例</p></blockquote><ol><li>路由更新，触发 <code>listen</code> 事件，新城新的 <code>location</code> 对象，更新 locationContext</li><li>useRoutes 消费 <code>locationContext，locationContext</code> 的变化会重新执行 useRoutes</li><li>重新执行内部调用 <code>matchRoutes</code> 和 <code>_renderMatchers</code> 找到新的渲染分支，渲染页面</li></ol><h2 id="v5-和-v6-对比"><a href="#v5-和-v6-对比" class="headerlink" title="v5 和 v6 对比"></a>v5 和 v6 对比</h2><ol><li>组件层面: </li></ol><ul><li>v5: Router Switch Route 结构，Router -&gt; 传递状态，负责派发更新；Switch -&gt; 匹配唯一路由；Route -&gt; 真实渲染路由组件</li><li>v6: Router Routes Route 结构，Router 抽离了 context；Routes -&gt; 形成路由渲染分支，渲染路由；Route 并非渲染真实路由，而是形成路由分支结构</li></ul><ol><li>使用层面: </li></ol><ul><li>v5: 嵌套路由，配置二级路由，需要写在具体的业务组件中</li><li>v6: 在外层统一配置路由结构，结构更清晰，通过 Outlet 来实现子路由的渲染，一定程度上类似于 vue 中的 view-router。搭配新的 api</li></ul><ol><li>原理层面: </li></ol><ul><li>v5: 本质在于 Route 组件，当路由上下文 context 改变的时候，Route 组件重新渲染，然后通过匹配来确定业务组件是否渲染</li><li>v6: 本质在于 Routes 组件，当 location 上下文改变的时候，Routes 重新渲染，重新形成渲染分支，然后通过 provider 方式逐层传递 Outlet，进行匹配渲染</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 简介</title>
      <link href="/articles/react/introduce/"/>
      <url>/articles/react/introduce/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote><p>用于构建用户界面的 JavaScript 库，组件化 + 声明式，提升开发效率及复用率</p><ul><li><code>JSX</code>: 描述 UI <a href="https://zh-hans.react.dev/learn/javascript-in-jsx-with-curly-braces">(官方文档)</a></li><li><code>@babel/preset-react</code>: JSX =&gt; React.creactElement(tagName, props, children)</li><li><code>React.createElement</code>: JS 对象 =&gt; VDom</li><li><code>ReactDom</code>: 渲染真实 Dom，VDom =&gt; Dom</li><li><img src="/images/react/introduce_1.png" alt=""></li></ul></blockquote><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="function-组件"><a href="#function-组件" class="headerlink" title="function 组件"></a>function 组件</h3><blockquote><p>无状态组件，从 v16.8 引入 hooks 之后拥有状态</p></blockquote><h3 id="联系及区别"><a href="#联系及区别" class="headerlink" title="联系及区别"></a>联系及区别</h3><ol><li>相同点: 组件是 React 可复用的最小编码单位，均会返回要在页面中渲染的 React 元素。除少数极端场景外，两者基本一致</li><li>不同点: <ul><li>侧重点: 类组件基于面向对象，主打继承、生命周期等概念；函数组件基于函数式编程，主打 immutable、无副作用、引用透明等特点</li><li>性能: 类组件 shouldComponentUpdate 阻断渲染来提升性能；函数组件依靠 React.memo 缓存渲染结果来提升性能</li><li>可维护性: 由于生命周期带来的复杂度，类组件并不易于优化。函数组件轻量简单，Hooks 更细粒度的逻辑组织与复用，更能适应 React 的未来发展</li></ul></li></ol><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><blockquote><ul><li>只能在函数最外层调用 Hook ，不要在循环、条件判断或者子函数中调⽤</li><li>只能在 React 的函数组件中或⾃定义的 Hook 中 调用 Hook</li></ul></blockquote><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>State Hook: 状态帮助组件记住用户 <code>输入</code> 的信息<ul><li>使用 <code>useState</code> 声明可以直接更新的状态变量</li><li>使用 <code>useReducer</code> 在 reducer 函数中声明带有更新逻辑的 state 变量</li></ul></li><li>Context Hook: 上下文帮助组件 <code>从祖先组件接收信息，而无需将其作为 props 传递</code><ul><li>使用 <code>useContext</code> 读取订阅上下文</li></ul></li><li>Ref Hook: ref 允许组件 <code>保存一些不用于渲染的信息</code>，比如 DOM 节点或 timeout ID。更新 ref 不会重新渲染组件，<code>escape hatch</code> 机制。常搭配非 React 系统如浏览器内置 API 一同工作<ul><li>使用 <code>useRef</code> 声明 ref，可以在其中保存任何值，最常用于保存 DOM 节点</li><li>使用 <code>useImperativeHandle</code> 自定义从组件中暴露的 ref</li></ul></li><li>Effect Hook: Effect 允许组件 <code>连接到外部系统并与之同步</code>，比如处理网络、浏览器、DOM、动画、使用不同 UI 库编写的小部件以及其他非 React 代码。避免使用 Effect 协调应用程序的数据流。如果不需要与外部系统交互，那么可能不需要 Effect<ul><li>使用 <code>useEffect</code> 将组件连接到外部系统</li><li><code>useLayoutEffect</code> 在浏览器重新绘制屏幕前执行，可以在此处测量布局</li><li><code>useInsertionEffect</code> 在 React 对 DOM 进行更改之前触发，可以在此处插入动态 CSS</li></ul></li><li>性能 Hook: 跳过不必要的工作，或者有时由于屏幕确实需要更新，无法跳过重新渲染。此时可以通过将必须同步的阻塞更新与不需要阻塞用户界面的非阻塞更新分离以提高性能<ul><li>使用 <code>useMemo</code> 缓存计算代价昂贵的计算结果</li><li>使用 <code>useCallback</code> 将函数传递给优化组件之前缓存函数定义</li><li><code>useTransition</code> 允许将状态转换标记为非阻塞，并允许其他更新中断它</li><li><code>useDeferredValue</code> 允许延迟更新 UI 的非关键部分，以让其他部分先更新</li></ul></li></ol><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><ol><li>传递对象: 批处理。对相同对象的多次处理会合并成一个，并渲染最后一次处理的结果<blockquote><p>&lt; v18</p><ul><li>合成事件和生命周期方法中: 异步；setTimeout 或者原生事件处理函数中: 同步，不会批处理</li><li>useState 的更新是批处理的，而类组件的 setState 在合成事件中是批处理的，但在其他情况下可能不是</li></ul><p>v18+</p><ul><li>引入并发模式: createRoot，默认启用批处理，包括 Promise、setTimeout 等</li><li>在并发模式下，允许中断低优先级更新，确保高优先级交互更流畅，应避免依赖状态更新的即时性，始终通过 useEffect 或回调函数处理副作用</li><li>并发模式下，useState 和类组件的 setState 都会自动批处理</li><li>flushSync 强制同步更新，立即获取状态</li></ul></blockquote></li><li>传递函数: 链式调用。多个函数会放入队列并依次执行，从而可以获取实时状态</li></ol><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p><img src="/images/react/introduce_6.png" alt=""></p><h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><blockquote><ul><li>利用 memoization 技术缓存结果，它仅会在某个依赖项改变时才重新计算 memoized 值</li><li>使用 <code>Object.is</code> 将每个依赖项与其之前的值进行比较</li></ul></blockquote><h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><blockquote><p>使用场景: 子组件某个事件触发依赖调用父组件的方法进行计算，这种场景通常是父组件通过 props 将函数传给子组件，但是这样会有个问题，父组件 state 发生改变，会导致子组件重新渲染，使用 useCallback 可以避免子组件的重复渲染</p><ul><li>如果子组件为 class 组件，则要继承 <code>PureComponent</code></li><li>如果子组件是 function 组件，则要使用 <code>useMemo</code> 缓存子组件</li></ul></blockquote><h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UseReducerUsage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ADD&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(counter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;state&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;ADD&quot; &#125;)&#125;&gt;ADD<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h4><blockquote><p>实现一个能够实时获取最新值的 hook</p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">useSyncState</span>: <span class="built_in">any</span> = <span class="function">(<span class="params"><span class="attr">state</span>: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">cbRef</span>: &#123; <span class="attr">current</span>: <span class="built_in">any</span> &#125; = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(state);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    cbRef.<span class="property">current</span> &amp;&amp; cbRef.<span class="title function_">current</span>(data);</span><br><span class="line">  &#125;, [data]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    data,</span><br><span class="line">    <span class="function">(<span class="params"><span class="attr">val</span>: <span class="built_in">any</span>, <span class="attr">callback</span>: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      cbRef.<span class="property">current</span> = callback;</span><br><span class="line">      <span class="title function_">setData</span>(val);</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useSyncState;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> [data, setData] = <span class="title function_">useSyncState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setData</span>(<span class="number">1</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是最新的值: &quot;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote><p>v16.4 之前的生命周期不做演示</p></blockquote><p><img src="/images/react/introduce_2.png" alt=""></p><p>v16.4 新增的生命周期</p><blockquote><p>getDerivedStateFromProps(props, state)</p><ul><li>render 之前调用，并且在初始挂载及后续更新时都会被调用</li><li>返回⼀个对象来更新 state，如果返回 null 则不更新 state，但 render 还是会执行</li></ul><p>getSnapshotBeforeUpdate</p><ul><li>render 之后，componentDidUpdate 之前</li><li>返回值将作为参数传递给 componentDidUpdate(prevProps, prevState, snapshot)</li></ul></blockquote><p>v17 废弃的三个生命周期函数用 getDerivedStateFromProps 替代</p><blockquote><p>componentWillMount、componentWillReceiveProps、componentWillUpdate: 使用这些生命周期的代码将更有可能在未来的 React 版本中存在缺陷，特别是一旦启用了异步渲染</p></blockquote><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="中心化状态管理"><a href="#中心化状态管理" class="headerlink" title="中心化状态管理"></a>中心化状态管理</h3><blockquote><p>强调应用状态的中心化存储和管理，以及明确的数据流</p><ul><li><code>Redux / Redux Toolkit</code>: 通过 action-reducer 模式来管理状态的变更。纯函数 reducer 保证能识别新旧 state 状态变化</li><li><code>easy-peasy</code>: 在 Redux 之上构建，提供更简单的 API</li><li><code>react-redux</code>: Provider 为后代组件提供 store，connect 为组件提供数据和变更方法</li><li><img src="/images/react/introduce_3.png" alt=""></li></ul></blockquote><h3 id="响应式状态管理"><a href="#响应式状态管理" class="headerlink" title="响应式状态管理"></a>响应式状态管理</h3><blockquote><p>调响应式和自动的状态更新机制，通常采用观察者模式</p><ul><li><code>MobX / mobx-state-tree</code>: 基于响应式和可观察状态的自动管理</li></ul></blockquote><h3 id="原子化或声明式状态管理"><a href="#原子化或声明式状态管理" class="headerlink" title="原子化或声明式状态管理"></a>原子化或声明式状态管理</h3><blockquote><p>将状态分解为更小的、可组合的单位，允许直接的读写操作和声明式的依赖管理</p><ul><li><code>Recoil</code>: 使用原子和选择器来管理状态，支持并行和异步操作</li><li><code>jotai</code>: 类似于 Recoil，提供了更简洁的 API 和概念</li></ul></blockquote><h4 id="Recoil-简介"><a href="#Recoil-简介" class="headerlink" title="Recoil 简介"></a>Recoil 简介</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><blockquote><p>使用 Recoil 的组件需要使用 <code>RecoilRoot</code> 组件包裹</p></blockquote><h5 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h5><blockquote><p>Atom 是一种新的状态，和传统的 state 不同，可以被任何组件订阅，当一个 Atom 被更新时，每个被订阅的组件都会用新的值来重新渲染</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> orgState = <span class="title function_">atom</span>(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;orgState&quot;</span>,</span><br><span class="line">  <span class="attr">default</span>: <span class="string">&quot;百度&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="订阅和更新状态"><a href="#订阅和更新状态" class="headerlink" title="订阅和更新状态"></a>订阅和更新状态</h5><blockquote><ul><li><code>useRecoilState</code>: 类似 useState 的一个 Hook，可以取到 atom 的值以及 setter 函数</li><li><code>useSetRecoilState</code>: 只获取 setter 函数，如果只使用了这个函数，状态变化不会导致组件重新渲染</li><li><code>useRecoilValue</code>: 只获取状态</li></ul></blockquote><h5 id="派生状态"><a href="#派生状态" class="headerlink" title="派生状态"></a>派生状态</h5><blockquote><p>selector 表示一段派生状态，建立依赖于其他 atom 的状态。它有一个强制性的 get 函数，其作用与 redux 的 reselect， MobX 的 @computed, vue 的 computed 相似</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depState = <span class="title function_">selector</span>(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;depState&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">&#123; get &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="title function_">get</span>(orgState);</span><br><span class="line">    <span class="keyword">return</span> dep;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDep</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="title function_">useRecoilValue</span>(depState);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>dep: &#123;dep&#125;<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异步状态"><a href="#异步状态" class="headerlink" title="异步状态"></a>异步状态</h5><blockquote><p>选择器 get 回调中返回 Promise ，而不是返回值本身</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = <span class="title function_">selector</span>(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;userName&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">async</span> (&#123; get &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">userID</span>: <span class="title function_">get</span>(userIDState),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CurrentUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userName = <span class="title function_">useRecoilValue</span>(userInfo);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态机和状态管理模式"><a href="#状态机和状态管理模式" class="headerlink" title="状态机和状态管理模式"></a>状态机和状态管理模式</h3><blockquote><p>状态机（FSM）和状态图（Statecharts）的概念来管理状态的复杂逻辑和转换</p><ul><li><code>XState</code>: 提供了有限状态机和状态图的实现，适用于复杂状态逻辑的管理</li></ul></blockquote><h3 id="轻量级和灵活的状态管理"><a href="#轻量级和灵活的状态管理" class="headerlink" title="轻量级和灵活的状态管理"></a>轻量级和灵活的状态管理</h3><blockquote><p>提供了简单直接的状态管理功能，不强制采用特定的架构模式</p><ul><li><code>Zustand</code>: 提供了简单、轻量级的状态管理，可以用于中心化或非中心化的数据流</li></ul></blockquote><h3 id="React-自带的状态管理工具"><a href="#React-自带的状态管理工具" class="headerlink" title="React 自带的状态管理工具"></a>React 自带的状态管理工具</h3><blockquote><p>框架本身提供的状态管理机制，适合轻量级的状态管理需求</p><ul><li><code>useState / useReducer</code>: React 内置的 Hooks，用于组件内部状态管理</li><li><code>useContext + useReducer</code>: 组合使用这两个 Hooks 可以实现跨组件的状态共享，类似于 Redux</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
