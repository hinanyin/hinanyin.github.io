<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>v8 引擎简介 | Nanyin の 小屋</title><meta name="author" content="南音"><meta name="copyright" content="南音"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="浏览器架构Chrome 多进程架构  浏览器进程: 地址栏，书签，回退与前进按钮，以及处理 web 浏览器中网络请求、文件访问等不可见的部分 渲染进程: 控制标签页内网站渲染 插件进程: 控制站点使用的任意插件，如 Flash GPU 进程: 处理独立于其它进程的 GPU 任务   多渲染进程带来的优势   稳定性: 一般情况下，浏览器会给每个标签页分配一个渲染进程，从而保证每个标签页能独立运行，">
<meta property="og:type" content="article">
<meta property="og:title" content="v8 引擎简介">
<meta property="og:url" content="https://nanyin.me/articles/front-tech/v8/index.html">
<meta property="og:site_name" content="Nanyin の 小屋">
<meta property="og:description" content="浏览器架构Chrome 多进程架构  浏览器进程: 地址栏，书签，回退与前进按钮，以及处理 web 浏览器中网络请求、文件访问等不可见的部分 渲染进程: 控制标签页内网站渲染 插件进程: 控制站点使用的任意插件，如 Flash GPU 进程: 处理独立于其它进程的 GPU 任务   多渲染进程带来的优势   稳定性: 一般情况下，浏览器会给每个标签页分配一个渲染进程，从而保证每个标签页能独立运行，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nanyin.me/img/covers/uVz3uC4fYBEfFOAI.webp">
<meta property="article:published_time" content="2025-04-02T07:29:01.000Z">
<meta property="article:modified_time" content="2025-04-10T08:53:35.800Z">
<meta property="article:author" content="南音">
<meta property="article:tag" content="引擎">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nanyin.me/img/covers/uVz3uC4fYBEfFOAI.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "v8 引擎简介",
  "url": "https://nanyin.me/articles/front-tech/v8/",
  "image": "https://nanyin.me/img/covers/uVz3uC4fYBEfFOAI.webp",
  "datePublished": "2025-04-02T07:29:01.000Z",
  "dateModified": "2025-04-10T08:53:35.800Z",
  "author": [
    {
      "@type": "Person",
      "name": "南音",
      "url": "https://nanyin.me/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://nanyin.me/articles/front-tech/v8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容: ${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 南音","link":"链接: ","source":"来源: Nanyin の 小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'v8 引擎简介',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/footer-beautify-runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/index_bg.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-brands fa-bilibili"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/talk2me/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/covers/uVz3uC4fYBEfFOAI.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Nanyin の 小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">v8 引擎简介</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-brands fa-bilibili"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/talk2me/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">v8 引擎简介</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-02T07:29:01.000Z" title="发表于 2025-04-02 15:29:01">2025-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-10T08:53:35.800Z" title="更新于 2025-04-10 16:53:35">2025-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%A4%A7%E5%89%8D%E7%AB%AF/">大前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="waline-pageview-count" data-path="/articles/front-tech/v8/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/articles/front-tech/v8/#post-comment"><span class="waline-comment-count" data-path="/articles/front-tech/v8/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-04-10 16:53:35&quot;}" hidden></div><h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><h3 id="Chrome-多进程架构"><a href="#Chrome-多进程架构" class="headerlink" title="Chrome 多进程架构"></a>Chrome 多进程架构</h3><p><img src="/images/front-tech/v8_1.gif" alt=""></p>
<ul>
<li>浏览器进程: 地址栏，书签，回退与前进按钮，以及处理 web 浏览器中网络请求、文件访问等不可见的部分</li>
<li>渲染进程: 控制标签页内网站渲染</li>
<li>插件进程: 控制站点使用的任意插件，如 Flash</li>
<li>GPU 进程: 处理独立于其它进程的 GPU 任务</li>
</ul>
<blockquote>
<p>多渲染进程带来的优势</p>
</blockquote>
<ul>
<li>稳定性: 一般情况下，浏览器会给每个标签页分配一个渲染进程，从而保证每个标签页能独立运行，互不影响。但由于受设备的内存及 CPU 能力影响，<code>当 Chrome 运行时达到限制时，会开始在同一站点的不同标签页上运行同一进程</code></li>
<li>沙箱化: 限制与保护进程的特定权限与能力</li>
</ul>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><blockquote>
<p>内核即 <code>Rendering Engine</code>，渲染引擎，负责对网页语法的解析，比如 HTML、JavaScript，并渲染到网页上</p>
</blockquote>
<h4 id="排版渲染引擎"><a href="#排版渲染引擎" class="headerlink" title="排版渲染引擎"></a>排版渲染引擎</h4><ul>
<li><code>KHTML</code>: HTML 网页排版引擎之一，由 KDE 所开发。后来经苹果扩展开源，衍生出 <code>WebCore</code> 及 <code>WebKit</code> 引擎</li>
<li><code>WebCore</code>: 如 Safari 浏览器</li>
</ul>
<h4 id="内核引擎"><a href="#内核引擎" class="headerlink" title="内核引擎"></a>内核引擎</h4><ul>
<li><code>Trident</code>: IE</li>
<li><code>Gecko</code>: Firefox</li>
<li><code>WebKit</code>: 诞生于 1998 年，并于 2005 年由 Apple 公司开源，Safari、Google Chrome、傲游 3、猎豹浏览器、百度浏览器</li>
<li><code>Presto</code>: 早期 Opera 的内核，现在主要是在手机平台 Opera mini</li>
<li><code>Chromium</code>: 基于 webkit，早期 chrome 的内核，那时候还叫 Chromium 浏览器</li>
<li><code>Blink</code>: 基于 Webkit2 分支，新版 Opera (15 及往后版本) 和移动端上使用较多</li>
</ul>
<p><img src="/images/front-tech/v8_2.png" alt=""></p>
<ul>
<li><code>WebKit Embedding API</code>: 负责浏览器 UI 与 WebKit 进行交互的部分</li>
<li><code>WebKit Ports</code>: 让 Webkit 更加方便的移植到各个操作系统、平台上，提供的一些调用 Native Library 接口</li>
</ul>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><blockquote>
<p>将 js 代码编译成 CPU 认识的指令集，同时负责执行以及管理内存</p>
<ul>
<li>解释形语言(如 js): 由引擎直接读取源码，一边编译一边执行，效率相对较低</li>
<li>编译型语言(如 c++): 将源码直接编译成可直接执行的代码，执行效率更高</li>
</ul>
</blockquote>
<ol>
<li><p><code>V8</code></p>
<ul>
<li>由 Google 开发，广泛应用于 Chrome 浏览器和 Node.js 环境</li>
<li>采用<code>即时编译</code> (JIT just in time compilation) 技术，<strong>混合编译执行和解释执行这两种手段</strong>, 启动过程中采用解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码。同时，V8 具备强大的内存管理和垃圾回收机制，可有效减少内存泄漏问题</li>
<li>适用于对性能要求较高的 Web 应用开发、服务器端开发 (如 Node.js 项目) 等</li>
</ul>
</li>
<li><p><code>JavaScriptCore</code></p>
<ul>
<li>由 Apple 开发，是 Safari 浏览器的默认引擎</li>
<li>高度优化，具有出色的性能和较低的内存占用。JavaScriptCore 支持 ECMAScript 标准的最新特性，并且与苹果的操作系统和设备紧密集成</li>
<li>主要用于苹果的 Safari 浏览器、iOS 系统中的 WebView 以及其他基于 WebKit 内核的浏览器和应用程序</li>
</ul>
</li>
<li><p><code>SpiderMonkey</code></p>
<ul>
<li>由 Mozilla 开发，最早的 JavaScript 引擎之一，Firefox 浏览器的默认引擎</li>
<li>对 ECMAScript 标准的支持非常全面，并且不断引入新的特性和优化。具备良好的调试和开发工具支持，方便开发者进行代码调试和性能优化</li>
<li>主要应用于 Firefox 浏览器及其相关的开发项目</li>
</ul>
</li>
<li><p><code>Chakra</code></p>
<ul>
<li>由微软开发，曾用于 Internet Explorer 和 Microsoft Edge 浏览器 (旧版)</li>
<li>在 Windows 平台上具有良好的性能和兼容性，支持许多微软特有的 JavaScript 扩展</li>
<li>主要用于微软的浏览器和相关的 Windows 应用程序。不过，新版的 Microsoft Edge 已经切换到了基于 Chromium 的架构，使用 V8 引擎</li>
</ul>
</li>
<li><p><code>Hermes</code></p>
<ul>
<li>由 Facebook 开发，专为 React Native 应用设计</li>
<li>体积小、启动速度快，能够显著减少应用的启动时间和内存占用。采用了静态编译技术，将 JavaScript 代码编译成字节码，在运行时直接执行字节码，提高了执行效率</li>
<li>主要用于 React Native 开发的移动应用</li>
</ul>
</li>
</ol>
<p><img src="/images/front-tech/v8_7.webp" alt=""></p>
<h2 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h2><p><img src="/images/front-tech/v8_3.png" alt=""></p>
<h3 id="编译及运行"><a href="#编译及运行" class="headerlink" title="编译及运行"></a>编译及运行</h3><p><img src="/images/front-tech/v8_6.webp" alt=""></p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><blockquote>
<p>Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code<br>Machine Code 可能会被还原成 Bytecode，此过程称为 <code>优化回滚</code> (Deoptimization)。比如 Ignition 收集的信息是错误的<br><code>热点标记</code>：如果代码被调用多次 (<code>反馈向量</code>标记)，则可能会被识别为热点代码，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code (已优化的机器码)，以提高代码的执行性能</p>
</blockquote>
<p><img src="/images/front-tech/v8_4.png" alt=""></p>
<ol>
<li><p>scanner</p>
<ul>
<li>词法分析器，将 js 源码转换成有意义的词 (token) 形成的数组</li>
</ul>
</li>
<li><p>parser</p>
<ul>
<li>语法分析器，将 token 数组按照特定的格式转换成对象，供 Ignition (解释器) 引擎生成字节码</li>
</ul>
</li>
<li><p>Ignition</p>
<ul>
<li>解释器，负责将 AST 转换为 Bytecode，解释执行 Bytecode；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；解释器执行时主要有四个模块，内存中的字节码、寄存器、栈、堆<ul>
<li>基于栈 (Stack-based): 保存函数参数、中间运算结果、变量等。比如 Java 虚拟机，.Net 虚拟机，还有早期的 V8 虚拟机</li>
<li>基于寄存器 (Register-based): 保存参数、中间计算结果。现在的 V8 虚拟机</li>
</ul>
</li>
</ul>
</li>
<li><p>TurboFan</p>
<ul>
<li>编译器，利用 Ignition 所收集的类型信息，将 Bytecode 转换为优化的汇编代码</li>
</ul>
</li>
<li><p>Orinoco</p>
<ul>
<li>垃圾回收模块，将程序不再需要的内存空间回收</li>
</ul>
</li>
</ol>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p><img src="/images/front-tech/v8_5.png" alt=""></p>
<ul>
<li>Execution: 辅助类，包含一些重要函数，辅助进入和执行 js 代码</li>
<li>JSFunction: 需要执行的 js 函数表示类</li>
<li>Runtime: 运行本地代码的辅助类，主要提供运行时所需的辅助函数，如属性访问、类型转换、编译、算术、位操作、比较、正则表达式等</li>
<li>Heap: 运行本地代码需要使用的内存堆类</li>
<li>MarkCompactCollector: 垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程</li>
<li>SweeperThread：负责垃圾回收的线程</li>
</ul>
<h3 id="三大核心优化技术"><a href="#三大核心优化技术" class="headerlink" title="三大核心优化技术"></a>三大核心优化技术</h3><ol>
<li><strong>惰性编译</strong>: 快速生成可执行的中间代码 (字节码)</li>
<li><strong>内联缓存</strong>: 在字节码执行期间，记录对象属性的隐藏类和偏移量</li>
<li><strong>隐藏类</strong>: 为内联缓存提供数据结构支持，实现属性快速访问</li>
<li>热点代码最终被 <strong>优化编译器</strong> 转换为高效机器码</li>
</ol>
<div class="tip bell"><p>性能优化建议</p>
</div>
<ol>
<li><p>保持对象结构稳定: 避免在构造函数外动态增删属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">const</span> p = &#123;&#125;;</span><br><span class="line">p.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">p.<span class="property">y</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>维持类型一致性: 避免同一属性存储不同类型数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐（破坏 IC）</span></span><br><span class="line">obj.<span class="property">field</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">field</span> = <span class="string">&quot;text&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用函数内联: 小函数更易被内联优化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125; <span class="comment">// 可能被内联</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="惰性编译"><a href="#惰性编译" class="headerlink" title="惰性编译"></a>惰性编译</h4><blockquote>
<p>Lazy Compilation</p>
</blockquote>
<ul>
<li>延迟编译：不一次性编译所有代码，而是在函数首次被执行时才编译</li>
<li>分层编译：先快速生成低优化字节码 (Ignition 解释器)，热点代码再优化 (TurboFan 编译器)</li>
<li>启动速度快：避免编译未使用的代码 (如大型库中未调用的函数)；节省内存</li>
</ul>
<h4 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h4><blockquote>
<p>Inline Cache (IC): 通过缓存对象操作的类型信息，将动态语言的特征访问转化为接近静态语言的效率，加速查找效率及运算</p>
</blockquote>
<ul>
<li>缓存对象属性的访问信息：针对同一属性的多次访问，直接复用之前的查找结果。减少了属性查找时间，但如果<code>属性类型变化会破坏优化</code>，比如属性从数字类型变成字符串类型，则需要重新查找隐藏类和偏移量</li>
<li>多态优化：跟踪不同类型的对象访问路径 (单态/多态/超态)<ul>
<li><code>单态内联缓存</code>: 传参结构固定的情况，所有 obj 为同一隐藏类，速度最快</li>
<li><code>多态内联缓存</code>: 传参结构不固定的情况，2-4 种隐藏类，速度较快</li>
<li><code>超态内联缓存</code>: 传参结构不固定的情况，&gt;4 种隐藏类，退化为哈希查找，速度慢<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超态示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">polymorphic</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="property">x</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用5种不同隐藏类的对象调用</span></span><br><span class="line">[A, B, C, D, E].<span class="title function_">forEach</span>(<span class="function">(<span class="params">cls</span>) =&gt;</span> <span class="title function_">polymorphic</span>(<span class="keyword">new</span> <span class="title function_">cls</span>()));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>多级处理状态</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th>处理方式</th>
<th>性能</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>未初始化</td>
<td>完整查找属性</td>
<td>慢 (100ms)</td>
<td>首次执行</td>
</tr>
<tr>
<td>预单态</td>
<td>记录 1 种隐藏类</td>
<td>较快</td>
<td>第 2 次相同类型访问</td>
</tr>
<tr>
<td>单态</td>
<td>直接使用缓存偏移量</td>
<td>极快 (1ms)</td>
<td>多次相同类型访问</td>
</tr>
<tr>
<td>多态</td>
<td>检查 2-4 种缓存类型</td>
<td>快</td>
<td>少量不同类型交替</td>
</tr>
<tr>
<td>超态</td>
<td>退化为哈希查找</td>
<td>慢</td>
<td>&gt;4 种类型</td>
</tr>
<tr>
<td>泛型</td>
<td>完全通用处理</td>
<td>最慢</td>
<td>无法预测的复杂情况</td>
</tr>
</tbody>
</table>
</div>
<h5 id="反馈向量"><a href="#反馈向量" class="headerlink" title="反馈向量"></a>反馈向量</h5><blockquote>
<p>IC 的核心数据结构，系统性地收集和优化类型反馈信息，实现高性能属性访问的关键</p>
</blockquote>
<ul>
<li><strong>动态类型记录器</strong>: 在字节码执行期间持续记录操作数的类型信息</li>
<li><strong>优化决策依据</strong>: 为 TurboFan 编译器提供热代码的类型特征</li>
<li><strong>内联缓存载体</strong>: 存储 IC 的状态和跳转目标地址</li>
<li><strong>热代码编译触发</strong>: 当反馈向量显示某操作达到阈值，触发 TurboFan 热点优化</li>
</ul>
<blockquote>
<p>反馈向量结构</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V8源码中的关键结构（简化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeedbackVector</span> &#123;</span><br><span class="line">  uint32_t slot_count_;       <span class="comment">// 槽位数量</span></span><br><span class="line">  <span class="title class_">FeedbackSlot</span>* slots_;       <span class="comment">// 反馈槽数组</span></span><br><span class="line">  <span class="title class_">MaybeObject</span>* metadata_;     <span class="comment">// 关联的元数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>槽位类型</th>
<th>记录内容</th>
<th>对应操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOAD_IC</td>
<td>属性加载的隐藏类和偏移量</td>
<td>obj.property</td>
</tr>
<tr>
<td>STORE_IC</td>
<td>属性存储的值信息</td>
<td>obj.property = val</td>
</tr>
<tr>
<td>CALL_IC</td>
<td>函数调用目标</td>
<td>func()</td>
</tr>
<tr>
<td>BINARY_OP_IC</td>
<td>运算操作数类型</td>
<td>a + b</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>属性访问优化过程</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getProp</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="property">x</span>; <span class="comment">// IC slot记录obj的类型信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次执行：未初始化状态</span></span><br><span class="line"><span class="title function_">getProp</span>(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;); <span class="comment">// 记录隐藏类C1和偏移量0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次执行：单态状态</span></span><br><span class="line"><span class="title function_">getProp</span>(&#123; <span class="attr">x</span>: <span class="number">2</span> &#125;); <span class="comment">// 快速路径直接访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同类型对象：转为多态</span></span><br><span class="line"><span class="title function_">getProp</span>(&#123; <span class="attr">x</span>: <span class="string">&quot;str&quot;</span> &#125;); <span class="comment">// 添加新类型到反馈向量</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>反馈向量内存布局</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FeedbackVector [0x1a50]</span><br><span class="line">├── Slot 0: LOAD_IC</span><br><span class="line">│   ├── Map: 0x1b20 (HiddenClass C1)</span><br><span class="line">│   └── Offset: 12</span><br><span class="line">├── Slot 1: CALL_IC</span><br><span class="line">│   └── Target: function@0x2c10</span><br><span class="line">└── Slot 2: BINARY_OP_IC</span><br><span class="line">    ├── Lhs: SMALL_INTEGER</span><br><span class="line">    └── Rhs: STRING</span><br></pre></td></tr></table></figure>
<h4 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h4><blockquote>
<p>Hide Class: 旨在将 JavaScript 中的<code>对象静态化</code>，提升对象的属性访问速度。假设对象创建好了之后就不会添加和删除属性，从而给对象创建隐藏类。在查找属性时会先去隐藏类中查找该属性相对于它的对象的偏移量，加上属性类型，直接从内存中取出属性值</p>
</blockquote>
<ol>
<li><p>动态创建对象的内存布局描述 (即反馈向量中的 <code>map</code> 属性)：相同结构的对象 (<code>相同的属性名称</code>、<code>相等的属性个数</code>)共享隐藏类 (map 指向同一个隐藏类)，记录属性偏移量，通过偏移量直接定位内存地址。</p>
</li>
<li><p>转换机制：对象属性变化时，隐藏类会按规则转换或者直接重构</p>
<ul>
<li><code>隐藏类转换</code>: 隐藏类通过<code>链式转换</code>来记录对象结构的变化。每个隐藏类记录当前对象的结构，并包含指向可能转换路径的指针。<code>相同修改路径</code>的对象会共享隐藏类链</li>
<li><code>重构隐藏类</code>: 当对象结构发生<code>非线性变化</code>时，转换链会断裂，触发完全重建。比如删除属性、动态属性添加顺序不一致 (属性添加顺序不同会生成不同的隐藏类链)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录转换路径</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>; <span class="comment">// 隐藏类 C0 → C1（添加属性 x）</span></span><br><span class="line">obj.<span class="property">y</span> = <span class="number">2</span>; <span class="comment">// 隐藏类 C1 → C2（添加属性 y），复用上一步的转换路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">x</span>; <span class="comment">// 隐藏类退化为慢路径（哈希表模式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态属性添加顺序不一致</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj[a] = <span class="number">1</span>; <span class="comment">// 隐藏类依赖 a/b 的值</span></span><br><span class="line">  obj[b] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createObj</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>); <span class="comment">// 隐藏类 C0 → C1 → C2</span></span><br><span class="line"><span class="title function_">createObj</span>(<span class="string">&quot;y&quot;</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">// 触发另一条隐藏类链</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最佳实践</p>
<ul>
<li>使用字面量初始化对象时，保证属性的顺序一致</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x; <span class="comment">// 所有实例共享相同隐藏类链</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免删除属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">property</span>;</span><br><span class="line"><span class="comment">// 推荐：设为 null 或 undefined</span></span><br><span class="line">obj.<span class="property">property</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>提前初始化所有属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优于动态添加</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="literal">null</span>, <span class="attr">y</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">y</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="V8-与-JS"><a href="#V8-与-JS" class="headerlink" title="V8 与 JS"></a>V8 与 JS</h3><h4 id="对象内属性"><a href="#对象内属性" class="headerlink" title="对象内属性"></a>对象内属性</h4><ul>
<li><strong>排序属性</strong>: 对象中的数字属性，V8 中被称为 elements，按照顺序存放</li>
<li><strong>常规属性</strong>：字符串属性，称为 properties，按照创建时的顺序保存</li>
<li>使用两个线性数据结构来分别保存排序属性和常规属性，同时 v8 将部分常规属性直接存储到对象本身，称为<code>对象内属性</code> (in-object properties)，不过此类属性一般有限 (10-20 个)</li>
</ul>
<h4 id="快属性-慢属性"><a href="#快属性-慢属性" class="headerlink" title="快属性 / 慢属性"></a>快属性 / 慢属性</h4><ol>
<li><p>快属性: 保存在线性数据结构中的属性</p>
<ul>
<li>访问速度快，但是添加或删除属性效率较低</li>
</ul>
</li>
<li><p>慢属性: 如果一个对象的属性过多，对象内部会使用独立的非线性数据结构 (字典) 作为属性存储容器</p>
<ul>
<li>读取速度慢，为提升查找效率，V8 在对象中添加了两个隐藏属性，排序属性和常规属性</li>
</ul>
</li>
<li><p>如果对象中的属性过多，或者存在反复添加或者删除属性的操作，V8 会将线性的存储模式 (快属性)降级为非线性的字典存储模式 (慢属性)，虽然降低了查找速度，但是提升了修改对象的属性的速度</p>
</li>
</ol>
<h4 id="动态、静态作用域"><a href="#动态、静态作用域" class="headerlink" title="动态、静态作用域"></a>动态、静态作用域</h4><ul>
<li><strong>静态作用域</strong>: <code>静态语言</code>，符号之间的引用关系能够根据程序代码在编译时就确定清楚，运行时不变，由程序代码决定，大多数语言都是静态作用域的。直接通过<code>偏移量</code>查询来查询对象的属性值，执行效率高</li>
<li><strong>动态作用域</strong>: <code>动态语言</code>，变量引用跟变量声明不是在编译时就确定了的。运行时，在运行环境中动态地找一个相同名称的变量。在 macOS 或 Linux 中用的 bash 脚本语言，是动态作用域的</li>
</ul>
<h4 id="惰性解析"><a href="#惰性解析" class="headerlink" title="惰性解析"></a>惰性解析</h4><ol>
<li><p>比如在 <code>预解析</code> 阶段</p>
<ul>
<li><strong>加速代码的启动速度</strong></li>
<li>延迟解析函数体: 解析器在解析的过程中，如果遇到函数声明，会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。避免了过多的代码增加编译时间和防止中间代码一直占用内存</li>
</ul>
</li>
<li><p>最佳实践</p>
<ul>
<li>模块化组织代码: 保持函数职责单一</li>
<li>避免 IIFE 滥用: 立即执行函数会强制全解析</li>
<li>合理使用动态导入</li>
</ul>
</li>
</ol>
<h4 id="预解析-全解析"><a href="#预解析-全解析" class="headerlink" title="预解析 / 全解析"></a>预解析 / 全解析</h4><ol>
<li><p>预解析: Pre-Parser</p>
<ul>
<li><strong>跳过函数体</strong>: 快速扫描函数签名和语法结构，如果有语法错误则向外抛出</li>
<li><strong>收集变量声明</strong>: 检查函数内部是否引用了外部变量，如果有预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，解决闭包所带来的问题</li>
<li>不生成 AST 或字节码</li>
<li><strong>位置标记</strong>: 记录函数体在源码中的位置范围</li>
</ul>
</li>
<li><p>全解析: Full Parser</p>
<ul>
<li>当函数首次被调用时、作为构造函数时、动态使用时触发</li>
<li>生成完整 AST 和字节码</li>
<li>进行作用域分析</li>
</ul>
</li>
</ol>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><blockquote>
<p>后进先出，同时栈空间连续，在需要分配空间和销毁空间操作时，只需移动下指针，非常适合管理函数调用<br>保存基本数据类型及对象指针，管理 js 函数调用</p>
</blockquote>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><blockquote>
<p>一种树形的存储结构，用来存储对象类型的离散的数据</p>
</blockquote>
<ol>
<li><p><code>new space</code>: 新生代内存区</p>
<ul>
<li>分为两个 semispace, from space 和 to space, 每个大小默认为 16M, 所以 new space 通常大小为 32M, 新创建的对象、临时变量、闭包变量、短生命周期的数据等会放入其中一个处于工作状态的 space</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// 初始分配在新生代</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>old space</code>: 老生代内存区</p>
<ul>
<li>通常会持久化的保存对象, 分为两个区域, old pointer space 和 old data space, 分别用来存放 GC 后还存活的指针信息和数据信息。一般有长期存活的对象、大对象、全局变量、闭包长期引用的变量、DOM 相关对象等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">cache</span> = &#123; <span class="attr">data</span>: <span class="string">&quot;长期存储&quot;</span> &#125;; <span class="comment">// 长期引用的对象，最终晋升到老生代</span></span><br><span class="line"><span class="keyword">const</span> bigArray = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// 大数组直接进入老生代</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>large object space</code>: 大对象区</p>
<ul>
<li>存放体积超越其他区大小的对象, 主要为了避免大对象的拷贝, 使用该空间专门存储大对象</li>
</ul>
</li>
<li><p><code>code Space</code>: 代码区</p>
<ul>
<li>存放代码对象, 最大限制为 512M, 也是唯一拥有执行权限的内存</li>
</ul>
</li>
<li><p><code>Cell space, property cell space, map space</code>: 单元区, 属性单元区, Map 区</p>
<ul>
<li>Map 空间存放对象的 Map 信息 (即隐藏类 Hiden Class) 最大限制为 8M; 每个 Map 对象固定大小, 为了快速定位, 单独出空间</li>
</ul>
</li>
</ol>
<p><img src="/images/front-tech/v8_8.png" alt=""></p>
<div class="tip success"><p>new space 和 old space</p>
</div>
<ol>
<li><p>new space 置换过程</p>
<ul>
<li>假设新创建对象分配到 from space</li>
<li>程序继续执行不断向 from space 中添加新的对象信息, 将要达到存储上限时, V8 垃圾回收机制开始清理 from 中不再被使用的对象 (此时称 <code>Minor GC</code>，<code>Eden</code> 区将满时触发，<code>Survivor</code> 区将满时不会触发，速度快，但会暂停主线程 (<code>Stop-the-World</code>) )</li>
<li>清理后将所有仍然存活的对象复制到 to space, 然后删除所有 from space 中的对象</li>
<li>此时程序继续执行向 to space 中添加新的对象信息, 重复上述过程</li>
</ul>
</li>
<li><p>old space</p>
<ul>
<li>程序运行一段时间后新生代内存区中仍存活的对象，终于满足了晋升的条件，转移到了老生代内存区</li>
<li>再经过一段时间, 对象不再被引用, 同时老生代内存区域空间被占用了很多的空间, V8 会在老生代里面进行遍历，给这些对象打上标记</li>
<li>为避免一次回收占用太多时间, V8 会分批回收有标记的待清理的对象 (此时称 <code>Major GC / Full GC</code>，会遍历整个堆，可能造成明显卡顿)</li>
</ul>
</li>
</ol>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote>
<p><code>代际假说</code> (The Generational Hypothesis) 是垃圾回收领域中的一个重要术语， V8 的垃圾回收的策略也是建立在该假说的基础之上</p>
<ul>
<li>大部分对象在内存中存在的时间很短，很多对象一经分配内存，很快就变得不可访问</li>
<li>不死的对象，会活的更久，比如全局的 window、DOM、Web API 等对象</li>
</ul>
</blockquote>
<h4 id="垃圾数据"><a href="#垃圾数据" class="headerlink" title="垃圾数据"></a>垃圾数据</h4><blockquote>
<p>从 GC Roots 对象出发，遍历 GC Root 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据<br>通常的 GC Roots 对象</p>
<ul>
<li>全局的 <code>window</code> 对象，包括每个 iframe 中的</li>
<li>文档 DOM 树</li>
<li>存放在栈上的变量</li>
</ul>
</blockquote>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol>
<li>通过<code>可访问性</code> (reachability) 算法，标记 GC Root 空间中的活动对象 (可访问的 reachable)和非活动对象 (不可访问的 unreachable)</li>
<li>回收非活动对象所占据的内存</li>
<li>针对主垃圾回收器做内存碎片整理</li>
</ol>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h5><blockquote>
<p><code>Scavenge</code>, 负责新生代区域的垃圾回收</p>
</blockquote>
<p>针对新生代的置换过程，随着程序的运行，某些对象一直在被使用会持续的积压在新生代区域，为了解决这个问题，V8 采用了 <code>晋升机制</code>，将满足条件的对象放到老生代内存区中存储，释放新生代内存区域的空间。有以下条件</p>
<ul>
<li>经历过一次 Scavenge 算法，且并未被标记清除的，也就是经过一次翻转置换操作的对象</li>
<li>在进行翻转置换时，被复制的对象大于 to space 空间的 25%</li>
</ul>
<h5 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h5><blockquote>
<p><code>Mark-Sweep</code> &amp; <code>Mark-Compact</code>, 负责老生代区域的垃圾回收, 通常会有在新生代晋升后的对象以及初始占用空间就很大的对象会存储在老生代内存区</p>
</blockquote>
<ol>
<li><code>Mark-Sweep</code>: 标记-清除。只需遍历存活对象，不移动内存，适合大多数情况，但是回收后会产生不连续的内存块，可能无法分配大对象；全堆扫描时，JS 主线程会暂停 (<code>Stop-the-World</code>)<ul>
<li>标记阶段：从根对象 (全局变量、活动函数栈等) 出发，递归遍历所有可访问的对象，并标记为“存活”</li>
<li>清除阶段：遍历整个堆内存，回收所有未被标记的对象，释放其内存</li>
</ul>
</li>
</ol>
<p><img src="/images/front-tech/v8_9.png" alt=""></p>
<ol>
<li><code>Mark-Compact</code>: 标记-整理。整理后内存连续，可分配更大对象，避免了碎片化可能产生的 <code>OOM</code> 问题。但是移动对象和更新引用比 Mark-Sweep 更耗时；需要计算新地址并更新所有引用<ul>
<li>标记阶段：与 <code>Mark-Sweep</code> 相同，先标记所有存活对象</li>
<li>整理阶段：将所有存活对象向一端移动，并更新引用地址，使剩余空间连续</li>
</ul>
</li>
</ol>
<h4 id="垃圾回收优化策略"><a href="#垃圾回收优化策略" class="headerlink" title="垃圾回收优化策略"></a>垃圾回收优化策略</h4><blockquote>
<p>为了优化垃圾回收产生的 <code>STW</code> 时间，V8 启动了代号为 <code>Orinoco</code> 的垃圾回收子系统来进行优化</p>
</blockquote>
<ol>
<li><p>Orinoco 的核心优化目标</p>
<ul>
<li>减少主线程停顿时间：避免长时间阻塞 JavaScript 执行</li>
<li>利用多核 CPU：通过并行和并发提高 GC 效率</li>
<li>分代回收策略：针对新生代和老生代采用不同算法</li>
</ul>
</li>
<li><p>Orinoco 的三大垃圾回收技术: <code>Parallel</code>, <code>Incremental</code>, <code>Concurrent</code></p>
</li>
<li><p>Orinoco 的分代回收策略</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>分代</th>
<th>算法</th>
<th>Orinoco 优化</th>
<th>STW 时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>新生代</td>
<td>Scavenge (复制算法)</td>
<td>并行回收 (多线程复制存活对象)</td>
<td>极短</td>
</tr>
<tr>
<td>老生代</td>
<td>Mark-Sweep-Compact</td>
<td>增量标记 + 并发标记/整理</td>
<td>显著减少</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h5><blockquote>
<p>并行回收。在主线程暂停 (STW) 期间，使用多个辅助线程同时执行垃圾回收任务<br>比如同时进行新生代 Scavenge 算法和老生代的标记阶段 (Marking)</p>
</blockquote>
<h5 id="Incremental"><a href="#Incremental" class="headerlink" title="Incremental"></a>Incremental</h5><blockquote>
<p>增量回收。针对一个大对象的回收，将完整的 GC 任务拆分为多个小任务，交替执行 GC 和 JavaScript 代码<br>老生代的标记阶段 (Marking)<br>可以避免长时间卡顿，但是需要处理两个问题</p>
</blockquote>
<ol>
<li><p>如何保存上一次的扫描结果：三色标记位 + <strong>标记工作表</strong></p>
<ul>
<li>三种颜色：白色(00)、灰色(10)、黑色(11)</li>
<li>初始状态，所有对象均为<code>白色</code>：未被根节点引用到的对象</li>
<li>当 GC 发现一个对象被引用，将会标记为<code>灰色</code>，并将其推入到<strong>标记工作表</strong>中</li>
<li><strong>标记工作表</strong>访问所有存在的<code>灰色</code>对象及其所有子对象，结束后会将该对象标记为<code>黑色</code></li>
<li>持续向表中添加<code>灰色</code>对象</li>
<li>处理完表中的<code>灰色</code>对象直至没有灰色对象，即所有对象均为白色或黑色，之后清理掉所有<code>白色</code>的对象</li>
</ul>
</li>
<li><p>如何处理标记好的数据被主线程修改：写屏障 <code>Write Barrier</code></p>
<ul>
<li>避免漏标 (Missed Mark) 和错标 (False Retention)</li>
<li>增量写屏障：强制让<code>黑色</code>对象不能直接指向<code>白色</code>对象，将新写入的对象从初始的白色直接变为灰色，<strong>标记工作表</strong> 继续工作</li>
<li>并发写屏障：使用<strong>记忆集 (Remembered Set)</strong>记录跨代引用 (如老生代对象引用新生代对象)</li>
<li>卡表 (Card Table)：将堆内存分块 (如 512B 一块)，通过卡表标记脏块 (含引用变化的块)。减少写屏障开销，只需标记卡表，GC 时仅扫描脏块</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 漏标</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">&quot;A&quot;</span> &#125;; <span class="comment">// 黑色（已标记）</span></span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">name</span>: <span class="string">&quot;B&quot;</span> &#125;; <span class="comment">// 白色（未标记）</span></span><br><span class="line">a.<span class="property">ref</span> = b; <span class="comment">// 如果 GC 不感知此修改，b 可能被误回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错标</span></span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">name</span>: <span class="string">&quot;A&quot;</span> &#125;; <span class="comment">// 色（已标记）</span></span><br><span class="line">c = <span class="literal">null</span>; <span class="comment">// 如果 GC 不感知此修改，c 无法回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化的增量写屏障逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">writeBarrier</span>(<span class="params">obj, field, newValue</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 实际执行写操作</span></span><br><span class="line">  obj[field] = newValue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果 GC 正在标记阶段，处理引用变化</span></span><br><span class="line">  <span class="keyword">if</span> (gcPhase === <span class="string">&quot;MARKING&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isMarked</span>(obj) &amp;&amp; !<span class="title function_">isMarked</span>(newValue)) &#123;</span><br><span class="line">      <span class="comment">// 将新引用的对象标记为灰色（待扫描）</span></span><br><span class="line">      <span class="title function_">markAsGrey</span>(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h5><blockquote>
<p>并发回收。完全在后台线程执行 GC，主线程继续运行 JavaScript<br>老生代的标记阶段 (Marking) 和内存整理 (Compaction)<br>主线程几乎无感知，但是需要解决并发冲突 (如对象被 JavaScript 修改时，GC 线程需同步)</p>
</blockquote>
<p><img src="/images/front-tech/v8_10.png" alt=""></p>
<h3 id="协程-线程-进程"><a href="#协程-线程-进程" class="headerlink" title="协程 / 线程 / 进程"></a>协程 / 线程 / 进程</h3><ul>
<li>Process: <strong>操作系统资源分配的基本单位</strong>，每个进程有独立的内存空间 (代码、数据、堆栈), 进程间通信(IPC)需要通过 管道、消息队列、共享内存、Socket 等方式</li>
<li>Thread: <strong>CPU 调度的基本单位</strong>，属于同一进程的线程共享内存空间, 线程间可直接读写同一进程的变量，但需要同步机制 (如锁、信号量)</li>
<li>Coroutine: <strong>用户态轻量级线程</strong>，由程序控制调度 (而非操作系统), 协程在单线程内实现任务切换，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协，通过 <code>yield/resume</code> 主动让出执行权。是 generator、async / await 实现异步编程的核心逻辑，await 暂停协程，Promise.resolve 后恢复协程</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr>
<td>调度单位</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户程序</td>
</tr>
<tr>
<td>内存隔离</td>
<td>完全隔离</td>
<td>共享同一进程内存</td>
<td>共享同一线程内存</td>
</tr>
<tr>
<td>上下文切换成本</td>
<td>高 (需切换页表等)</td>
<td>中 (需切换寄存器)</td>
<td>极低 (仅切换局部变量)</td>
</tr>
<tr>
<td>通信方式</td>
<td>IPC (管道、Socket 等)</td>
<td>共享内存 (需同步)</td>
<td>直接共享变量</td>
</tr>
<tr>
<td>多核并行能力</td>
<td>是</td>
<td>是</td>
<td>否 (需结合多线程)</td>
</tr>
<tr>
<td>典型应用</td>
<td>Chrome 多标签页</td>
<td>Java 多线程服务器</td>
<td>Go 的 goroutine</td>
</tr>
</tbody>
</table>
</div>
<h3 id="机器码-字节码"><a href="#机器码-字节码" class="headerlink" title="机器码 / 字节码"></a>机器码 / 字节码</h3><blockquote>
<p>现阶段的 V8 采用基于寄存器的编译器，带有一个累加器 (accumulator)，通过累加器来暂存中间变量</p>
</blockquote>
<p>早期的 V8 为了提升代码的执行速度，直接将 JavaScript 源代码编译成了没有优化的二进制机器代码，如果某一段二进制代码执行频率过高，那么 V8 会将其标记为热点代码，热点代码会被优化编译器优化，优化后的机器代码执行效率更高。但存在致命问题，于是引入中间字节码</p>
<ul>
<li>时间问题：编译时间过久，影响代码启动速度</li>
<li>空间问题：缓存编译后的二进制代码占用更多的内存</li>
</ul>
<p>字节码优势</p>
<ul>
<li>解决启动问题：生成字节码的时间很短</li>
<li>解决空间问题：相较于机器代码，字节码体积减小很多，缓存字节码很大程度上降低了内存的使用</li>
<li>代码架构清晰：简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易</li>
</ul>
<h4 id="常用字节码指令"><a href="#常用字节码指令" class="headerlink" title="常用字节码指令"></a>常用字节码指令</h4><ul>
<li>Ldar: Load accumulator Register, 表示将寄存器中的值加载到累加器中</li>
<li>Star: Store accumulator Register, 表示把累加器中的值保存到某个寄存器中</li>
<li>Add: <strong>Add a0 [0]</strong>, 从 a0 寄存器加载值并将其与累加器中的值相加，将结果再次放入累加器。<strong>[0]</strong> 是反馈向量槽 (feedback vector slot)，一个数组，解释器将解释执行过程中的一些数据类型的分析信息都保存在这个反馈向量槽中了，目的是给 TurboFan 优化编译器提供优化信息，很多字节码都会为反馈向量槽提供运行时信息</li>
<li>LdaSmi: 将小整数 (Smi)加载到累加器寄存器中</li>
<li>Return: 结束当前函数的执行，并将控制权传回给调用方，返回累加器中的值</li>
</ul>
<h2 id="提升-JS-性能的技巧"><a href="#提升-JS-性能的技巧" class="headerlink" title="提升 JS 性能的技巧"></a>提升 JS 性能的技巧</h2><blockquote>
<p>V8 动态跟踪数组的元素类型，共 21 种内部表示</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>示例</th>
<th>优化等级</th>
</tr>
</thead>
<tbody>
<tr>
<td>PACKED_SMI_ELEMENTS</td>
<td>[1, 2, 3]</td>
<td>最高效</td>
</tr>
<tr>
<td>PACKED_DOUBLE_ELEMENTS</td>
<td>[1.1, 2.2]</td>
<td>次高效</td>
</tr>
<tr>
<td>PACKED_ELEMENTS</td>
<td>[‘a’, {}]</td>
<td>基础</td>
</tr>
<tr>
<td>HOLEY_ 变体*</td>
<td>[1, , ‘x’]</td>
<td>较低效</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>在构造函数里初始化所有对象的成员</li>
<li>总是以相同的次序初始化对象成员</li>
<li>尽量使用可以用 31 位有符号整数表示的数</li>
<li><p>为数组使用从 0 开始的连续的主键，保持数组密集型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐：预先填充undefined而非留空位</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">const</span> badArr = [<span class="number">1</span>, , <span class="number">3</span>]; <span class="comment">// 创建HOLEY数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要预分配大数组 (比如元素占用内存大于 64K 字节)到其最大尺寸，可能从线性存储模式降级为字典存储模式，慢慢增大数组即可</p>
</li>
<li>不要删除数组里的元素，尤其是数字数组</li>
<li>不要加载未初始化或已删除的元素</li>
<li><p>对于固定大小的数组，使用 <code>array literals</code> 初始化 (初始化小额定长数组时，用字面量进行初始化)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量（推荐）：引擎可静态分析优化</span></span><br><span class="line"><span class="keyword">const</span> literal = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数（动态分配，优化受限）</span></span><br><span class="line"><span class="keyword">const</span> constructed = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> fromed = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>小数组(小于 64k)在使用之前先预分配正确的尺寸</p>
</li>
<li>请勿在数字数组中存放非数字的值(对象)</li>
<li><p>尽量使用单一类型 (monomorphic) 而不是多类型 (polymorphic) (如果通过非字面量进行初始化小数组时，切勿触发类型的重新转换)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持单一元素类型（最高效）</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// PACKED_SMI_ELEMENTS</span></span><br><span class="line">nums.<span class="title function_">push</span>(<span class="number">4.5</span>); <span class="comment">// → PACKED_DOUBLE（性能损耗）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合类型会降级</span></span><br><span class="line"><span class="keyword">const</span> mixed = [<span class="number">1</span>, <span class="string">&quot;a&quot;</span>]; <span class="comment">// → PACKED_ELEMENTS</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用 try{} catch{} (如果存在 try/catch 代码快，则将性能敏感的代码放到一个嵌套的函数中)</p>
</li>
<li>在优化后避免在方法中修改隐藏类</li>
</ol>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><blockquote>
<p>包含空位 (holes) 的数组，会引发显著的性能下降</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式空位</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, , <span class="number">3</span>]; <span class="comment">// 索引1处为空位</span></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000</span>); <span class="comment">// 1000个空位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式产生空位</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> arr3[<span class="number">1</span>]; <span class="comment">// 索引1变为空位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否为稀疏数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> <span class="keyword">in</span> arr1); <span class="comment">// false（说明索引1是空位）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2.<span class="title function_">hasOwnProperty</span>(<span class="number">500</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>性能问题</p>
</blockquote>
<ul>
<li>密集数组 (Packed): 连续内存块，访问复杂度为 O(1)</li>
<li>稀疏数组 (Holey): 哈希表/特殊标记，访问复杂度为 O(n)~O(1)，无法应用 SIMD 指令优化，一旦变为 HOLEY 类型，即使填充空位也无法恢复 PACKED 状态，隐藏类更加复杂，大程度增加 GC 扫描时间</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/441313455">详解 Chrome V8 引擎</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://nanyin.me">南音</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://nanyin.me/articles/front-tech/v8/">https://nanyin.me/articles/front-tech/v8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://nanyin.me" target="_blank">Nanyin の 小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%95%E6%93%8E/">引擎</a></div><div class="post-share"><div class="social-share" data-image="/img/covers/uVz3uC4fYBEfFOAI.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">南音</div><div class="author-info-description">2025年的愿望实现了吗</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hinanyin"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/hinanyin" target="_blank" title="Github"><i class="iconfont icon-github" style="color: #000000;"></i></a><a class="social-icon" href="tencent://message/?uin=1561682937" target="_blank" title="QQ"><i class="iconfont icon-qq" style="color: #1296db;"></i></a><a class="social-icon" href="https://space.bilibili.com/14896283" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili" style="color: #fb7299;"></i></a><a class="social-icon" href="mailto:1561682937@qq.com" target="_blank" title="Email"><i class="iconfont icon-email" style="color: #ffbf00;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果阅读过程中遇到了问题，请及时评论或者留言，有看到会在第一时间给出回复 🎉🎉🎉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">浏览器架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">Chrome 多进程架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-number">1.2.</span> <span class="toc-text">浏览器内核</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E7%89%88%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.1.</span> <span class="toc-text">排版渲染引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.2.</span> <span class="toc-text">内核引擎</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%BC%95%E6%93%8E"><span class="toc-number">2.</span> <span class="toc-text">JavaScript 引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8"><span class="toc-number">3.</span> <span class="toc-text">V8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8F%8A%E8%BF%90%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">编译及运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">编译过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">运行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">3.2.</span> <span class="toc-text">三大核心优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E7%BC%96%E8%AF%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">惰性编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">内联缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E9%A6%88%E5%90%91%E9%87%8F"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">反馈向量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%B1%BB"><span class="toc-number">3.2.3.</span> <span class="toc-text">隐藏类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8-%E4%B8%8E-JS"><span class="toc-number">3.3.</span> <span class="toc-text">V8 与 JS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%B1%9E%E6%80%A7"><span class="toc-number">3.3.1.</span> <span class="toc-text">对象内属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E5%B1%9E%E6%80%A7-%E6%85%A2%E5%B1%9E%E6%80%A7"><span class="toc-number">3.3.2.</span> <span class="toc-text">快属性 &#x2F; 慢属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E3%80%81%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">动态、静态作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E8%A7%A3%E6%9E%90"><span class="toc-number">3.3.4.</span> <span class="toc-text">惰性解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E8%A7%A3%E6%9E%90-%E5%85%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">3.3.5.</span> <span class="toc-text">预解析 &#x2F; 全解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.4.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">堆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.5.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.1.</span> <span class="toc-text">垃圾数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.5.3.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">副垃圾回收器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">主垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">3.5.4.</span> <span class="toc-text">垃圾回收优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">Parallel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Incremental"><span class="toc-number">3.5.4.2.</span> <span class="toc-text">Incremental</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Concurrent"><span class="toc-number">3.5.4.3.</span> <span class="toc-text">Concurrent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">协程 &#x2F; 线程 &#x2F; 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">3.7.</span> <span class="toc-text">机器码 &#x2F; 字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-number">3.7.1.</span> <span class="toc-text">常用字节码指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8D%87-JS-%E6%80%A7%E8%83%BD%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">4.</span> <span class="toc-text">提升 JS 性能的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.</span> <span class="toc-text">稀疏数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/articles/front-tech/v8/" title="v8 引擎简介"><img src="/img/covers/uVz3uC4fYBEfFOAI.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="v8 引擎简介"/></a><div class="content"><a class="title" href="/articles/front-tech/v8/" title="v8 引擎简介">v8 引擎简介</a><time datetime="2025-04-02T07:29:01.000Z" title="发表于 2025-04-02 15:29:01">2025-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/front-tech/chromePlugin/" title="chrome 扩展"><img src="/img/covers/uQgFBS9Q4E8VZl6q.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chrome 扩展"/></a><div class="content"><a class="title" href="/articles/front-tech/chromePlugin/" title="chrome 扩展">chrome 扩展</a><time datetime="2025-03-25T09:36:22.000Z" title="发表于 2025-03-25 17:36:22">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/front-tech/vscodePlugin/" title="vsCode 插件"><img src="/img/covers/uJ8e1Jwr9Syrsuv7.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vsCode 插件"/></a><div class="content"><a class="title" href="/articles/front-tech/vscodePlugin/" title="vsCode 插件">vsCode 插件</a><time datetime="2025-03-14T10:11:57.000Z" title="发表于 2025-03-14 18:11:57">2025-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/front-tech/cli/" title="脚手架实现"><img src="/img/covers/uJ1Pv34lRqnQH5s2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="脚手架实现"/></a><div class="content"><a class="title" href="/articles/front-tech/cli/" title="脚手架实现">脚手架实现</a><time datetime="2025-03-07T07:02:44.000Z" title="发表于 2025-03-07 15:02:44">2025-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/python/introduce/" title="Python 语言简介"><img src="/img/covers/utPZNZGk5yrYGxBZ.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 语言简介"/></a><div class="content"><a class="title" href="/articles/python/introduce/" title="Python 语言简介">Python 语言简介</a><time datetime="2025-03-05T08:53:18.000Z" title="发表于 2025-03-05 16:53:18">2025-03-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2025 By 南音</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"requiredMeta":["nick","mail"],"locale":{"placeholder":"昵称和邮箱为必填项，为了您能及时收到相关回复的邮件通知，请确保邮箱的正确性！"},"emoji":["//unpkg.com/@waline/emojis@1.2.0/bmoji","//unpkg.com/@waline/emojis@1.2.0/bilibili"],"search":true}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.nanyin.me/',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script defer src="//clustrmaps.com/globe.js?d=5V2tOKp8qAdRM-i8eu7ETTO9ugt5uKbbG-U7Yj8uMl8"></script><script defer src="/live2d-widget/autoload.js"></script><meting-js class="no-destroy" id="8932390" server="netease" type="playlist" fixed="true" autoplay="false" order="random" volume="0.3" list-folded="false" list-max-height="36vh"> </meting-js><script async src="/js/grayscale.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://npm.elemecdn.com/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/aplayer/dist/APlayer.min.js"></script><script src="https://npm.elemecdn.com/meting/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v3.8.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用双线部署，默认线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用双线部署，联通线路托管于Coding" title=""><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/footer-beautify-runtime.js"></script><!-- hexo injector body_end end --></body></html>